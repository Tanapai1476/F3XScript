local function applyAngularOscillate(ang1, ang2, time, easingType, directionMode)
        easingType = easingType or "Linear"
        directionMode = directionMode or "InOut"
        
        for _, part in ipairs(selectedParts) do
            replicateToServer(function()
                setNetworkOwnership(part)
                
                if angularOscillateParts[part] then
                    if angularOscillateParts[part].connection then angularOscillateParts[part].connection:Disconnect() end
                    if angularOscillateParts[part].bodyGyro then angularOscillateParts[part].bodyGyro:Destroy() end
                    if angularOscillateParts[part].bodyPosition then angularOscillateParts[part].bodyPosition:Destroy() end
                    if angularOscillateParts[part].vectorForce then angularOscillateParts[part].vectorForce:Destroy() end
                    if angularOscillateParts[part].attachment then angularOscillateParts[part].attachment:Destroy() end
                end
                
                local bodyPosition = Instance.new("BodyPosition")
                bodyPosition.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                bodyPosition.Position = part.Position
                bodyPosition.D = 5000
                bodyPosition.P = 50000
                bodyPosition.Parent = part
                
                local bodyGyro = Instance.new("BodyGyro")
                bodyGyro.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
                bodyGyro.D = 5000
                bodyGyro.P = 50000
                bodyGyro.Parent = part
                
                local attachment = Instance.new("Attachment")
                attachment.Parent = part
                
                local vectorForce = Instance.new("VectorForce")
                vectorForce.Attachment0 = attachment
                vectorForce.ApplyAtCenterOfMass = true
                vectorForce.RelativeTo = Enum.ActuatorRelativeTo.World
                vectorForce.Force = Vector3.new(0, part.Mass * workspace.Gravity, 0)
                vectorForce.Parent = part
                
                local baseRotation = part.CFrame - part.CFrame.Position
                local rotation1 = CFrame.Angles(math.rad(ang1.X), math.rad(ang1.Y), math.rad(ang1.Z))
                local rotation2 = CFrame.Angles(math.rad(ang2.X), math.rad(ang2.Y), math.rad(ang2.Z))
                local movingToAng1 = true
                local startTime = tick()
                
                local function easingFunction(t, easingType, directionMode)
                    if directionMode == "Linear" or easingType == "Linear" then return t end
                    if easingType == "Constant" then return t < 1 and 0 or 1 end
                    local isToAng1 = movingToAng1
                    if easingType == "Quadratic" then
                        if directionMode == "InOut" then return isToAng1 and t * t or 1 - (1 - t) * (1 - t)
                        elseif directionMode == "InIn" then return t * t
                        else return 1 - (1 - t) * (1 - t) end
                    elseif easingType == "Cubic" then
                        if directionMode == "InOut" then return isToAng1 and t * t * t or 1 - math.pow(1 - t, 3)
                        elseif directionMode == "InIn" then return t * t * t
                        else return 1 - math.pow(1 - t, 3) end
                    elseif easingType == "Sine" then
                        if directionMode == "InOut" then return isToAng1 and 1 - math.cos((t * math.pi) / 2) or math.sin((t * math.pi) / 2)
                        elseif directionMode == "InIn" then return 1 - math.cos((t * math.pi) / 2)
                        else return math.sin((t * math.pi) / 2) end
                    elseif easingType == "Exponential" then
                        if directionMode == "InOut" then return isToAng1 and (t == 0 and 0 or math.pow(2, 10 * (t - 1))) or (t == 1 and 1 or 1 - math.pow(2, -10 * t))
                        elseif directionMode == "InIn" then return t == 0 and 0 or math.pow(2, 10 * (t - 1))
                        else return t == 1 and 1 or 1 - math.pow(2, -10 * t) end
                    end
                    return t
                end
                
                local connection = RunService.Heartbeat:Connect(function()
                    if not part.Parent then connection:Disconnect() return end
                    
                    local elapsed = (tick() - startTime) % (time * 2)
                    local alpha, targetRotation
                    
                    if elapsed < time then
                        movingToAng1 = true
                        alpha = elapsed / time
                        targetRotation = rotation1
                    else
                        movingToAng1 = false
                        alpha = (elapsed - time) / time
                        targetRotation = rotation2
                    end
                    
                    local easedAlpha = easingFunction(alpha, easingType, directionMode)
                    local currentRotation = (movingToAng1 and baseRotation or (baseRotation * rotation1)):Lerp(baseRotation * targetRotation, easedAlpha)
                    
                    bodyPosition.Position = part.Position
                    bodyGyro.CFrame = CFrame.new(part.Position) * currentRotation
                    part.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                    part.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                end)
                
                angularOscillateParts[part] = {bodyGyro = bodyGyro, bodyPosition = bodyPosition, attachment = attachment, vectorForce = vectorForce, connection = connection}
                print("Applied Angular Oscillate to " .. part.Name)
            end)
        end
    end-- Physics Apply Tool - LocalScript with Server Replication for Executors
-- ENHANCED VERSION with Constraint Modes, New Features, and Extras
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local StarterGui = game:GetService("StarterGui")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")
local toolPersistent = false

-- NEW: Constraint settings
local constraintMode = "Core" -- "Core" or "Face"
local constraintVisual = false
local constraintCollision = true
local selectedFaces = {} -- {part1 = Vector3.new(0,1,0), part2 = Vector3.new(0,-1,0)}

-- NEW: Physics extras storage
local showForcesVisuals = {}
local frozenMotionParts = {}
local timeScaleActive = false
local currentTimeScale = 1
local physicsRecordings = {}
local gravityGunActive = false
local gravityGunPart = nil
local physicsPaints = {}
local kineticAmplifiers = {}
local blackHoles = {}
local buoyancyParts = {}
local momentumAbsorbers = {}
local forceReflectors = {}
local gravityDistorters = {}
local shockwaveGenerators = {}
local exclusiveZeroGravity = false
local exclusiveZeroGravityConnection = nil
local orbiterCores = {}
local exponentialTweenParts = {}

local function createNotificationGui()
    local notificationGui = Instance.new("ScreenGui")
    notificationGui.Name = "PhysicsToolNotification"
    notificationGui.ResetOnSpawn = false
    notificationGui.Parent = playerGui
    
    local notificationFrame = Instance.new("Frame")
    notificationFrame.Size = UDim2.new(0, 400, 0, 200)
    notificationFrame.Position = UDim2.new(0.5, -200, 0.5, -100)
    notificationFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
    notificationFrame.BorderSizePixel = 0
    notificationFrame.Parent = notificationGui
    
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 12)
    corner.Parent = notificationFrame
    
    local shadow = Instance.new("Frame")
    shadow.Size = UDim2.new(1, 10, 1, 10)
    shadow.Position = UDim2.new(0, -5, 0, -5)
    shadow.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    shadow.BackgroundTransparency = 0.5
    shadow.BorderSizePixel = 0
    shadow.ZIndex = notificationFrame.ZIndex - 1
    shadow.Parent = notificationGui
    
    local shadowCorner = Instance.new("UICorner")
    shadowCorner.CornerRadius = UDim.new(0, 12)
    shadowCorner.Parent = shadow
    
    local titleLabel = Instance.new("TextLabel")
    titleLabel.Size = UDim2.new(1, -20, 0, 40)
    titleLabel.Position = UDim2.new(0, 10, 0, 10)
    titleLabel.BackgroundTransparency = 1
    titleLabel.Text = "ðŸ”§ Physics Apply Tool"
    titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    titleLabel.TextSize = 20
    titleLabel.Font = Enum.Font.GothamBold
    titleLabel.Parent = notificationFrame
    
    local questionLabel = Instance.new("TextLabel")
    questionLabel.Size = UDim2.new(1, -20, 0, 60)
    questionLabel.Position = UDim2.new(0, 10, 0, 60)
    questionLabel.BackgroundTransparency = 1
    questionLabel.Text = "Force Enable Inventory?\n\nThis will give you the physics tool permanently\neven after respawning."
    questionLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
    questionLabel.TextSize = 14
    questionLabel.Font = Enum.Font.Gotham
    questionLabel.TextWrapped = true
    questionLabel.Parent = notificationFrame
    
    local yesButton = Instance.new("TextButton")
    yesButton.Size = UDim2.new(0, 120, 0, 40)
    yesButton.Position = UDim2.new(0, 50, 1, -60)
    yesButton.BackgroundColor3 = Color3.fromRGB(50, 150, 50)
    yesButton.BorderSizePixel = 0
    yesButton.Text = "âœ“ YES"
    yesButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    yesButton.TextSize = 16
    yesButton.Font = Enum.Font.GothamBold
    yesButton.Parent = notificationFrame
    
    local yesCorner = Instance.new("UICorner")
    yesCorner.CornerRadius = UDim.new(0, 8)
    yesCorner.Parent = yesButton
    
    local noButton = Instance.new("TextButton")
    noButton.Size = UDim2.new(0, 120, 0, 40)
    noButton.Position = UDim2.new(1, -170, 1, -60)
    noButton.BackgroundColor3 = Color3.fromRGB(150, 50, 50)
    noButton.BorderSizePixel = 0
    noButton.Text = "âœ— NO"
    noButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    noButton.TextSize = 16
    noButton.Font = Enum.Font.GothamBold
    noButton.Parent = notificationFrame
    
    local noCorner = Instance.new("UICorner")
    noCorner.CornerRadius = UDim.new(0, 8)
    noCorner.Parent = noButton
    
    yesButton.MouseEnter:Connect(function()
        TweenService:Create(yesButton, TweenInfo.new(0.2), {BackgroundColor3 = Color3.fromRGB(70, 170, 70)}):Play()
    end)
    
    yesButton.MouseLeave:Connect(function()
        TweenService:Create(yesButton, TweenInfo.new(0.2), {BackgroundColor3 = Color3.fromRGB(50, 150, 50)}):Play()
    end)
    
    noButton.MouseEnter:Connect(function()
        TweenService:Create(noButton, TweenInfo.new(0.2), {BackgroundColor3 = Color3.fromRGB(170, 70, 70)}):Play()
    end)
    
    noButton.MouseLeave:Connect(function()
        TweenService:Create(noButton, TweenInfo.new(0.2), {BackgroundColor3 = Color3.fromRGB(150, 50, 50)}):Play()
    end)
    
    notificationFrame.Position = UDim2.new(0.5, -200, -1, 0)
    shadow.Position = UDim2.new(0, -5, -1, -5)
    
    TweenService:Create(notificationFrame, TweenInfo.new(0.5, Enum.EasingStyle.Back, Enum.EasingDirection.Out), 
        {Position = UDim2.new(0.5, -200, 0.5, -100)}):Play()
    TweenService:Create(shadow, TweenInfo.new(0.5, Enum.EasingStyle.Back, Enum.EasingDirection.Out), 
        {Position = UDim2.new(0, -5, 0, -5)}):Play()
    
    return notificationGui, yesButton, noButton
end

local function createPhysicsTool()
    local backpack = player:WaitForChild("Backpack")
    
    local tool = Instance.new("Tool")
    tool.Name = "Physics Apply Tool"
    tool.RequiresHandle = false
    tool.Parent = backpack

    local screenGui
    local mainFrame
    local selectedParts = {}
    local selectionBoxes = {}
    local currentPanel = nil
    local isToolEquipped = false
    local studSelectMode = false
    local selectedStuds = {}

    local velocityControls = {}
    local angularControls = {}
    local gravityForces = {}
    local weightForces = {}
    local gyroStabilizers = {}
    local frozenFlingers = {}
    local positionLocks = {}

    local tpLockedPart = nil
    local tpLockEnabled = false
    local tpAtCursorEnabled = false
    local tpSelectionBox = nil
    local mouse = nil

    local function setNetworkOwnership(part)
        pcall(function()
            if part.Parent and part.Parent ~= player.Character then
                if part.AssemblyRootPart then
                    part.AssemblyRootPart:SetNetworkOwner(player)
                else
                    part:SetNetworkOwner(player)
                end
            end
        end)
    end

    local function replicateToServer(func)
        local success = pcall(func)
        if success then task.wait() end
    end

    local function createPanel(parent, title, layoutOrder)
        local panel = Instance.new("Frame")
        panel.Name = title:gsub("[^%w]", "")
        panel.LayoutOrder = layoutOrder
        panel.BackgroundColor3 = Color3.fromRGB(50, 50, 60)
        panel.BorderSizePixel = 0
        panel.Parent = parent
        
        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 8)
        corner.Parent = panel
        
        local header = Instance.new("Frame")
        header.Size = UDim2.new(1, 0, 0, 30)
        header.BackgroundColor3 = Color3.fromRGB(60, 60, 70)
        header.BorderSizePixel = 0
        header.Parent = panel
        
        local headerCorner = Instance.new("UICorner")
        headerCorner.CornerRadius = UDim.new(0, 8)
        headerCorner.Parent = header
        
        local titleLabel = Instance.new("TextLabel")
        titleLabel.Size = UDim2.new(1, -40, 1, 0)
        titleLabel.Position = UDim2.new(0, 10, 0, 0)
        titleLabel.BackgroundTransparency = 1
        titleLabel.Text = title
        titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
        titleLabel.TextSize = 14
        titleLabel.TextXAlignment = Enum.TextXAlignment.Left
        titleLabel.Font = Enum.Font.GothamSemibold
        titleLabel.Parent = header
        
        local closeBtn = Instance.new("TextButton")
        closeBtn.Size = UDim2.new(0, 20, 0, 20)
        closeBtn.Position = UDim2.new(1, -25, 0, 5)
        closeBtn.BackgroundColor3 = Color3.fromRGB(200, 60, 60)
        closeBtn.BorderSizePixel = 0
        closeBtn.Text = "Ã—"
        closeBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
        closeBtn.TextSize = 14
        closeBtn.Font = Enum.Font.GothamBold
        closeBtn.Parent = header
        
        local closeBtnCorner = Instance.new("UICorner")
        closeBtnCorner.CornerRadius = UDim.new(0, 4)
        closeBtnCorner.Parent = closeBtn
        
        closeBtn.MouseButton1Click:Connect(function()
            panel.Visible = false
        end)
        
        -- Make panels draggable
        local dragging = false
        local dragStart = nil
        local startPos = nil
        
        header.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                dragging = true
                dragStart = input.Position
                startPos = panel.Position
                
                -- Bring to front
                panel.ZIndex = 10
            end
        end)
        
        header.InputChanged:Connect(function(input)
            if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
                local delta = input.Position - dragStart
                panel.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
            end
        end)
        
        header.InputEnded:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                dragging = false
                panel.ZIndex = 1
            end
        end)
        
        UserInputService.InputEnded:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                dragging = false
                panel.ZIndex = 1
            end
        end)
        
        return panel
    end

    local function createButton(parent, text, size, position)
        local button = Instance.new("TextButton")
        button.Size = size
        button.Position = position
        button.BackgroundColor3 = Color3.fromRGB(70, 130, 180)
        button.BorderSizePixel = 0
        button.Text = text
        button.TextColor3 = Color3.fromRGB(255, 255, 255)
        button.TextSize = 12
        button.Font = Enum.Font.GothamSemibold
        button.Parent = parent
        
        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 6)
        corner.Parent = button
        
        button.MouseEnter:Connect(function()
            TweenService:Create(button, TweenInfo.new(0.2), {BackgroundColor3 = Color3.fromRGB(90, 150, 200)}):Play()
        end)
        
        button.MouseLeave:Connect(function()
            TweenService:Create(button, TweenInfo.new(0.2), {BackgroundColor3 = Color3.fromRGB(70, 130, 180)}):Play()
        end)
        
        return button
    end

    local function createToggleButton(parent, text, size, position, initialState)
        initialState = initialState or false
        
        local button = Instance.new("TextButton")
        button.Size = size
        button.Position = position
        button.BorderSizePixel = 0
        button.Text = text
        button.TextColor3 = Color3.fromRGB(255, 255, 255)
        button.TextSize = 12
        button.Font = Enum.Font.GothamSemibold
        button.Parent = parent
        
        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 6)
        corner.Parent = button
        
        local function updateButtonColor(state)
            button.BackgroundColor3 = state and Color3.fromRGB(50, 150, 50) or Color3.fromRGB(150, 50, 50)
        end
        
        updateButtonColor(initialState)
        button:SetAttribute("ToggleState", initialState)
        
        button.MouseEnter:Connect(function()
            local currentColor = button.BackgroundColor3
            local hoverColor = Color3.new(
                math.min(currentColor.R + 0.1, 1),
                math.min(currentColor.G + 0.1, 1),
                math.min(currentColor.B + 0.1, 1)
            )
            TweenService:Create(button, TweenInfo.new(0.2), {BackgroundColor3 = hoverColor}):Play()
        end)
        
        button.MouseLeave:Connect(function()
            updateButtonColor(button:GetAttribute("ToggleState"))
        end)
        
        return button, updateButtonColor
    end

    local function createNumberInput(parent, placeholder, position)
        local input = Instance.new("TextBox")
        input.Size = UDim2.new(0, 70, 0, 30)
        input.Position = position
        input.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
        input.BorderSizePixel = 0
        input.PlaceholderText = placeholder
        input.Text = "0"
        input.TextColor3 = Color3.fromRGB(255, 255, 255)
        input.TextSize = 12
        input.Font = Enum.Font.Gotham
        input.Parent = parent
        
        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 4)
        corner.Parent = input
        
        return input
    end

    local function createDropdown(parent, options)
        local dropdown = Instance.new("TextButton")
        dropdown.Size = UDim2.new(1, -20, 0, 30)
        dropdown.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
        dropdown.BorderSizePixel = 0
        dropdown.Text = options[1] .. " â–¼"
        dropdown.TextColor3 = Color3.fromRGB(255, 255, 255)
        dropdown.TextSize = 12
        dropdown.Font = Enum.Font.Gotham
        dropdown.Parent = parent
        
        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 4)
        corner.Parent = dropdown
        
        local currentIndex = 1
        dropdown.MouseButton1Click:Connect(function()
            currentIndex = currentIndex % #options + 1
            dropdown.Text = options[currentIndex] .. " â–¼"
        end)
        
        return dropdown
    end

    -- NEW: Get closest face on a part based on click position
    local function getClosestFace(part, position)
        local rel = part.CFrame:PointToObjectSpace(position)
        local size = part.Size/2
        local faces = {
            {Vector3.new(0,1,0), math.abs(rel.Y - size.Y)},
            {Vector3.new(0,-1,0), math.abs(rel.Y + size.Y)},
            {Vector3.new(1,0,0), math.abs(rel.X - size.X)},
            {Vector3.new(-1,0,0), math.abs(rel.X + size.X)},
            {Vector3.new(0,0,1), math.abs(rel.Z - size.Z)},
            {Vector3.new(0,0,-1), math.abs(rel.Z + size.Z)}
        }
        table.sort(faces, function(a,b) return a[2] < b[2] end)
        return faces[1][1]
    end

    -- NEW: Auto-detect touching faces between parts
    local function findTouchingFaces(part1, part2)
        local center1 = part1.Position
        local center2 = part2.Position
        local direction = (center2 - center1).Unit
        local localDir1 = part1.CFrame:VectorToObjectSpace(direction)
        local absX, absY, absZ = math.abs(localDir1.X), math.abs(localDir1.Y), math.abs(localDir1.Z)
        local face1
        if absX > absY and absX > absZ then
            face1 = localDir1.X > 0 and Vector3.new(1, 0, 0) or Vector3.new(-1, 0, 0)
        elseif absY > absZ then
            face1 = localDir1.Y > 0 and Vector3.new(0, 1, 0) or Vector3.new(0, -1, 0)
        else
            face1 = localDir1.Z > 0 and Vector3.new(0, 0, 1) or Vector3.new(0, 0, -1)
        end
        local localDir2 = part2.CFrame:VectorToObjectSpace(-direction)
        absX, absY, absZ = math.abs(localDir2.X), math.abs(localDir2.Y), math.abs(localDir2.Z)
        local face2
        if absX > absY and absX > absZ then
            face2 = localDir2.X > 0 and Vector3.new(1, 0, 0) or Vector3.new(-1, 0, 0)
        elseif absY > absZ then
            face2 = localDir2.Y > 0 and Vector3.new(0, 1, 0) or Vector3.new(0, -1, 0)
        else
            face2 = localDir2.Z > 0 and Vector3.new(0, 0, 1) or Vector3.new(0, 0, -1)
        end
        local surfacePos1 = (part1.Size / 2) * face1
        local surfacePos2 = (part2.Size / 2) * face2
        return face1, face2, surfacePos1, surfacePos2
    end
    
    -- NEW: Find furthest faces (opposite of Auto Face)
    local function findFurthestFaces(part1, part2)
        local center1 = part1.Position
        local center2 = part2.Position
        local direction = (center2 - center1).Unit
        
        -- For part1, find the face pointing AWAY from part2
        local localDir1 = part1.CFrame:VectorToObjectSpace(-direction)  -- Note: negative direction
        local absX, absY, absZ = math.abs(localDir1.X), math.abs(localDir1.Y), math.abs(localDir1.Z)
        local face1
        if absX > absY and absX > absZ then
            face1 = localDir1.X > 0 and Vector3.new(1, 0, 0) or Vector3.new(-1, 0, 0)
        elseif absY > absZ then
            face1 = localDir1.Y > 0 and Vector3.new(0, 1, 0) or Vector3.new(0, -1, 0)
        else
            face1 = localDir1.Z > 0 and Vector3.new(0, 0, 1) or Vector3.new(0, 0, -1)
        end
        
        -- For part2, find the face pointing AWAY from part1
        local localDir2 = part2.CFrame:VectorToObjectSpace(direction)  -- Note: positive direction
        absX, absY, absZ = math.abs(localDir2.X), math.abs(localDir2.Y), math.abs(localDir2.Z)
        local face2
        if absX > absY and absX > absZ then
            face2 = localDir2.X > 0 and Vector3.new(1, 0, 0) or Vector3.new(-1, 0, 0)
        elseif absY > absZ then
            face2 = localDir2.Y > 0 and Vector3.new(0, 1, 0) or Vector3.new(0, -1, 0)
        else
            face2 = localDir2.Z > 0 and Vector3.new(0, 0, 1) or Vector3.new(0, 0, -1)
        end
        
        local surfacePos1 = (part1.Size / 2) * face1
        local surfacePos2 = (part2.Size / 2) * face2
        return face1, face2, surfacePos1, surfacePos2
    end
    
    -- NEW: Find nearest neighboring part to a part
    local function findNearestNeighbor(part, candidateParts)
        local nearest = nil
        local nearestDist = math.huge
        for _, candidate in ipairs(candidateParts) do
            if candidate ~= part and candidate.Parent then
                local dist = (candidate.Position - part.Position).Magnitude
                if dist < nearestDist then
                    nearestDist = dist
                    nearest = candidate
                end
            end
        end
        return nearest
    end

    -- Helper function to determine constraint axis from face normal
    local function getConstraintAxisFromFace(faceNormal)
        local absX, absY, absZ = math.abs(faceNormal.X), math.abs(faceNormal.Y), math.abs(faceNormal.Z)
        
        if absY > absX and absY > absZ then
            return "Y" -- Top/Bottom faces
        elseif absX > absZ then
            return "X" -- Left/Right faces
        else
            return "Z" -- Front/Back faces
        end
    end
    
    -- NEW: Enhanced constraint application with modes including Auto Face
    -- NEW: Collision Constraint (opposite of NoCollision)
    local function applyCollisionConstraint()
        if #selectedParts < 2 then
            warn("Need 2 parts for Collision constraint")
            return
        end
        
        for i = 1, #selectedParts - 1 do
            for j = i + 1, #selectedParts do
                local part1, part2 = selectedParts[i], selectedParts[j]
                
                replicateToServer(function()
                    setNetworkOwnership(part1)
                    setNetworkOwnership(part2)
                    
                    -- Remove any existing NoCollisionConstraints between these parts
                    for _, constraint in ipairs(part1:GetChildren()) do
                        if constraint:IsA("NoCollisionConstraint") then
                            if constraint.Part0 == part2 or constraint.Part1 == part2 then
                                constraint:Destroy()
                            end
                        end
                    end
                    
                    -- Collision is default behavior, but we create a tag to track it
                    local collisionMarker = Instance.new("BoolValue")
                    collisionMarker.Name = "CollisionConstraintWith_" .. part2.Name
                    collisionMarker.Parent = part1
                    
                    print("âœ… Forced collision between " .. part1.Name .. " and " .. part2.Name)
                end)
            end
        end
    end
    
    local function removeAllCollisionConstraints()
        for _, part in ipairs(workspace:GetDescendants()) do
            if part:IsA("BasePart") then
                for _, child in ipairs(part:GetChildren()) do
                    if child:IsA("BoolValue") and child.Name:match("^CollisionConstraintWith_") then
                        child:Destroy()
                    end
                end
            end
        end
        print("Removed all Collision constraint markers")
    end

    local function applyConstraint(constraintType, showSpringVisual, chainMode)
        chainMode = chainMode or "Chain"
        
        if #selectedParts < 2 then
            warn("Need 2+ parts for constraints")
            return
        end
        
        -- Chain Mode: Connect parts in sequence (1â†’2, 2â†’3, 3â†’4, etc.)
        if chainMode == "Chain" then
            for i = 1, #selectedParts - 1 do
                local part1, part2 = selectedParts[i], selectedParts[i + 1]
                
                replicateToServer(function()
                    setNetworkOwnership(part1)
                    setNetworkOwnership(part2)
                    
                    local constraint
                    
                    if constraintType:find("Rope") then
                        constraint = Instance.new("RopeConstraint")
                        constraint.Length = (part1.Position - part2.Position).Magnitude
                        constraint.Visible = constraintVisual
                    elseif constraintType:find("Rod") then
                        constraint = Instance.new("RodConstraint")
                        constraint.Length = (part1.Position - part2.Position).Magnitude
                    elseif constraintType:find("Hinge") then
                        constraint = Instance.new("HingeConstraint")
                    elseif constraintType:find("BallSocket") then
                        constraint = Instance.new("BallSocketConstraint")
                    elseif constraintType:find("Chain") then
                        constraint = Instance.new("RopeConstraint")
                        constraint.Length = (part1.Position - part2.Position).Magnitude
                        constraint.Visible = constraintVisual
                        part1.CustomPhysicalProperties = PhysicalProperties.new(5, 0.3, 0.5)
                        part2.CustomPhysicalProperties = PhysicalProperties.new(5, 0.3, 0.5)
                    elseif constraintType:find("Plane") then
                        constraint = Instance.new("PlaneConstraint")
                        -- PlaneConstraint only uses Attachment0 (the plane surface)
                        -- Attachment1 is the part that can move along the plane
                    elseif constraintType:find("Cylindrical") then
                        constraint = Instance.new("CylindricalConstraint")
                    elseif constraintType:find("Prismatic") then
                        constraint = Instance.new("PrismaticConstraint")
                    elseif constraintType:find("Spring") then
                        constraint = Instance.new("SpringConstraint")
                        constraint.FreeLength = (part1.Position - part2.Position).Magnitude
                        constraint.Stiffness = 1000
                        constraint.Damping = 100
                        constraint.Visible = showSpringVisual or false
                    end
                    
                    if constraint then
                        local attachment1 = Instance.new("Attachment")
                        local attachment2 = Instance.new("Attachment")
                        
                        -- Set positions first
                        if constraintMode == "Face" then
                            local face1 = selectedFaces[part1] or Vector3.new(0,0,0)
                            local face2 = selectedFaces[part2] or Vector3.new(0,0,0)
                            attachment1.Position = (part1.Size/2) * face1
                            attachment2.Position = (part2.Size/2) * face2
                        elseif constraintMode == "Auto Face" then
                            local face1, face2 = findTouchingFaces(part1, part2)
                            attachment1.Position = (part1.Size/2) * face1
                            attachment2.Position = (part2.Size/2) * face2
                        elseif constraintMode == "Anti-AutoFace" then
                            local face1, face2 = findFurthestFaces(part1, part2)
                            attachment1.Position = (part1.Size/2) * face1
                            attachment2.Position = (part2.Size/2) * face2
                        end
                        
                        -- Parent attachments BEFORE setting orientation
                        attachment1.Parent = part1
                        attachment2.Parent = part2
                        
                        -- NOW set orientation after parenting
                        if constraintMode == "Face" or constraintMode == "Auto Face" then
                            local face1 = (constraintMode == "Face") and (selectedFaces[part1] or Vector3.new(0,0,0)) or findTouchingFaces(part1, part2)
                            
                            -- Auto-orient prismatic/cylindrical/plane constraints based on face
                            if constraint:IsA("PrismaticConstraint") or constraint:IsA("CylindricalConstraint") then
                                local axis = getConstraintAxisFromFace(face1)
                                if axis == "X" then
                                    attachment1.CFrame = attachment1.CFrame * CFrame.Angles(0, 0, math.rad(90))
                                    attachment2.CFrame = attachment2.CFrame * CFrame.Angles(0, 0, math.rad(90))
                                elseif axis == "Y" then
                                    -- Y is default, no rotation needed
                                else -- Z
                                    attachment1.CFrame = attachment1.CFrame * CFrame.Angles(math.rad(90), 0, 0)
                                    attachment2.CFrame = attachment2.CFrame * CFrame.Angles(math.rad(90), 0, 0)
                                end
                                print("ðŸ”§ Auto-oriented " .. constraintType .. " to " .. axis .. " axis")
                            elseif constraint:IsA("PlaneConstraint") then
                                -- Plane constraint needs proper orientation to work
                                local axis = getConstraintAxisFromFace(face1)
                                if axis == "X" then
                                    attachment1.CFrame = attachment1.CFrame * CFrame.Angles(0, math.rad(90), 0)
                                elseif axis == "Y" then
                                    -- Y is default
                                else -- Z
                                    attachment1.CFrame = attachment1.CFrame * CFrame.Angles(0, 0, math.rad(90))
                                end
                                print("ðŸ”§ Auto-oriented PlaneConstraint to " .. axis .. " axis")
                            end
                        end
                        
                        constraint.Attachment0 = attachment1
                        constraint.Attachment1 = attachment2
                        
                        if constraint:IsA("RopeConstraint") or constraint:IsA("RodConstraint") then
                            constraint.Visible = constraintVisual
                        end
                        
                        if not constraintCollision and constraint:FindFirstChild("LimitsEnabled") then
                            pcall(function() constraint.LimitsEnabled = false end)
                        end
                        
                        constraint.Parent = workspace
                        
                        print("Applied " .. constraintType .. " (" .. constraintMode .. ") between " .. part1.Name .. " and " .. part2.Name)
                    end
                end)
            end
        
        -- First to All Mode: Connect first part to all other parts (1â†’2, 1â†’3, 1â†’4, etc.)
        elseif chainMode == "First to All" then
            local firstPart = selectedParts[1]
            
            for i = 2, #selectedParts do
                local part2 = selectedParts[i]
                
                replicateToServer(function()
                    setNetworkOwnership(firstPart)
                    setNetworkOwnership(part2)
                    
                    local constraint
                    
                    if constraintType:find("Rope") then
                        constraint = Instance.new("RopeConstraint")
                        constraint.Length = (firstPart.Position - part2.Position).Magnitude
                        constraint.Visible = constraintVisual
                    elseif constraintType:find("Rod") then
                        constraint = Instance.new("RodConstraint")
                        constraint.Length = (firstPart.Position - part2.Position).Magnitude
                    elseif constraintType:find("Hinge") then
                        constraint = Instance.new("HingeConstraint")
                    elseif constraintType:find("BallSocket") then
                        constraint = Instance.new("BallSocketConstraint")
                    elseif constraintType:find("Chain") then
                        constraint = Instance.new("RopeConstraint")
                        constraint.Length = (firstPart.Position - part2.Position).Magnitude
                        constraint.Visible = constraintVisual
                        firstPart.CustomPhysicalProperties = PhysicalProperties.new(5, 0.3, 0.5)
                        part2.CustomPhysicalProperties = PhysicalProperties.new(5, 0.3, 0.5)
                    elseif constraintType:find("Plane") then
                        constraint = Instance.new("PlaneConstraint")
                    elseif constraintType:find("Cylindrical") then
                        constraint = Instance.new("CylindricalConstraint")
                    elseif constraintType:find("Prismatic") then
                        constraint = Instance.new("PrismaticConstraint")
                    elseif constraintType:find("Spring") then
                        constraint = Instance.new("SpringConstraint")
                        constraint.FreeLength = (firstPart.Position - part2.Position).Magnitude
                        constraint.Stiffness = 1000
                        constraint.Damping = 100
                        constraint.Visible = showSpringVisual or false
                    end
                    
                    if constraint then
                        local attachment1 = Instance.new("Attachment")
                        local attachment2 = Instance.new("Attachment")
                        
                        if constraintMode == "Face" then
                            local face1 = selectedFaces[firstPart] or Vector3.new(0,0,0)
                            local face2 = selectedFaces[part2] or Vector3.new(0,0,0)
                            attachment1.Position = (firstPart.Size/2) * face1
                            attachment2.Position = (part2.Size/2) * face2
                        elseif constraintMode == "Auto Face" then
                            local face1, face2 = findTouchingFaces(firstPart, part2)
                            attachment1.Position = (firstPart.Size/2) * face1
                            attachment2.Position = (part2.Size/2) * face2
                        elseif constraintMode == "Anti-AutoFace" then
                            local face1, face2 = findFurthestFaces(firstPart, part2)
                            attachment1.Position = (firstPart.Size/2) * face1
                            attachment2.Position = (part2.Size/2) * face2
                        end
                        
                        attachment1.Parent = firstPart
                        attachment2.Parent = part2
                        
                        constraint.Attachment0 = attachment1
                        constraint.Attachment1 = attachment2
                        
                        if constraint:IsA("RopeConstraint") or constraint:IsA("RodConstraint") then
                            constraint.Visible = constraintVisual
                        end
                        
                        if not constraintCollision and constraint:FindFirstChild("LimitsEnabled") then
                            pcall(function() constraint.LimitsEnabled = false end)
                        end
                        
                        constraint.Parent = workspace
                        
                        print("Applied " .. constraintType .. " (" .. constraintMode .. ") between " .. firstPart.Name .. " and " .. part2.Name)
                    end
                end)
            end
        end
    end

    local function applyVelocity(velocity, method, mode, keybind, velAxisMode)
        method = method or "BodyVelocity"
        mode = mode or "Always On"
        keybind = keybind or "W"
        velAxisMode = velAxisMode or "Off"
        
        for _, part in ipairs(selectedParts) do
            replicateToServer(function()
                setNetworkOwnership(part)
                
                if velocityControls[part] then
                    if velocityControls[part].bodyVel then
                        velocityControls[part].bodyVel:Destroy()
                    end
                    if velocityControls[part].vectorForce then
                        velocityControls[part].vectorForce:Destroy()
                    end
                    if velocityControls[part].attachment then
                        velocityControls[part].attachment:Destroy()
                    end
                    if velocityControls[part].connection then
                        velocityControls[part].connection:Disconnect()
                    end
                    if velocityControls[part].keybindConnection then
                        velocityControls[part].keybindConnection:Disconnect()
                    end
                    velocityControls[part] = nil
                end
                
                if velocity.Magnitude == 0 then
                    if not part.Anchored then
                        part.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                    end
                    print("Disabled velocity control for " .. part.Name)
                else
                    local bodyVel = nil
                    local vectorForce = nil
                    local attachment = nil
                    local connection = nil
                    local keybindConnection = nil
                    local isKeyDown = false
                    
                    -- Store initial CFrame for Velocity to Axis modes
                    local initialCFrame = part.CFrame
                    
                    -- Parse keybind
                    local keyEnum = nil
                    if keybind:len() == 1 then
                        keyEnum = Enum.KeyCode[keybind:upper()]
                    else
                        keyEnum = Enum.KeyCode[keybind]
                    end
                    
                    if mode == "Keybind Move" then
                        -- Setup keybind listeners
                        keybindConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
                            if gameProcessed then return end
                            if input.KeyCode == keyEnum then
                                isKeyDown = true
                            end
                        end)
                        
                        local keyUpConnection = UserInputService.InputEnded:Connect(function(input)
                            if input.KeyCode == keyEnum then
                                isKeyDown = false
                            end
                        end)
                    end
                    
                    if part.Anchored then
                        -- For anchored parts - push touching parts
                        connection = RunService.Heartbeat:Connect(function()
                            if part.Parent then
                                local shouldApply = (mode == "Always On") or (mode == "Keybind Move" and isKeyDown)
                                
                                if shouldApply then
                                    local touching = part:GetTouchingParts()
                                    local effectiveVel = velocity
                                    
                                    -- Handle velocity modes for anchored parts
                                    if velAxisMode == "Velocity to Axis" then
                                        effectiveVel = initialCFrame:VectorToWorldSpace(velocity)
                                    elseif velAxisMode == "Updating Velocity to Axis" or velAxisMode == "Thruster" then
                                        effectiveVel = part.CFrame:VectorToWorldSpace(velocity)
                                    end
                                    
                                    for _, touchingPart in pairs(touching) do
                                        if touchingPart ~= part and not touchingPart.Anchored and touchingPart.Parent ~= player.Character then
                                            touchingPart.AssemblyLinearVelocity = effectiveVel
                                        end
                                    end
                                end
                            else
                                connection:Disconnect()
                            end
                        end)
                        
                        print("Applied anchored velocity conveyor " .. tostring(velocity) .. " to " .. part.Name .. " (" .. mode .. ", " .. velAxisMode .. ")")
                        
                    else
                        -- For unanchored parts - use selected method
                        if method == "BodyVelocity" then
                            bodyVel = Instance.new("BodyVelocity")
                            bodyVel.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                            bodyVel.Velocity = Vector3.new(0, 0, 0)
                            bodyVel.Parent = part
                            
                            connection = RunService.Heartbeat:Connect(function()
                                if bodyVel.Parent and part.Parent then
                                    local shouldApply = (mode == "Always On") or (mode == "Keybind Move" and isKeyDown)
                                    
                                    if shouldApply then
                                        local effectiveVel = velocity
                                        
                                        -- Handle Velocity to Axis modes
                                        if velAxisMode == "Velocity to Axis" then
                                            effectiveVel = initialCFrame:VectorToWorldSpace(velocity)
                                        elseif velAxisMode == "Updating Velocity to Axis" or velAxisMode == "Thruster" then
                                            effectiveVel = part.CFrame:VectorToWorldSpace(velocity)
                                        end
                                        
                                        bodyVel.Velocity = effectiveVel
                                        part.AssemblyLinearVelocity = effectiveVel
                                    else
                                        bodyVel.Velocity = Vector3.new(0, 0, 0)
                                    end
                                else
                                    connection:Disconnect()
                                end
                            end)
                            
                            print("Applied BodyVelocity " .. tostring(velocity) .. " to " .. part.Name .. " (" .. mode .. ", " .. velAxisMode .. ")")
                            
                        elseif method == "AssemblyLinearVelocity" then
                            connection = RunService.Heartbeat:Connect(function()
                                if part.Parent then
                                    local shouldApply = (mode == "Always On") or (mode == "Keybind Move" and isKeyDown)
                                    
                                    if shouldApply then
                                        local effectiveVel = velocity
                                        
                                        if velAxisMode == "Velocity to Axis" then
                                            effectiveVel = initialCFrame:VectorToWorldSpace(velocity)
                                        elseif velAxisMode == "Updating Velocity to Axis" or velAxisMode == "Thruster" then
                                            effectiveVel = part.CFrame:VectorToWorldSpace(velocity)
                                        end
                                        
                                        part.AssemblyLinearVelocity = effectiveVel
                                    else
                                        part.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                                    end
                                else
                                    connection:Disconnect()
                                end
                            end)
                            
                            print("Applied AssemblyLinearVelocity " .. tostring(velocity) .. " to " .. part.Name .. " (" .. mode .. ", " .. velAxisMode .. ")")
                            
                        elseif method == "VectorForce" then
                            attachment = Instance.new("Attachment")
                            attachment.Parent = part
                            
                            vectorForce = Instance.new("VectorForce")
                            vectorForce.Attachment0 = attachment
                            vectorForce.ApplyAtCenterOfMass = true
                            vectorForce.RelativeTo = Enum.ActuatorRelativeTo.World
                            vectorForce.Parent = part
                            
                            connection = RunService.Heartbeat:Connect(function()
                                if vectorForce.Parent and part.Parent then
                                    local shouldApply = (mode == "Always On") or (mode == "Keybind Move" and isKeyDown)
                                    
                                    if shouldApply then
                                        local effectiveVel = velocity
                                        
                                        if velAxisMode == "Velocity to Axis" then
                                            effectiveVel = initialCFrame:VectorToWorldSpace(velocity)
                                        elseif velAxisMode == "Updating Velocity to Axis" or velAxisMode == "Thruster" then
                                            effectiveVel = part.CFrame:VectorToWorldSpace(velocity)
                                        end
                                        
                                        local currentVel = part.AssemblyLinearVelocity
                                        local velocityDiff = effectiveVel - currentVel
                                        vectorForce.Force = velocityDiff * part.AssemblyMass * 10
                                    else
                                        vectorForce.Force = Vector3.new(0, 0, 0)
                                    end
                                else
                                    connection:Disconnect()
                                end
                            end)
                            
                            print("Applied VectorForce velocity " .. tostring(velocity) .. " to " .. part.Name .. " (" .. mode .. ", " .. velAxisMode .. ")")
                        end
                    end
                    
                    velocityControls[part] = {
                        bodyVel = bodyVel,
                        vectorForce = vectorForce,
                        attachment = attachment,
                        connection = connection,
                        keybindConnection = keybindConnection
                    }
                    
                    task.wait(0.05)
                    if not part.Anchored and mode == "Always On" then
                        local effectiveVel = velocity
                        if velAxisMode == "Velocity to Axis" then
                            effectiveVel = initialCFrame:VectorToWorldSpace(velocity)
                        elseif velAxisMode == "Updating Velocity to Axis" or velAxisMode == "Thruster" then
                            effectiveVel = part.CFrame:VectorToWorldSpace(velocity)
                        end
                        part.AssemblyLinearVelocity = effectiveVel
                    end
                end
            end)
        end
    end

    local function applyAngularVelocity(angularVel, mode, method, keybind, spinAxis)
        mode = mode or "Spinnable Movable"
        method = method or "BodyAngularVelocity"
        keybind = keybind or "E"
        spinAxis = spinAxis or "Off"
        
        for _, part in ipairs(selectedParts) do
            replicateToServer(function()
                setNetworkOwnership(part)
                
                if angularControls[part] then
                    if angularControls[part].connection then
                        angularControls[part].connection:Disconnect()
                    end
                    if angularControls[part].bodyAngVel then
                        angularControls[part].bodyAngVel:Destroy()
                    end
                    if angularControls[part].bodyPosition then
                        angularControls[part].bodyPosition:Destroy()
                    end
                    if angularControls[part].bodyGyro then
                        angularControls[part].bodyGyro:Destroy()
                    end
                    if angularControls[part].attachment then
                        angularControls[part].attachment:Destroy()
                    end
                    if angularControls[part].torqueForce then
                        angularControls[part].torqueForce:Destroy()
                    end
                    if angularControls[part].weldConstraint then
                        angularControls[part].weldConstraint:Destroy()
                    end
                    if angularControls[part].anchorPart then
                        angularControls[part].anchorPart:Destroy()
                    end
                    if angularControls[part].keybindConnection then
                        angularControls[part].keybindConnection:Disconnect()
                    end
                    if angularControls[part].hingeConstraint then
                        pcall(function()
                            angularControls[part].hingeConstraint.ActuatorType = Enum.ActuatorType.None
                            angularControls[part].hingeConstraint.AngularVelocity = 0
                        end)
                    end
                    if angularControls[part].safetyConnection then
                        angularControls[part].safetyConnection:Disconnect()
                    end
                    angularControls[part] = nil
                end
                
                if angularVel.Magnitude == 0 then
                    if not part.Anchored then
                        part.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                    end
                    print("Disabled angular control for " .. part.Name)
                else
                    local bodyAngVel = nil
                    local bodyPosition = nil
                    local bodyGyro = nil
                    local attachment = nil
                    local torqueForce = nil
                    local weldConstraint = nil
                    local anchorPart = nil
                    local connection = nil
                    local keybindConnection = nil
                    local hingeConstraint = nil
                    local safetyConnection = nil
                    local initialPosition = part.Position
                    local lastCheckTime = tick()
                    local isKeyDown = false
                    
                    -- Parse mode
                    local isSpinnable = mode:find("Spinnable")
                    local isMovable = mode:find("Movable")
                    local isKeybind = (mode == "Keybind Spin")
                    
                    -- Parse keybind
                    local keyEnum = nil
                    if isKeybind then
                        if keybind:len() == 1 then
                            keyEnum = Enum.KeyCode[keybind:upper()]
                        else
                            keyEnum = Enum.KeyCode[keybind]
                        end
                        
                        keybindConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
                            if gameProcessed then return end
                            if input.KeyCode == keyEnum then
                                isKeyDown = true
                            end
                        end)
                        
                        local keyUpConnection = UserInputService.InputEnded:Connect(function(input)
                            if input.KeyCode == keyEnum then
                                isKeyDown = false
                            end
                        end)
                    end
                    
                    if part.Anchored then
                        -- For anchored parts - spin touching parts around this part
                        connection = RunService.Heartbeat:Connect(function()
                            if part.Parent then
                                local shouldApply = not isKeybind or (isKeybind and isKeyDown)
                                
                                if shouldApply then
                                    local touching = part:GetTouchingParts()
                                    
                                    for _, touchingPart in pairs(touching) do
                                        if touchingPart ~= part and not touchingPart.Anchored and touchingPart.Parent ~= player.Character then
                                            touchingPart.AssemblyAngularVelocity = angularVel
                                        end
                                    end
                                end
                            else
                                connection:Disconnect()
                            end
                        end)
                        
                        print("Applied anchored angular velocity conveyor " .. tostring(angularVel) .. " to " .. part.Name)
                        
                    else
                        -- For unanchored parts - apply based on mode and method
                        
                        -- ULTRA LOCK for unmovable parts - uses WeldConstraint to invisible anchored part
                        if not isMovable and not isKeybind then
                            anchorPart = Instance.new("Part")
                            anchorPart.Name = "UltraLockAnchor"
                            anchorPart.Size = Vector3.new(0.1, 0.1, 0.1)
                            anchorPart.CFrame = part.CFrame
                            anchorPart.Anchored = true
                            anchorPart.CanCollide = false
                            anchorPart.Transparency = 1
                            anchorPart.Parent = workspace
                            
                            weldConstraint = Instance.new("WeldConstraint")
                            weldConstraint.Part0 = part
                            weldConstraint.Part1 = anchorPart
                            weldConstraint.Parent = part
                        end
                        
                        if method == "BodyAngularVelocity" then
                            -- Classic method - uses BodyAngularVelocity
                            bodyAngVel = Instance.new("BodyAngularVelocity")
                            bodyAngVel.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
                            bodyAngVel.AngularVelocity = Vector3.new(0, 0, 0)
                            bodyAngVel.P = 1000000 -- MASSIVELY increased power to prevent collision stoppage
                            bodyAngVel.Parent = part
                            
                            -- Store initial CFrame for Spin to Axis modes
                            local initialCFrame = part.CFrame
                            
                            connection = RunService.Heartbeat:Connect(function()
                                if bodyAngVel.Parent and part.Parent then
                                    local shouldApply = not isKeybind or (isKeybind and isKeyDown)
                                    
                                    if shouldApply then
                                        -- Handle Spin to Axis modes
                                        if spinAxis == "Spin to Axis" then
                                            -- Rotate in local space relative to initial orientation
                                            local localAngVel = initialCFrame:VectorToWorldSpace(angularVel)
                                            bodyAngVel.AngularVelocity = localAngVel
                                            if not isSpinnable or not isMovable then
                                                part.AssemblyAngularVelocity = localAngVel
                                            end
                                            if part.AssemblyAngularVelocity.Magnitude < localAngVel.Magnitude * 0.9 then
                                                part.AssemblyAngularVelocity = localAngVel
                                            end
                                        elseif spinAxis == "Updating Spin to Axis" then
                                            -- Continuously update to current local space
                                            local localAngVel = part.CFrame:VectorToWorldSpace(angularVel)
                                            bodyAngVel.AngularVelocity = localAngVel
                                            if not isSpinnable or not isMovable then
                                                part.AssemblyAngularVelocity = localAngVel
                                            end
                                            if part.AssemblyAngularVelocity.Magnitude < localAngVel.Magnitude * 0.9 then
                                                part.AssemblyAngularVelocity = localAngVel
                                            end
                                        else
                                            -- Default: Off - use world space
                                            bodyAngVel.AngularVelocity = angularVel
                                            if not isSpinnable or not isMovable then
                                                part.AssemblyAngularVelocity = angularVel
                                            end
                                            if part.AssemblyAngularVelocity.Magnitude < angularVel.Magnitude * 0.9 then
                                                part.AssemblyAngularVelocity = angularVel
                                            end
                                        end
                                    else
                                        bodyAngVel.AngularVelocity = Vector3.new(0, 0, 0)
                                        part.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                                    end
                                    
                                    if weldConstraint and anchorPart then
                                        anchorPart.CFrame = CFrame.new(initialPosition)
                                    end
                                else
                                    connection:Disconnect()
                                end
                            end)
                            
                            print("Applied BodyAngularVelocity (" .. mode .. ", Spin Axis: " .. spinAxis .. ") to " .. part.Name)
                            
                        elseif method == "BodyGyro" then
                            -- BodyGyro method - uses rotation CFrame
                            bodyGyro = Instance.new("BodyGyro")
                            bodyGyro.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
                            bodyGyro.D = 500
                            bodyGyro.P = 100000 -- Increased power
                            bodyGyro.Parent = part
                            
                            local startCFrame = part.CFrame - part.CFrame.Position
                            local initialCFrame = part.CFrame
                            local currentAngle = 0
                            
                            connection = RunService.Heartbeat:Connect(function()
                                if part.Parent then
                                    local shouldApply = not isKeybind or (isKeybind and isKeyDown)
                                    
                                    if shouldApply then
                                        local dt = task.wait()
                                        
                                        local effectiveAngVel = angularVel
                                        if spinAxis == "Spin to Axis" then
                                            effectiveAngVel = initialCFrame:VectorToWorldSpace(angularVel)
                                        elseif spinAxis == "Updating Spin to Axis" then
                                            effectiveAngVel = part.CFrame:VectorToWorldSpace(angularVel)
                                        end
                                        
                                        currentAngle = currentAngle + (effectiveAngVel.Magnitude * dt)
                                        
                                        local axis = effectiveAngVel.Unit
                                        local rotationCFrame = CFrame.fromAxisAngle(axis, currentAngle)
                                        
                                        bodyGyro.CFrame = startCFrame * rotationCFrame
                                        
                                        if not isSpinnable then
                                            part.AssemblyAngularVelocity = effectiveAngVel
                                        end
                                        if part.AssemblyAngularVelocity.Magnitude < effectiveAngVel.Magnitude * 0.9 then
                                            part.AssemblyAngularVelocity = effectiveAngVel
                                        end
                                    else
                                        part.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                                    end
                                    
                                    if weldConstraint and anchorPart then
                                        anchorPart.CFrame = CFrame.new(initialPosition)
                                    end
                                else
                                    connection:Disconnect()
                                end
                            end)
                            
                            print("Applied BodyGyro (" .. mode .. ", Spin Axis: " .. spinAxis .. ") to " .. part.Name)
                            
                        elseif method == "AssemblyAngularVelocity" then
                            -- Direct property method - lightest
                            local initialCFrame = part.CFrame
                            
                            connection = RunService.Heartbeat:Connect(function()
                                if part.Parent then
                                    local shouldApply = not isKeybind or (isKeybind and isKeyDown)
                                    
                                    if shouldApply then
                                        local effectiveAngVel = angularVel
                                        if spinAxis == "Spin to Axis" then
                                            effectiveAngVel = initialCFrame:VectorToWorldSpace(angularVel)
                                        elseif spinAxis == "Updating Spin to Axis" then
                                            effectiveAngVel = part.CFrame:VectorToWorldSpace(angularVel)
                                        end
                                        part.AssemblyAngularVelocity = effectiveAngVel
                                    else
                                        part.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                                    end
                                    
                                    if weldConstraint and anchorPart then
                                        anchorPart.CFrame = CFrame.new(initialPosition)
                                    end
                                else
                                    connection:Disconnect()
                                end
                            end)
                            
                            print("Applied AssemblyAngularVelocity (" .. mode .. ", Spin Axis: " .. spinAxis .. ") to " .. part.Name)
                            
                        elseif method == "Torque" then
                            -- Torque method - uses Torque object for realistic physics
                            attachment = Instance.new("Attachment")
                            attachment.Parent = part
                            
                            torqueForce = Instance.new("Torque")
                            torqueForce.Attachment0 = attachment
                            torqueForce.RelativeTo = Enum.ActuatorRelativeTo.World
                            torqueForce.Parent = part
                            
                            local initialCFrame = part.CFrame
                            
                            connection = RunService.Heartbeat:Connect(function()
                                if torqueForce.Parent and part.Parent then
                                    local shouldApply = not isKeybind or (isKeybind and isKeyDown)
                                    
                                    if shouldApply then
                                        local effectiveAngVel = angularVel
                                        if spinAxis == "Spin to Axis" then
                                            effectiveAngVel = initialCFrame:VectorToWorldSpace(angularVel)
                                        elseif spinAxis == "Updating Spin to Axis" then
                                            effectiveAngVel = part.CFrame:VectorToWorldSpace(angularVel)
                                        end
                                        
                                        local currentAngVel = part.AssemblyAngularVelocity
                                        local velocityDiff = effectiveAngVel - currentAngVel
                                        
                                        -- Apply massive torque to overcome collisions
                                        local torqueMagnitude = velocityDiff * part.AssemblyMass * 500
                                        torqueForce.Torque = torqueMagnitude
                                        
                                        if not isSpinnable then
                                            part.AssemblyAngularVelocity = part.AssemblyAngularVelocity:Lerp(effectiveAngVel, 0.5)
                                        end
                                        if part.AssemblyAngularVelocity.Magnitude < effectiveAngVel.Magnitude * 0.8 then
                                            part.AssemblyAngularVelocity = effectiveAngVel
                                        end
                                    else
                                        torqueForce.Torque = Vector3.new(0, 0, 0)
                                        part.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                                    end
                                    
                                    if weldConstraint and anchorPart then
                                        anchorPart.CFrame = CFrame.new(initialPosition)
                                    end
                                else
                                    connection:Disconnect()
                                end
                            end)
                            
                            print("Applied Torque (" .. mode .. ", Spin Axis: " .. spinAxis .. ") to " .. part.Name)
                        end
                    end
                    
                    angularControls[part] = {
                        bodyAngVel = bodyAngVel,
                        bodyPosition = bodyPosition,
                        bodyGyro = bodyGyro,
                        attachment = attachment,
                        torqueForce = torqueForce,
                        weldConstraint = weldConstraint,
                        anchorPart = anchorPart,
                        connection = connection,
                        keybindConnection = keybindConnection,
                        hingeConstraint = hingeConstraint,
                        safetyConnection = safetyConnection
                    }
                end
            end)
        end
    end

    local function toggleZeroGravity()
        for _, part in ipairs(selectedParts) do
            replicateToServer(function()
                setNetworkOwnership(part)
                
                if gravityForces[part] then
                    if gravityForces[part].connection then
                        gravityForces[part].connection:Disconnect()
                    end
                    if gravityForces[part].vectorForce then
                        gravityForces[part].vectorForce:Destroy()
                    end
                    if gravityForces[part].attachment then
                        gravityForces[part].attachment:Destroy()
                    end
                    gravityForces[part] = nil
                    print("Removed zero gravity from " .. part.Name)
                else
                    local attachment = Instance.new("Attachment")
                    attachment.Parent = part
                    
                    local vectorForce = Instance.new("VectorForce")
                    vectorForce.Attachment0 = attachment
                    vectorForce.ApplyAtCenterOfMass = true
                    vectorForce.RelativeTo = Enum.ActuatorRelativeTo.World
                    vectorForce.Force = Vector3.new(0, part.Mass * workspace.Gravity, 0)
                    vectorForce.Parent = part
                    
                    gravityForces[part] = {
                        vectorForce = vectorForce,
                        attachment = attachment,
                        connection = nil
                    }
                    
                    print("Applied true zero gravity (gravity cancelled) to " .. part.Name)
                end
            end)
        end
    end

    -- NEW: Enhanced weight/physics properties editor
    local function applyPhysicsProperties(density, friction, elasticity)
        for _, part in ipairs(selectedParts) do
            replicateToServer(function()
                setNetworkOwnership(part)
                
                if density == 0 and friction == 0 and elasticity == 0 then
                    part.CustomPhysicalProperties = nil
                    print("Reset physics properties for " .. part.Name)
                else
                    local d = density > 0 and density or (part.CustomPhysicalProperties and part.CustomPhysicalProperties.Density or 0.7)
                    local f = friction >= 0 and (friction == math.huge and 2 or friction) or (part.CustomPhysicalProperties and part.CustomPhysicalProperties.Friction or 0.3)
                    local e = elasticity >= 0 and (elasticity > 1 and 1 or elasticity) or (part.CustomPhysicalProperties and part.CustomPhysicalProperties.Elasticity or 0.5)
                    
                    part.CustomPhysicalProperties = PhysicalProperties.new(d, f, e)
                    print("Applied physics properties to " .. part.Name .. " (D:" .. d .. " F:" .. f .. " E:" .. e .. ")")
                end
            end)
        end
    end

    local function applyWeight(mass)
        for _, part in ipairs(selectedParts) do
            replicateToServer(function()
                setNetworkOwnership(part)
                
                if weightForces[part] then
                    weightForces[part]:Destroy()
                    weightForces[part] = nil
                end
                
                if mass == 0 then
                    print("Disabled weight simulation for " .. part.Name)
                else
                    local vectorForce = Instance.new("VectorForce")
                    vectorForce.Force = Vector3.new(0, -mass * workspace.Gravity, 0)
                    vectorForce.ApplyAtCenterOfMass = true
                    
                    local attachment = Instance.new("Attachment")
                    attachment.Parent = part
                    vectorForce.Attachment0 = attachment
                    vectorForce.Parent = part
                    
                    weightForces[part] = vectorForce
                    print("Applied weight simulation (" .. mass .. " mass) to " .. part.Name)
                end
            end)
        end
    end

    -- NEW: Enhanced gyro with multiple modes
    local function applyGyroBalancer(targetOrientation, stabilityPower, gyroType)
        gyroType = gyroType or "BodyPosition"
        for _, part in ipairs(selectedParts) do
            replicateToServer(function()
                setNetworkOwnership(part)
                
                if gyroStabilizers[part] then
                    if gyroStabilizers[part].connection then gyroStabilizers[part].connection:Disconnect() end
                    if gyroStabilizers[part].bodyPosition then gyroStabilizers[part].bodyPosition:Destroy() end
                    if gyroStabilizers[part].bodyAngularVelocity then gyroStabilizers[part].bodyAngularVelocity:Destroy() end
                    if gyroStabilizers[part].attachment then gyroStabilizers[part].attachment:Destroy() end
                    if gyroStabilizers[part].alignOrientation then gyroStabilizers[part].alignOrientation:Destroy() end
                    if gyroStabilizers[part].bodyGyro then gyroStabilizers[part].bodyGyro:Destroy() end
                    gyroStabilizers[part] = nil
                end
                
                if stabilityPower <= 0 then
                    print("Disabled gyro balancer for " .. part.Name)
                    return
                end
                
                local initialPosition = part.Position
                local targetCFrame
                
                if targetOrientation == "Upright" then
                    targetCFrame = CFrame.new(part.Position, part.Position + Vector3.new(0, 1, 0))
                elseif targetOrientation == "Level" then
                    local lookVector = part.CFrame.LookVector
                    lookVector = Vector3.new(lookVector.X, 0, lookVector.Z).Unit
                    targetCFrame = CFrame.lookAt(part.Position, part.Position + lookVector, Vector3.new(0, 1, 0))
                elseif targetOrientation == "Original" then
                    targetCFrame = part.CFrame
                elseif targetOrientation == "VelocityAligned" then
                    targetCFrame = part.CFrame
                else
                    targetCFrame = part.CFrame
                end
                
                local connection, bodyPosition, bodyAngularVelocity, attachment, alignOrientation, bodyGyro
                
                if gyroType == "AlignOrientation" then
                    attachment = Instance.new("Attachment")
                    attachment.Parent = part
                    
                    alignOrientation = Instance.new("AlignOrientation")
                    alignOrientation.Attachment0 = attachment
                    alignOrientation.Mode = Enum.OrientationAlignmentMode.OneAttachment
                    alignOrientation.CFrame = targetCFrame - targetCFrame.Position
                    alignOrientation.MaxTorque = 10000 * stabilityPower
                    alignOrientation.Responsiveness = 20
                    alignOrientation.Parent = part
                    
                    connection = RunService.Heartbeat:Connect(function()
                        if alignOrientation.Parent and part.Parent then
                            if targetOrientation == "Upright" then
                                local currentLook = part.CFrame.LookVector
                                currentLook = Vector3.new(currentLook.X, 0, currentLook.Z).Unit
                                alignOrientation.CFrame = (CFrame.lookAt(Vector3.new(), currentLook, Vector3.new(0, 1, 0)) - CFrame.lookAt(Vector3.new(), currentLook, Vector3.new(0, 1, 0)).Position)
                            elseif targetOrientation == "Level" then
                                local currentLook = part.CFrame.LookVector
                                currentLook = Vector3.new(currentLook.X, 0, currentLook.Z).Unit
                                alignOrientation.CFrame = (CFrame.lookAt(Vector3.new(), currentLook, Vector3.new(0, 1, 0)) - CFrame.lookAt(Vector3.new(), currentLook, Vector3.new(0, 1, 0)).Position)
                            elseif targetOrientation == "VelocityAligned" then
                                local vel = part.AssemblyLinearVelocity
                                if vel.Magnitude > 1 then
                                    alignOrientation.CFrame = (CFrame.lookAt(Vector3.new(), vel.Unit, Vector3.new(0, 1, 0)) - CFrame.lookAt(Vector3.new(), vel.Unit, Vector3.new(0, 1, 0)).Position)
                                end
                            end
                        else
                            connection:Disconnect()
                        end
                    end)
                    
                    gyroStabilizers[part] = {alignOrientation = alignOrientation, attachment = attachment, connection = connection}
                    
                elseif gyroType == "BodyGyro" then
                    bodyGyro = Instance.new("BodyGyro")
                    bodyGyro.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
                    bodyGyro.P = 10000 * (stabilityPower / 50)
                    bodyGyro.D = 1000 * (stabilityPower / 50)
                    bodyGyro.CFrame = targetCFrame - targetCFrame.Position
                    bodyGyro.Parent = part
                    
                    connection = RunService.Heartbeat:Connect(function()
                        if bodyGyro.Parent and part.Parent then
                            if targetOrientation == "Upright" then
                                local currentLook = part.CFrame.LookVector
                                currentLook = Vector3.new(currentLook.X, 0, currentLook.Z).Unit
                                bodyGyro.CFrame = CFrame.lookAt(Vector3.new(), currentLook, Vector3.new(0, 1, 0))
                            elseif targetOrientation == "Level" then
                                local currentLook = part.CFrame.LookVector
                                currentLook = Vector3.new(currentLook.X, 0, currentLook.Z).Unit
                                bodyGyro.CFrame = CFrame.lookAt(Vector3.new(), currentLook, Vector3.new(0, 1, 0))
                            elseif targetOrientation == "VelocityAligned" then
                                local vel = part.AssemblyLinearVelocity
                                if vel.Magnitude > 1 then
                                    bodyGyro.CFrame = CFrame.lookAt(Vector3.new(), vel.Unit, Vector3.new(0, 1, 0))
                                end
                            end
                        else
                            connection:Disconnect()
                        end
                    end)
                    
                    gyroStabilizers[part] = {bodyGyro = bodyGyro, connection = connection}
                    
                else -- BodyPosition type - the only one that should lock position
                    bodyPosition = Instance.new("BodyPosition")
                    bodyAngularVelocity = Instance.new("BodyAngularVelocity")
                    attachment = Instance.new("Attachment")
                    
                    bodyPosition.MaxForce = Vector3.new(4000, 4000, 4000) * part.Mass * (stabilityPower / 50)
                    bodyPosition.Position = initialPosition
                    bodyPosition.D = 2000 * (stabilityPower / 50)
                    bodyPosition.P = 8000 * (stabilityPower / 50)
                    bodyPosition.Parent = part
                    
                    bodyAngularVelocity.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
                    bodyAngularVelocity.AngularVelocity = Vector3.new(0, 0, 0)
                    bodyAngularVelocity.P = 10000 * (stabilityPower / 50)
                    bodyAngularVelocity.D = 1000 * (stabilityPower / 50)
                    bodyAngularVelocity.Parent = part
                    
                    attachment.Parent = part
                    
                    connection = RunService.Heartbeat:Connect(function()
                        if bodyPosition.Parent and bodyAngularVelocity.Parent and part.Parent then
                            local currentPos = part.Position
                            local desiredCFrame
                            
                            if targetOrientation == "Upright" then
                                local currentLook = part.CFrame.LookVector
                                currentLook = Vector3.new(currentLook.X, 0, currentLook.Z).Unit
                                desiredCFrame = CFrame.lookAt(currentPos, currentPos + currentLook, Vector3.new(0, 1, 0))
                            elseif targetOrientation == "Level" then
                                local currentLook = part.CFrame.LookVector
                                currentLook = Vector3.new(currentLook.X, 0, currentLook.Z).Unit
                                desiredCFrame = CFrame.lookAt(currentPos, currentPos + currentLook, Vector3.new(0, 1, 0))
                            elseif targetOrientation == "Original" then
                                desiredCFrame = CFrame.new(currentPos) * (targetCFrame - targetCFrame.Position)
                            elseif targetOrientation == "VelocityAligned" then
                                local vel = part.AssemblyLinearVelocity
                                if vel.Magnitude > 1 then
                                    desiredCFrame = CFrame.lookAt(currentPos, currentPos + vel.Unit, Vector3.new(0, 1, 0))
                                else
                                    desiredCFrame = part.CFrame
                                end
                            else
                                desiredCFrame = part.CFrame
                            end
                            
                            local currentCFrame = part.CFrame
                            local rotationDifference = desiredCFrame:ToObjectSpace(currentCFrame)
                            local axis, angle = rotationDifference:ToAxisAngle()
                            
                            local angularVelocity = axis * angle * stabilityPower * 0.1
                            local currentAngularVel = part.AssemblyAngularVelocity
                            local targetAngularVel = angularVelocity - currentAngularVel * 0.5
                            
                            bodyAngularVelocity.AngularVelocity = targetAngularVel
                            bodyPosition.Position = currentPos
                            
                        else
                            connection:Disconnect()
                        end
                    end)
                    
                    gyroStabilizers[part] = {
                        bodyPosition = bodyPosition,
                        bodyAngularVelocity = bodyAngularVelocity,
                        attachment = attachment,
                        connection = connection
                    }
                end
                
                print("Applied " .. gyroType .. " gyro (" .. targetOrientation .. ", power " .. stabilityPower .. ") to " .. part.Name)
            end)
        end
    end

    local function applyFrozenFlinger(flingPower)
        for _, part in ipairs(selectedParts) do
            replicateToServer(function()
                setNetworkOwnership(part)
                
                if frozenFlingers[part] then
                    if frozenFlingers[part].connection then frozenFlingers[part].connection:Disconnect() end
                    if frozenFlingers[part].weld then frozenFlingers[part].weld:Destroy() end
                    if frozenFlingers[part].anchorPart then frozenFlingers[part].anchorPart:Destroy() end
                    frozenFlingers[part] = nil
                end
                
                if part.Anchored then
                    warn("Cannot apply Frozen Flinger to anchored parts!")
                    return
                end
                
                local anchorPart = Instance.new("Part")
                anchorPart.Name = "FrozenFlingerAnchor"
                anchorPart.Size = Vector3.new(0.1, 0.1, 0.1)
                anchorPart.CFrame = part.CFrame
                anchorPart.Anchored = true
                anchorPart.CanCollide = false
                anchorPart.Transparency = 1
                anchorPart.Parent = workspace
                
                local weld = Instance.new("WeldConstraint")
                weld.Part0 = part
                weld.Part1 = anchorPart
                weld.Parent = part
                
                local lockedCFrame = part.CFrame
                
                local connection = RunService.Heartbeat:Connect(function()
                    if weld.Parent and part.Parent and anchorPart.Parent then
                        part.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                        part.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                        
                        local touchingParts = part:GetTouchingParts()
                        
                        for _, touchingPart in pairs(touchingParts) do
                            if touchingPart ~= part and touchingPart ~= anchorPart and not touchingPart.Anchored then
                                local character = touchingPart.Parent
                                local humanoid = character:FindFirstChildOfClass("Humanoid")
                                
                                if humanoid then
                                    local hrp = character:FindFirstChild("HumanoidRootPart")
                                    
                                    if hrp then
                                        local direction = (hrp.Position - part.Position).Unit
                                        local flingVelocity = direction * flingPower
                                        
                                        hrp.AssemblyLinearVelocity = flingVelocity
                                        local impulse = flingVelocity * hrp.AssemblyMass
                                        hrp:ApplyImpulse(impulse)
                                        
                                        for _, bodyPart in pairs(character:GetChildren()) do
                                            if bodyPart:IsA("BasePart") and bodyPart ~= hrp then
                                                bodyPart.AssemblyLinearVelocity = flingVelocity
                                            end
                                        end
                                    end
                                else
                                    local direction = (touchingPart.Position - part.Position).Unit
                                    local flingVelocity = direction * flingPower
                                    
                                    touchingPart.AssemblyLinearVelocity = flingVelocity
                                    
                                    local impulse = flingVelocity * touchingPart.AssemblyMass
                                    touchingPart:ApplyImpulse(impulse)
                                end
                            end
                        end
                    else
                        connection:Disconnect()
                    end
                end)
                
                frozenFlingers[part] = {
                    weld = weld,
                    anchorPart = anchorPart,
                    connection = connection,
                    flingPower = flingPower,
                    lockedCFrame = lockedCFrame
                }
                
                print("Applied Frozen Flinger (power " .. flingPower .. ") to " .. part.Name .. " - COMPLETELY FROZEN")
            end)
        end
    end

    local function removeFrozenFlinger()
        for _, part in ipairs(selectedParts) do
            if frozenFlingers[part] then
                if frozenFlingers[part].connection then frozenFlingers[part].connection:Disconnect() end
                if frozenFlingers[part].weld then frozenFlingers[part].weld:Destroy() end
                if frozenFlingers[part].anchorPart then frozenFlingers[part].anchorPart:Destroy() end
                frozenFlingers[part] = nil
                print("Removed Frozen Flinger from " .. part.Name)
            end
        end
    end

    local function applyPositionLock()
        for _, part in ipairs(selectedParts) do
            replicateToServer(function()
                setNetworkOwnership(part)
                
                if positionLocks[part] then
                    if positionLocks[part].connection then positionLocks[part].connection:Disconnect() end
                    if positionLocks[part].bodyPosition then positionLocks[part].bodyPosition:Destroy() end
                    if positionLocks[part].bodyVelocity then positionLocks[part].bodyVelocity:Destroy() end
                    positionLocks[part] = nil
                end
                
                if part.Anchored then
                    warn("Cannot apply Position Lock to anchored parts!")
                    return
                end
                
                local lockedPosition = part.Position
                
                local bodyPosition = Instance.new("BodyPosition")
                bodyPosition.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                bodyPosition.Position = lockedPosition
                bodyPosition.D = 1000
                bodyPosition.P = 10000
                bodyPosition.Parent = part
                
                local bodyVelocity = Instance.new("BodyVelocity")
                bodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                bodyVelocity.Velocity = Vector3.new(0, 0, 0)
                bodyVelocity.Parent = part
                
                local connection = RunService.Heartbeat:Connect(function()
                    if bodyPosition.Parent and part.Parent then
                        local isWelded = false
                        local weldParent = nil
                        
                        for _, child in pairs(part:GetChildren()) do
                            if child:IsA("Weld") or child:IsA("WeldConstraint") or child:IsA("Motor6D") then
                                isWelded = true
                                weldParent = child.Part1 or child.Part0
                                if weldParent == part then
                                    weldParent = child.Part0 or child.Part1
                                end
                                break
                            end
                        end
                        
                        if isWelded and weldParent and weldParent.Parent then
                            lockedPosition = part.Position
                            bodyPosition.Position = lockedPosition
                            bodyVelocity.Velocity = Vector3.new(0, 0, 0)
                        else
                            bodyPosition.Position = lockedPosition
                            part.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                        end
                    else
                        connection:Disconnect()
                    end
                end)
                
                positionLocks[part] = {
                    bodyPosition = bodyPosition,
                    bodyVelocity = bodyVelocity,
                    connection = connection,
                    lockedPosition = lockedPosition
                }
                
                print("Applied Position Lock to " .. part.Name)
            end)
        end
    end

    local function removePositionLock()
        for _, part in ipairs(selectedParts) do
            if positionLocks[part] then
                if positionLocks[part].connection then positionLocks[part].connection:Disconnect() end
                if positionLocks[part].bodyPosition then positionLocks[part].bodyPosition:Destroy() end
                if positionLocks[part].bodyVelocity then positionLocks[part].bodyVelocity:Destroy() end
                positionLocks[part] = nil
                print("Removed Position Lock from " .. part.Name)
            end
        end
    end

    -- NEW: Show Forces visualizer
    local function toggleShowForces()
        for _, part in ipairs(selectedParts) do
            if showForcesVisuals[part] then
                for _, arrow in pairs(showForcesVisuals[part]) do
                    if arrow then arrow:Destroy() end
                end
                showForcesVisuals[part] = nil
                print("Disabled force visualization for " .. part.Name)
            else
                local arrows = {}
                local connection = RunService.Heartbeat:Connect(function()
                    if not part.Parent then
                        for _, arrow in pairs(arrows) do
                            if arrow then arrow:Destroy() end
                        end
                        connection:Disconnect()
                        return
                    end
                    
                    for _, arrow in pairs(arrows) do
                        if arrow then arrow:Destroy() end
                    end
                    arrows = {}
                    
                    local velocity = part.AssemblyLinearVelocity
                    if velocity.Magnitude > 0.1 then
                        local arrow = Instance.new("Part")
                        arrow.Size = Vector3.new(0.2, 0.2, velocity.Magnitude / 10)
                        arrow.CFrame = CFrame.new(part.Position, part.Position + velocity) * CFrame.new(0, 0, -arrow.Size.Z/2)
                        arrow.Anchored = true
                        arrow.CanCollide = false
                        arrow.Color = Color3.fromRGB(0, 255, 0)
                        arrow.Transparency = 0.5
                        arrow.Parent = workspace
                        table.insert(arrows, arrow)
                    end
                    
                    local angVel = part.AssemblyAngularVelocity
                    if angVel.Magnitude > 0.1 then
                        local arrow = Instance.new("Part")
                        arrow.Size = Vector3.new(0.2, angVel.Magnitude / 5, 0.2)
                        arrow.CFrame = CFrame.new(part.Position) * CFrame.Angles(0, 0, math.rad(90))
                        arrow.Anchored = true
                        arrow.CanCollide = false
                        arrow.Color = Color3.fromRGB(255, 255, 0)
                        arrow.Transparency = 0.5
                        arrow.Parent = workspace
                        table.insert(arrows, arrow)
                    end
                end)
                showForcesVisuals[part] = arrows
                showForcesVisuals[part].connection = connection
                print("Enabled force visualization for " .. part.Name)
            end
        end
    end

    -- NEW: Freeze Motion (like anchor but unanchored)
    local function toggleFreezeMotion()
        for _, part in ipairs(selectedParts) do
            if frozenMotionParts[part] then
                if frozenMotionParts[part].connection then frozenMotionParts[part].connection:Disconnect() end
                frozenMotionParts[part] = nil
                print("Unfroze motion for " .. part.Name)
            else
                local connection = RunService.Heartbeat:Connect(function()
                    if part.Parent then
                        part.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                        part.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                    else
                        connection:Disconnect()
                    end
                end)
                frozenMotionParts[part] = {connection = connection}
                print("Froze motion for " .. part.Name)
            end
        end
    end

    -- NEW: Time Scale (slow motion physics)
    local function applyTimeScale(scale)
        if timeScaleActive and scale == 1 then
            timeScaleActive = false
            currentTimeScale = 1
            print("Disabled time scale")
        else
            timeScaleActive = true
            currentTimeScale = scale
            print("Applied time scale: " .. scale)
            
            RunService.Heartbeat:Connect(function()
                if timeScaleActive then
                    for _, part in ipairs(workspace:GetDescendants()) do
                        if part:IsA("BasePart") and not part.Anchored then
                            local vel = part.AssemblyLinearVelocity
                            part.AssemblyLinearVelocity = vel * currentTimeScale
                        end
                    end
                end
            end)
        end
    end

    -- NEW: Physics Recorder
    local function startRecording(recordName)
        if physicsRecordings[recordName] then
            print("Recording already exists: " .. recordName)
            return
        end
        
        local recording = {frames = {}, parts = {}}
        for _, part in ipairs(selectedParts) do
            table.insert(recording.parts, part)
        end
        
        local connection = RunService.Heartbeat:Connect(function()
            local frame = {}
            for i, part in ipairs(recording.parts) do
                if part.Parent then
                    frame[i] = {CFrame = part.CFrame, Velocity = part.AssemblyLinearVelocity}
                end
            end
            table.insert(recording.frames, frame)
        end)
        
        recording.connection = connection
        physicsRecordings[recordName] = recording
        print("Started recording: " .. recordName)
    end

    local function stopRecording(recordName)
        if not physicsRecordings[recordName] then return end
        if physicsRecordings[recordName].connection then
            physicsRecordings[recordName].connection:Disconnect()
        end
        physicsRecordings[recordName].connection = nil
        print("Stopped recording: " .. recordName .. " (" .. #physicsRecordings[recordName].frames .. " frames)")
    end

    local function playbackRecording(recordName)
        if not physicsRecordings[recordName] then return end
        local recording = physicsRecordings[recordName]
        
        task.spawn(function()
            for frameNum, frame in ipairs(recording.frames) do
                for partNum, data in pairs(frame) do
                    if recording.parts[partNum] and recording.parts[partNum].Parent then
                        recording.parts[partNum].CFrame = data.CFrame
                        recording.parts[partNum].AssemblyLinearVelocity = data.Velocity
                    end
                end
                task.wait(1/60)
            end
            print("Finished playback: " .. recordName)
        end)
    end

    -- NEW: Gravity Gun
    local function toggleGravityGun()
        gravityGunActive = not gravityGunActive
        if not gravityGunActive and gravityGunPart then
            gravityGunPart = nil
        end
        print("Gravity Gun: " .. (gravityGunActive and "ON" or "OFF"))
    end

    -- NEW: Physics Paint
    local function applyPhysicsPaint(paintType)
        for _, part in ipairs(selectedParts) do
            if physicsPaints[part] then
                if physicsPaints[part].connection then physicsPaints[part].connection:Disconnect() end
            end
            
            if paintType == "Slippery" then
                part.CustomPhysicalProperties = PhysicalProperties.new(0.7, 0.01, 0.5)
                physicsPaints[part] = {type = "Slippery"}
            elseif paintType == "Bouncy" then
                part.CustomPhysicalProperties = PhysicalProperties.new(0.7, 0.3, 1)
                physicsPaints[part] = {type = "Bouncy"}
            elseif paintType == "Magnetic" then
                local connection = RunService.Heartbeat:Connect(function()
                    if part.Parent then
                        for otherPart, data in pairs(physicsPaints) do
                            if data.type == "Magnetic" and otherPart ~= part and otherPart.Parent then
                                local dist = (part.Position - otherPart.Position).Magnitude
                                if dist < 50 then
                                    local force = (otherPart.Position - part.Position).Unit * (500 / dist)
                                    part.AssemblyLinearVelocity = part.AssemblyLinearVelocity + force * 0.01
                                end
                            end
                        end
                    else
                        connection:Disconnect()
                    end
                end)
                physicsPaints[part] = {type = "Magnetic", connection = connection}
            elseif paintType == "Gooey" then
                local connection = RunService.Heartbeat:Connect(function()
                    if part.Parent then
                        local touching = part:GetTouchingParts()
                        for _, touchPart in pairs(touching) do
                            if touchPart.Anchored then
                                part.AssemblyLinearVelocity = part.AssemblyLinearVelocity * 0.5
                            end
                        end
                    else
                        connection:Disconnect()
                    end
                end)
                physicsPaints[part] = {type = "Gooey", connection = connection}
            elseif paintType == "Buoyancy" then
                -- Remove any existing buoyancy objects
                if part:FindFirstChild("BuoyancyBodyPosition") then
                    part:FindFirstChild("BuoyancyBodyPosition"):Destroy()
                end
                if part:FindFirstChild("BuoyancyBodyGyro") then
                    part:FindFirstChild("BuoyancyBodyGyro"):Destroy()
                end
                
                -- Store the last known position on water
                local lockedOnWater = false
                local lastWaterY = nil
                
                local connection = RunService.Heartbeat:Connect(function()
                    if part.Parent then
                        -- Check for water below the part
                        local checkPos = part.Position - Vector3.new(0, part.Size.Y/2 + 1, 0)
                        local region = Region3.new(checkPos - Vector3.new(3, 3, 3), checkPos + Vector3.new(3, 3, 3))
                        region = region:ExpandToGrid(4)
                        
                        local terrain = workspace.Terrain
                        local materials, sizes = terrain:ReadVoxels(region, 4)
                        local size = materials.Size
                        
                        local waterFound = false
                        local waterLevel = -math.huge
                        
                        for x = 1, size.X do
                            for y = 1, size.Y do
                                for z = 1, size.Z do
                                    if materials[x][y][z] == Enum.Material.Water then
                                        waterFound = true
                                        local worldPos = region.CFrame * Vector3.new(
                                            (x - size.X/2) * 4,
                                            (y - size.Y/2) * 4,
                                            (z - size.Z/2) * 4
                                        )
                                        waterLevel = math.max(waterLevel, worldPos.Y)
                                    end
                                end
                            end
                        end
                        
                        if waterFound then
                            local bottomY = part.Position.Y - part.Size.Y/2
                            
                            -- If bottom is at or below water, lock it
                            if bottomY <= waterLevel + 0.1 then
                                if not lockedOnWater then
                                    lockedOnWater = true
                                    lastWaterY = waterLevel + part.Size.Y/2
                                end
                                
                                -- Force position to stay on water surface
                                local currentPos = part.Position
                                part.CFrame = CFrame.new(currentPos.X, lastWaterY, currentPos.Z) * (part.CFrame - part.CFrame.Position)
                                
                                -- Zero out all velocities completely
                                part.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                                part.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                                part.RotVelocity = Vector3.new(0, 0, 0)
                                
                                -- Make sure part doesn't interact with other physics
                                if part:IsA("BasePart") then
                                    part.CustomPhysicalProperties = PhysicalProperties.new(100, 0, 0, 1, 1)
                                end
                            else
                                lockedOnWater = false
                                lastWaterY = nil
                            end
                        else
                            lockedOnWater = false
                            lastWaterY = nil
                        end
                    else
                        connection:Disconnect()
                    end
                end)
                physicsPaints[part] = {type = "Buoyancy", connection = connection}
            end
            print("Applied " .. paintType .. " paint to " .. part.Name)
        end
    end

    -- NEW: Kinetic Amplifier
    local function applyKineticAmplifier()
        for _, part in ipairs(selectedParts) do
            if kineticAmplifiers[part] then
                if kineticAmplifiers[part].connection then kineticAmplifiers[part].connection:Disconnect() end
            end
            
            local charge = 0
            local lockedCFrame = part.CFrame
            
            local connection = RunService.Heartbeat:Connect(function()
                if part.Parent then
                    local vel = part.AssemblyLinearVelocity
                    if vel.Magnitude > 0.1 then
                        charge = charge + vel.Magnitude * 0.1
                    end
                    part.CFrame = lockedCFrame
                    part.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                    part.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                else
                    connection:Disconnect()
                end
            end)
            
            kineticAmplifiers[part] = {charge = charge, connection = connection, lockedCFrame = lockedCFrame}
            print("Applied Kinetic Amplifier to " .. part.Name)
        end
    end

    local function releaseKineticAmplifier()
        for _, part in ipairs(selectedParts) do
            if kineticAmplifiers[part] then
                if kineticAmplifiers[part].connection then kineticAmplifiers[part].connection:Disconnect() end
                local charge = kineticAmplifiers[part].charge or 0
                local dir = (mouse.Hit.Position - part.Position).Unit
                part.AssemblyLinearVelocity = dir * charge
                print("Released " .. charge .. " energy from " .. part.Name)
                kineticAmplifiers[part] = nil
            end
        end
    end

    -- NEW: Black Hole Tool
    local function applyBlackHole(strength)
        for _, part in ipairs(selectedParts) do
            if blackHoles[part] then
                if blackHoles[part].connection then blackHoles[part].connection:Disconnect() end
            end
            
            local connection = RunService.Heartbeat:Connect(function()
                if part.Parent then
                    for _, otherPart in ipairs(workspace:GetPartBoundsInRadius(part.Position, 100)) do
                        if otherPart ~= part and not otherPart.Anchored then
                            local dist = (part.Position - otherPart.Position).Magnitude
                            if dist > 1 then
                                local force = (part.Position - otherPart.Position).Unit * (strength * (100 / dist^2))
                                otherPart.AssemblyLinearVelocity = otherPart.AssemblyLinearVelocity + force * 0.1
                            end
                        end
                    end
                else
                    connection:Disconnect()
                end
            end)
            
            blackHoles[part] = {connection = connection, strength = strength}
            print("Applied Black Hole (strength " .. strength .. ") to " .. part.Name)
        end
    end

    local function removeBlackHole()
        for _, part in ipairs(selectedParts) do
            if blackHoles[part] then
                if blackHoles[part].connection then blackHoles[part].connection:Disconnect() end
                blackHoles[part] = nil
                print("Removed Black Hole from " .. part.Name)
            end
        end
    end

    -- NEW: Buoyancy Paint (Water Terrain)
    local function applyBuoyancyPaint(mode, dragMultiplier)
        dragMultiplier = dragMultiplier or 0.5
        for _, part in ipairs(selectedParts) do
            if buoyancyParts[part] then
                if buoyancyParts[part].connection then buoyancyParts[part].connection:Disconnect() end
            end
            
            local connection = RunService.Heartbeat:Connect(function()
                if part.Parent then
                    local region = Region3.new(part.Position - Vector3.new(1, 1, 1), part.Position + Vector3.new(1, 1, 1))
                    region = region:ExpandToGrid(4)
                    local terrain = workspace.Terrain
                    local materials, sizes = terrain:ReadVoxels(region, 4)
                    local size = materials.Size
                    
                    local waterFound = false
                    local waterLevel = -math.huge
                    
                    for x = 1, size.X do
                        for y = 1, size.Y do
                            for z = 1, size.Z do
                                if materials[x][y][z] == Enum.Material.Water then
                                    waterFound = true
                                    local worldPos = region.CFrame * Vector3.new(
                                        (x - size.X/2) * 4,
                                        (y - size.Y/2) * 4,
                                        (z - size.Z/2) * 4
                                    )
                                    waterLevel = math.max(waterLevel, worldPos.Y)
                                end
                            end
                        end
                    end
                    
                    if waterFound then
                        local submergedAmount = math.clamp((waterLevel - (part.Position.Y - part.Size.Y/2)) / part.Size.Y, 0, 1)
                        
                        if mode == "Hydrophobic" then
                            if submergedAmount > 0 then
                                local repelForce = Vector3.new(0, 1000 * submergedAmount * part.Mass, 0)
                                part.AssemblyLinearVelocity = part.AssemblyLinearVelocity + repelForce * 0.01
                            end
                        else
                            local density = part.CustomPhysicalProperties and part.CustomPhysicalProperties.Density or 0.7
                            local buoyancyForce = Vector3.new(0, workspace.Gravity * part.Mass * submergedAmount * (1 / density), 0)
                            part.AssemblyLinearVelocity = part.AssemblyLinearVelocity + buoyancyForce * 0.01
                            
                            if submergedAmount > 0 then
                                part.AssemblyLinearVelocity = part.AssemblyLinearVelocity * (1 - dragMultiplier * submergedAmount * 0.05)
                            end
                        end
                    end
                else
                    connection:Disconnect()
                end
            end)
            
            buoyancyParts[part] = {connection = connection, mode = mode, drag = dragMultiplier}
            print("Applied " .. mode .. " Buoyancy Paint to " .. part.Name)
        end
    end

    local function removeBuoyancyPaint()
        for _, part in ipairs(selectedParts) do
            if buoyancyParts[part] then
                if buoyancyParts[part].connection then buoyancyParts[part].connection:Disconnect() end
                buoyancyParts[part] = nil
                print("Removed Buoyancy Paint from " .. part.Name)
            end
        end
    end

    -- NEW: Momentum Absorber
    local function applyMomentumAbsorber(releaseMode)
        releaseMode = releaseMode or "Burst"
        for _, part in ipairs(selectedParts) do
            if momentumAbsorbers[part] then
                if momentumAbsorbers[part].connection then momentumAbsorbers[part].connection:Disconnect() end
            end
            
            local storedEnergy = 0
            local lastImpactPart = nil
            
            local connection = RunService.Heartbeat:Connect(function()
                if part.Parent then
                    local vel = part.AssemblyLinearVelocity
                    if vel.Magnitude > 1 then
                        local energyToAbsorb = vel.Magnitude * 0.1
                        storedEnergy = storedEnergy + energyToAbsorb
                        part.AssemblyLinearVelocity = vel * 0.95
                    end
                    
                    local touching = part:GetTouchingParts()
                    for _, touchPart in pairs(touching) do
                        if touchPart ~= part and not touchPart.Anchored then
                            lastImpactPart = touchPart
                        end
                    end
                else
                    connection:Disconnect()
                end
            end)
            
            momentumAbsorbers[part] = {
                connection = connection,
                energy = storedEnergy,
                mode = releaseMode,
                lastImpact = lastImpactPart
            }
            print("Applied Momentum Absorber (" .. releaseMode .. ") to " .. part.Name)
        end
    end

    local function releaseMomentumAbsorber()
        for _, part in ipairs(selectedParts) do
            if momentumAbsorbers[part] then
                local data = momentumAbsorbers[part]
                local energy = data.energy or 0
                
                if data.mode == "Burst" then
                    local direction = Vector3.new(0, 1, 0)
                    if data.lastImpact and data.lastImpact.Parent then
                        direction = (data.lastImpact.Position - part.Position).Unit
                    end
                    part.AssemblyLinearVelocity = direction * energy
                    print("Released " .. energy .. " energy in Burst mode")
                    
                elseif data.mode == "Pulse" then
                    task.spawn(function()
                        for i = 1, 10 do
                            if part.Parent then
                                part.AssemblyLinearVelocity = part.AssemblyLinearVelocity + Vector3.new(0, energy * 0.1, 0)
                                task.wait(0.1)
                            end
                        end
                    end)
                    print("Released " .. energy .. " energy in Pulse mode")
                    
                elseif data.mode == "Redirect" then
                    if data.lastImpact and data.lastImpact.Parent then
                        local direction = (data.lastImpact.Position - part.Position).Unit
                        data.lastImpact.AssemblyLinearVelocity = direction * energy
                        print("Redirected " .. energy .. " energy to " .. data.lastImpact.Name)
                    end
                end
                
                data.energy = 0
            end
        end
    end

    local function removeMomentumAbsorber()
        for _, part in ipairs(selectedParts) do
            if momentumAbsorbers[part] then
                if momentumAbsorbers[part].connection then momentumAbsorbers[part].connection:Disconnect() end
                momentumAbsorbers[part] = nil
                print("Removed Momentum Absorber from " .. part.Name)
            end
        end
    end

    -- NEW: Force Reflection (Reactive Surface)
    local function applyForceReflection(coefficient, reflectRotation, perfectMirror)
        coefficient = coefficient or 1.0
        for _, part in ipairs(selectedParts) do
            if forceReflectors[part] then
                if forceReflectors[part].connection then forceReflectors[part].connection:Disconnect() end
            end
            
            local connection = RunService.Heartbeat:Connect(function()
                if part.Parent then
                    local touching = part:GetTouchingParts()
                    for _, touchPart in pairs(touching) do
                        if touchPart ~= part and not touchPart.Anchored then
                            local vel = touchPart.AssemblyLinearVelocity
                            
                            if perfectMirror then
                                local normal = (part.Position - touchPart.Position).Unit
                                local reflected = vel - 2 * vel:Dot(normal) * normal
                                touchPart.AssemblyLinearVelocity = reflected * coefficient
                            else
                                touchPart.AssemblyLinearVelocity = -vel * coefficient
                            end
                            
                            if reflectRotation then
                                local angVel = touchPart.AssemblyAngularVelocity
                                touchPart.AssemblyAngularVelocity = -angVel * coefficient
                            end
                        end
                    end
                else
                    connection:Disconnect()
                end
            end)
            
            forceReflectors[part] = {
                connection = connection,
                coefficient = coefficient,
                rotation = reflectRotation,
                mirror = perfectMirror
            }
            print("Applied Force Reflection (coef: " .. coefficient .. ") to " .. part.Name)
        end
    end

    local function removeForceReflection()
        for _, part in ipairs(selectedParts) do
            if forceReflectors[part] then
                if forceReflectors[part].connection then forceReflectors[part].connection:Disconnect() end
                forceReflectors[part] = nil
                print("Removed Force Reflection from " .. part.Name)
            end
        end
    end

    -- NEW: Shockwave Generator
    local shockwaveMode2Active = false
    local shockwaveMode2Connection = nil
    local shockwaveMode2Submode = "ConstantShockwave"
    local shockwaveMode2Settings = {frequency = 1, strength = 100, radius = 50}
    
    local function applyShockwaveGenerator(mode, frequency, strength, radius)
        frequency = frequency or 1
        strength = strength or 100
        radius = radius or 50
        
        for _, part in ipairs(selectedParts) do
            if shockwaveGenerators[part] then
                if shockwaveGenerators[part].connection then shockwaveGenerators[part].connection:Disconnect() end
            end
            
            if mode == "Mode1Apply" then
                local lastTime = tick()
                
                local connection = RunService.Heartbeat:Connect(function()
                    if part.Parent then
                        local currentTime = tick()
                        
                        if currentTime - lastTime >= (1 / frequency) then
                            lastTime = currentTime
                            
                            local partsInRange = workspace:GetPartBoundsInRadius(part.Position, radius)
                            
                            for _, otherPart in ipairs(partsInRange) do
                                if otherPart ~= part and not otherPart.Anchored and otherPart.Parent ~= player.Character then
                                    local dist = (otherPart.Position - part.Position).Magnitude
                                    
                                    if dist > 0 and dist <= radius then
                                        local falloff = 1 - (dist / radius)
                                        local direction = (otherPart.Position - part.Position).Unit
                                        local force = direction * strength * falloff
                                        
                                        otherPart.AssemblyLinearVelocity = otherPart.AssemblyLinearVelocity + force * 0.1
                                        
                                        local upwardForce = Vector3.new(0, strength * falloff * 0.5, 0)
                                        otherPart.AssemblyLinearVelocity = otherPart.AssemblyLinearVelocity + upwardForce * 0.1
                                    end
                                end
                            end
                        end
                    else
                        connection:Disconnect()
                    end
                end)
                
                shockwaveGenerators[part] = {
                    connection = connection,
                    mode = "Mode1Apply",
                    frequency = frequency,
                    strength = strength,
                    radius = radius
                }
                
                print("Applied Shockwave Generator (Mode 1: Apply, freq: " .. frequency .. "Hz) to " .. part.Name)
            end
        end
    end

    local function removeShockwaveGenerator()
        for _, part in ipairs(selectedParts) do
            if shockwaveGenerators[part] then
                if shockwaveGenerators[part].connection then shockwaveGenerators[part].connection:Disconnect() end
                shockwaveGenerators[part] = nil
                print("Removed Shockwave Generator from " .. part.Name)
            end
        end
    end
    
    local function toggleShockwaveMode2(submode, frequency, strength, radius)
        shockwaveMode2Submode = submode or "ConstantShockwave"
        shockwaveMode2Settings.frequency = frequency or 1
        shockwaveMode2Settings.strength = strength or 100
        shockwaveMode2Settings.radius = radius or 50
        
        if shockwaveMode2Active then
            shockwaveMode2Active = false
            if shockwaveMode2Connection then
                shockwaveMode2Connection:Disconnect()
                shockwaveMode2Connection = nil
            end
            print("Disabled Shockwave Mode 2 (Press E to activate when enabled)")
        else
            shockwaveMode2Active = true
            print("Enabled Shockwave Mode 2: " .. shockwaveMode2Submode .. " - Press and hold E to send shockwaves at mouse!")
        end
    end
    
    local function sendShockwaveAtMouse()
        if not shockwaveMode2Active or not mouse then return end
        
        local mousePos = mouse.Hit.Position
        
        if shockwaveMode2Submode == "ConstantShockwave" then
            local partsInRange = workspace:GetPartBoundsInRadius(mousePos, shockwaveMode2Settings.radius)
            
            for _, otherPart in ipairs(partsInRange) do
                if not otherPart.Anchored and otherPart.Parent ~= player.Character then
                    local dist = (otherPart.Position - mousePos).Magnitude
                    
                    if dist > 0 and dist <= shockwaveMode2Settings.radius then
                        local falloff = 1 - (dist / shockwaveMode2Settings.radius)
                        local direction = (otherPart.Position - mousePos).Unit
                        local force = direction * shockwaveMode2Settings.strength * falloff * 0.05
                        
                        otherPart.AssemblyLinearVelocity = otherPart.AssemblyLinearVelocity + force
                    end
                end
            end
            
        elseif shockwaveMode2Submode == "FrequencyShockwave" then
            local partsInRange = workspace:GetPartBoundsInRadius(mousePos, shockwaveMode2Settings.radius)
            
            for _, otherPart in ipairs(partsInRange) do
                if not otherPart.Anchored and otherPart.Parent ~= player.Character then
                    local dist = (otherPart.Position - mousePos).Magnitude
                    
                    if dist > 0 and dist <= shockwaveMode2Settings.radius then
                        local falloff = 1 - (dist / shockwaveMode2Settings.radius)
                        local direction = (otherPart.Position - mousePos).Unit
                        local force = direction * shockwaveMode2Settings.strength * falloff
                        
                        otherPart.AssemblyLinearVelocity = otherPart.AssemblyLinearVelocity + force * 0.2
                        
                        local upwardForce = Vector3.new(0, shockwaveMode2Settings.strength * falloff * 0.5, 0)
                        otherPart.AssemblyLinearVelocity = otherPart.AssemblyLinearVelocity + upwardForce * 0.2
                    end
                end
            end
        end
    end

    -- EXCLUSIVE: Network Ownership Zero Gravity (ONE-TIME APPLY - No Toggle)
    local exclusiveZeroGravityForces = {}
    local lastZeroGCheck = 0
    local zeroGCheckInterval = 0.5 -- Check every 0.5 seconds instead of every frame
    
    local function applyExclusiveZeroGravity()
        -- One-time apply to all current unanchored parts
        local partsToCheck = {}
        for _, part in ipairs(workspace:GetDescendants()) do
            if part:IsA("BasePart") and not part.Anchored and part.Parent ~= player.Character then
                table.insert(partsToCheck, part)
            end
        end
        
        local appliedCount = 0
        for _, part in ipairs(partsToCheck) do
            if not exclusiveZeroGravityForces[part] then
                pcall(function()
                    part:SetNetworkOwner(player)
                end)
                
                local attachment = Instance.new("Attachment")
                attachment.Parent = part
                
                local vectorForce = Instance.new("VectorForce")
                vectorForce.Attachment0 = attachment
                vectorForce.ApplyAtCenterOfMass = true
                vectorForce.RelativeTo = Enum.ActuatorRelativeTo.World
                vectorForce.Force = Vector3.new(0, part.Mass * workspace.Gravity, 0)
                vectorForce.Parent = part
                
                exclusiveZeroGravityForces[part] = {
                    vectorForce = vectorForce,
                    attachment = attachment
                }
                appliedCount = appliedCount + 1
            end
        end
        
        print("Applied Exclusive Zero Gravity to " .. appliedCount .. " unanchored parts (One-time apply)")
    end
    
    local function clearExclusiveZeroGravity()
        -- Clean up all forces
        for part, data in pairs(exclusiveZeroGravityForces) do
            if data.vectorForce then data.vectorForce:Destroy() end
            if data.attachment then data.attachment:Destroy() end
        end
        exclusiveZeroGravityForces = {}
        
        print("Cleared Exclusive Zero Gravity from all parts")
    end
    
    -- Keep the old toggle version for backward compatibility in case it's called
    local function toggleExclusiveZeroGravity()
        if exclusiveZeroGravity then
            exclusiveZeroGravity = false
            if exclusiveZeroGravityConnection then
                exclusiveZeroGravityConnection:Disconnect()
                exclusiveZeroGravityConnection = nil
            end
            clearExclusiveZeroGravity()
        else
            exclusiveZeroGravity = true
            applyExclusiveZeroGravity()
        end
    end

    -- EXCLUSIVE: Orbiter Core (FIXED - Apply to Anchored Part, Orbits All Unanchored)
    local function applyOrbiterCore(frequency, orbitRadius, orbitSpeed)
        frequency = frequency or 2
        orbitRadius = orbitRadius or 10
        orbitSpeed = orbitSpeed or 5
        
        for _, part in ipairs(selectedParts) do
            if orbiterCores[part] then
                if orbiterCores[part].connection then orbiterCores[part].connection:Disconnect() end
            end
            
            if not part.Anchored then
                warn("Orbiter Core requires ANCHORED parts! " .. part.Name .. " is not anchored.")
                return
            end
            
            local orbitingParts = {}
            local orbitAngle = 0
            local stripIndex = 0
            
            local connection = RunService.Heartbeat:Connect(function()
                if part.Parent then
                    orbitAngle = orbitAngle + (orbitSpeed * 0.016)
                    
                    -- Get ALL unanchored parts in workspace (excluding player character)
                    local partsInWorld = workspace:GetDescendants()
                    for _, otherPart in ipairs(partsInWorld) do
                        if otherPart:IsA("BasePart") and not otherPart.Anchored and otherPart ~= part and otherPart.Parent ~= player.Character then
                            -- Try to set network ownership
                            pcall(function()
                                otherPart:SetNetworkOwner(player)
                            end)
                            
                            if not orbitingParts[otherPart] then
                                orbitingParts[otherPart] = {
                                    index = stripIndex,
                                    angleOffset = stripIndex * (360 / frequency)
                                }
                                stripIndex = stripIndex + 1
                            end
                            
                            local data = orbitingParts[otherPart]
                            local currentAngle = orbitAngle + data.angleOffset
                            local radianAngle = math.rad(currentAngle)
                            
                            local targetX = part.Position.X + math.cos(radianAngle) * (orbitRadius + data.index * 0.5)
                            local targetZ = part.Position.Z + math.sin(radianAngle) * (orbitRadius + data.index * 0.5)
                            local targetY = part.Position.Y + math.sin(orbitAngle * 0.5 + data.index) * 3
                            
                            local targetPosition = Vector3.new(targetX, targetY, targetZ)
                            local direction = (targetPosition - otherPart.Position)
                            
                            local pullForce = direction.Unit * math.min(direction.Magnitude * 2, 50)
                            otherPart.AssemblyLinearVelocity = pullForce
                        end
                    end
                    
                    -- Clean up parts that no longer exist
                    local newOrbitingParts = {}
                    for otherPart, data in pairs(orbitingParts) do
                        if otherPart.Parent then
                            newOrbitingParts[otherPart] = data
                        end
                    end
                    orbitingParts = newOrbitingParts
                else
                    connection:Disconnect()
                end
            end)
            
            orbiterCores[part] = {
                connection = connection,
                frequency = frequency,
                radius = orbitRadius,
                speed = orbitSpeed
            }
            
            print("Applied Orbiter Core to anchored part " .. part.Name .. " (freq: " .. frequency .. ", radius: " .. orbitRadius .. ")")
        end
    end
    
    local function removeOrbiterCore()
        for _, part in ipairs(selectedParts) do
            if orbiterCores[part] then
                if orbiterCores[part].connection then orbiterCores[part].connection:Disconnect() end
                orbiterCores[part] = nil
                print("Removed Orbiter Core from " .. part.Name)
            end
        end
    end

    -- NEW: Global Physics Paint (Apply to ALL unanchored parts)
    local globalPaintConnections = {}
    local globalPaintActive = {}
    
    local function applyGlobalPhysicsPaint(paintType)
        -- Clear previous global paints if any
        if globalPaintConnections[paintType] then
            if globalPaintConnections[paintType].connection then
                globalPaintConnections[paintType].connection:Disconnect()
            end
        end
        
        if paintType == "Slippery" then
            local connection = RunService.Heartbeat:Connect(function()
                for _, part in ipairs(workspace:GetDescendants()) do
                    if part:IsA("BasePart") and not part.Anchored and part.Parent ~= player.Character then
                        if not globalPaintActive[part] or globalPaintActive[part] ~= "Slippery" then
                            part.CustomPhysicalProperties = PhysicalProperties.new(0.7, 0.01, 0.5)
                            globalPaintActive[part] = "Slippery"
                        end
                    end
                end
            end)
            globalPaintConnections["Slippery"] = {connection = connection}
            print("Applied Slippery paint to ALL unanchored parts globally")
            
        elseif paintType == "Bouncy" then
            local connection = RunService.Heartbeat:Connect(function()
                for _, part in ipairs(workspace:GetDescendants()) do
                    if part:IsA("BasePart") and not part.Anchored and part.Parent ~= player.Character then
                        if not globalPaintActive[part] or globalPaintActive[part] ~= "Bouncy" then
                            part.CustomPhysicalProperties = PhysicalProperties.new(0.7, 0.3, 1)
                            globalPaintActive[part] = "Bouncy"
                        end
                    end
                end
            end)
            globalPaintConnections["Bouncy"] = {connection = connection}
            print("Applied Bouncy paint to ALL unanchored parts globally")
            
        elseif paintType == "Magnetic" then
            local connection = RunService.Heartbeat:Connect(function()
                for _, part in ipairs(workspace:GetDescendants()) do
                    if part:IsA("BasePart") and not part.Anchored and part.Parent ~= player.Character then
                        globalPaintActive[part] = "Magnetic"
                        
                        for _, otherPart in ipairs(workspace:GetDescendants()) do
                            if otherPart:IsA("BasePart") and otherPart ~= part and not otherPart.Anchored and otherPart.Parent ~= player.Character and globalPaintActive[otherPart] == "Magnetic" then
                                local dist = (part.Position - otherPart.Position).Magnitude
                                if dist < 50 then
                                    local force = (otherPart.Position - part.Position).Unit * (500 / (dist + 1))
                                    part.AssemblyLinearVelocity = part.AssemblyLinearVelocity + force * 0.01
                                end
                            end
                        end
                    end
                end
            end)
            globalPaintConnections["Magnetic"] = {connection = connection}
            print("Applied Magnetic paint to ALL unanchored parts globally")
            
        elseif paintType == "Gooey" then
            local connection = RunService.Heartbeat:Connect(function()
                for _, part in ipairs(workspace:GetDescendants()) do
                    if part:IsA("BasePart") and not part.Anchored and part.Parent ~= player.Character then
                        globalPaintActive[part] = "Gooey"
                        
                        local touching = part:GetTouchingParts()
                        for _, touchPart in pairs(touching) do
                            if touchPart.Anchored then
                                part.AssemblyLinearVelocity = part.AssemblyLinearVelocity * 0.5
                            end
                        end
                    end
                end
            end)
            globalPaintConnections["Gooey"] = {connection = connection}
            print("Applied Gooey paint to ALL unanchored parts globally")
            
        elseif paintType == "Hydrophobic" then
            local connection = RunService.Heartbeat:Connect(function()
                for _, part in ipairs(workspace:GetDescendants()) do
                    if part:IsA("BasePart") and not part.Anchored and part.Parent ~= player.Character then
                        globalPaintActive[part] = "Hydrophobic"
                        
                        local region = Region3.new(part.Position - Vector3.new(2, 2, 2), part.Position + Vector3.new(2, 2, 2))
                        region = region:ExpandToGrid(4)
                        local terrain = workspace.Terrain
                        local materials, sizes = terrain:ReadVoxels(region, 4)
                        local size = materials.Size
                        
                        local waterFound = false
                        local waterLevel = -math.huge
                        
                        for x = 1, size.X do
                            for y = 1, size.Y do
                                for z = 1, size.Z do
                                    if materials[x][y][z] == Enum.Material.Water then
                                        waterFound = true
                                        local worldPos = region.CFrame * Vector3.new(
                                            (x - size.X/2) * 4,
                                            (y - size.Y/2) * 4,
                                            (z - size.Z/2) * 4
                                        )
                                        waterLevel = math.max(waterLevel, worldPos.Y)
                                    end
                                end
                            end
                        end
                        
                        if waterFound then
                            local bottomY = part.Position.Y - part.Size.Y/2
                            if bottomY < waterLevel + 2 then
                                -- Strong upward force to stay above water
                                local upwardForce = Vector3.new(0, part.Mass * workspace.Gravity * 3, 0)
                                part.AssemblyLinearVelocity = part.AssemblyLinearVelocity + upwardForce * 0.1
                                
                                -- Cancel any downward velocity
                                if part.AssemblyLinearVelocity.Y < 0 then
                                    part.AssemblyLinearVelocity = Vector3.new(
                                        part.AssemblyLinearVelocity.X,
                                        0,
                                        part.AssemblyLinearVelocity.Z
                                    )
                                end
                            end
                        end
                    end
                end
            end)
            globalPaintConnections["Hydrophobic"] = {connection = connection}
            print("Applied Hydrophobic paint to ALL unanchored parts globally")
        end
    end
    
    local function clearGlobalPhysicsPaint()
        for paintType, data in pairs(globalPaintConnections) do
            if data.connection then
                data.connection:Disconnect()
            end
        end
        globalPaintConnections = {}
        
        for part, _ in pairs(globalPaintActive) do
            if part.Parent then
                part.CustomPhysicalProperties = nil
            end
        end
        globalPaintActive = {}
        
        print("Cleared all global physics paints")
    end

    -- NEW: Exponential Tween (Moves between two positions with exponential easing)
    local function applyExponentialTween(pos1, pos2, tweenTime, pos1Easing, pos2Easing)
        pos1Easing = pos1Easing or "Out"
        pos2Easing = pos2Easing or "In"
        
        for _, part in ipairs(selectedParts) do
            replicateToServer(function()
                setNetworkOwnership(part)
                
                if exponentialTweenParts[part] then
                    if exponentialTweenParts[part].connection then exponentialTweenParts[part].connection:Disconnect() end
                    if exponentialTweenParts[part].bodyPosition then exponentialTweenParts[part].bodyPosition:Destroy() end
                    if exponentialTweenParts[part].bodyGyro then exponentialTweenParts[part].bodyGyro:Destroy() end
                end
                
                -- Lock rotation and prevent external forces
                local bodyPosition = Instance.new("BodyPosition")
                bodyPosition.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                bodyPosition.D = 5000
                bodyPosition.P = 50000
                bodyPosition.Parent = part
                
                local bodyGyro = Instance.new("BodyGyro")
                bodyGyro.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
                bodyGyro.D = 5000
                bodyGyro.P = 50000
                bodyGyro.CFrame = part.CFrame
                bodyGyro.Parent = part
                
                -- Cancel gravity
                local attachment = Instance.new("Attachment")
                attachment.Parent = part
                
                local vectorForce = Instance.new("VectorForce")
                vectorForce.Attachment0 = attachment
                vectorForce.ApplyAtCenterOfMass = true
                vectorForce.RelativeTo = Enum.ActuatorRelativeTo.World
                vectorForce.Force = Vector3.new(0, part.Mass * workspace.Gravity, 0)
                vectorForce.Parent = part
                
                local startPos = part.Position
                local targetPos1 = startPos + pos1
                local targetPos2 = startPos + pos2
                local movingToPos1 = true
                
                local function tweenToPosition(targetPos, easingDirection)
                    local startTime = tick()
                    local startPosition = part.Position
                    
                    local connection
                    connection = RunService.Heartbeat:Connect(function()
                        if not part.Parent then
                            connection:Disconnect()
                            return
                        end
                        
                        local elapsed = tick() - startTime
                        local alpha = math.min(elapsed / tweenTime, 1)
                        
                        -- Apply exponential easing with InOut switching at midpoint
                        local easedAlpha
                        if easingDirection == "In" then
                            -- In: Decelerate (start fast, end slow) then Accelerate (start slow, end fast)
                            if alpha < 0.5 then
                                -- First half: EaseOut (decelerate)
                                local t = alpha * 2
                                easedAlpha = (t == 1 and 1 or 1 - math.pow(2, -10 * t)) * 0.5
                            else
                                -- Second half: EaseIn (accelerate)
                                local t = (alpha - 0.5) * 2
                                easedAlpha = 0.5 + (t == 0 and 0 or math.pow(2, 10 * (t - 1))) * 0.5
                            end
                        else -- Out
                            -- Out: Accelerate (start slow, end fast) then Decelerate (start fast, end slow)
                            if alpha < 0.5 then
                                -- First half: EaseIn (accelerate)
                                local t = alpha * 2
                                easedAlpha = (t == 0 and 0 or math.pow(2, 10 * (t - 1))) * 0.5
                            else
                                -- Second half: EaseOut (decelerate)
                                local t = (alpha - 0.5) * 2
                                easedAlpha = 0.5 + (t == 1 and 1 or 1 - math.pow(2, -10 * t)) * 0.5
                            end
                        end
                        
                        local currentPos = startPosition:Lerp(targetPos, easedAlpha)
                        bodyPosition.Position = currentPos
                        
                        -- Keep rotation locked
                        bodyGyro.CFrame = part.CFrame
                        
                        -- Force velocity to zero
                        part.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                        part.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                        
                        if alpha >= 1 then
                            connection:Disconnect()
                            
                            -- Switch direction
                            if movingToPos1 then
                                movingToPos1 = false
                                tweenToPosition(targetPos2, pos2Easing)
                            else
                                movingToPos1 = true
                                tweenToPosition(targetPos1, pos1Easing)
                            end
                        end
                    end)
                    
                    if exponentialTweenParts[part] then
                        exponentialTweenParts[part].currentConnection = connection
                    end
                end
                
                exponentialTweenParts[part] = {
                    bodyPosition = bodyPosition,
                    bodyGyro = bodyGyro,
                    attachment = attachment,
                    vectorForce = vectorForce,
                    pos1 = pos1,
                    pos2 = pos2,
                    tweenTime = tweenTime,
                    pos1Easing = pos1Easing,
                    pos2Easing = pos2Easing
                }
                
                -- Start the tween
                tweenToPosition(targetPos1, pos1Easing)
                
                print("Applied Exponential Tween to " .. part.Name .. " (Time: " .. tweenTime .. "s, Pos1: " .. pos1Easing .. ", Pos2: " .. pos2Easing .. ")")
            end)
        end
    end
    
    local function removeExponentialTween()
        for _, part in ipairs(selectedParts) do
            if exponentialTweenParts[part] then
                if exponentialTweenParts[part].currentConnection then exponentialTweenParts[part].currentConnection:Disconnect() end
                if exponentialTweenParts[part].connection then exponentialTweenParts[part].connection:Disconnect() end
                if exponentialTweenParts[part].bodyPosition then exponentialTweenParts[part].bodyPosition:Destroy() end
                if exponentialTweenParts[part].bodyGyro then exponentialTweenParts[part].bodyGyro:Destroy() end
                if exponentialTweenParts[part].vectorForce then exponentialTweenParts[part].vectorForce:Destroy() end
                if exponentialTweenParts[part].attachment then exponentialTweenParts[part].attachment:Destroy() end
                exponentialTweenParts[part] = nil
                print("Removed Exponential Tween from " .. part.Name)
            end
        end
    end
    local function applyGravityDistorter(gravityVector, strength, radius, mode)
        mode = mode or "Normal"
        radius = radius or 50
        for _, part in ipairs(selectedParts) do
            if gravityDistorters[part] then
                if gravityDistorters[part].connection then gravityDistorters[part].connection:Disconnect() end
            end
            
            local vortexAngle = 0
            
            local connection = RunService.Heartbeat:Connect(function()
                if part.Parent then
                    local partsInRange = workspace:GetPartBoundsInRadius(part.Position, radius)
                    
                    for _, otherPart in ipairs(partsInRange) do
                        if otherPart ~= part and not otherPart.Anchored then
                            local dist = (part.Position - otherPart.Position).Magnitude
                            
                            if dist > 1 and dist < radius then
                                local insideOnly = false
                                if mode == "InsideOnly" then
                                    local relPos = part.CFrame:PointToObjectSpace(otherPart.Position)
                                    local halfSize = part.Size / 2
                                    insideOnly = math.abs(relPos.X) < halfSize.X and 
                                                math.abs(relPos.Y) < halfSize.Y and 
                                                math.abs(relPos.Z) < halfSize.Z
                                end
                                
                                if not (mode == "InsideOnly") or insideOnly then
                                    local force
                                    
                                    if mode == "Chaotic" then
                                        local randomDir = Vector3.new(
                                            math.random() - 0.5,
                                            math.random() - 0.5,
                                            math.random() - 0.5
                                        ).Unit
                                        force = randomDir * (strength / dist)
                                        
                                    elseif mode == "Vortex" then
                                        vortexAngle = vortexAngle + 0.05
                                        local rotatedGravity = CFrame.Angles(0, vortexAngle, 0) * gravityVector
                                        force = rotatedGravity * (strength / dist)
                                        local tangent = (otherPart.Position - part.Position):Cross(Vector3.new(0, 1, 0)).Unit
                                        force = force + tangent * strength * 0.5
                                        
                                    elseif mode == "Inverse" then
                                        force = -gravityVector * (strength / dist)
                                        
                                    else
                                        force = gravityVector * (strength / dist)
                                    end
                                    
                                    otherPart.AssemblyLinearVelocity = otherPart.AssemblyLinearVelocity + force * 0.01
                                end
                            end
                        end
                    end
                else
                    connection:Disconnect()
                end
            end)
            
            gravityDistorters[part] = {
                connection = connection,
                gravity = gravityVector,
                strength = strength,
                radius = radius,
                mode = mode
            }
            print("Applied Gravity Distorter (" .. mode .. ", radius: " .. radius .. ") to " .. part.Name)
        end
    end

    local function removeGravityDistorter()
        for _, part in ipairs(selectedParts) do
            if gravityDistorters[part] then
                if gravityDistorters[part].connection then gravityDistorters[part].connection:Disconnect() end
                gravityDistorters[part] = nil
                print("Removed Gravity Distorter from " .. part.Name)
            end
        end
    end

    local function onTpPartClicked(part)
        if not isToolEquipped then return end
        if part.Parent == player.Character then return end
        if part.Anchored then warn("Cannot select anchored parts for TP!") return end
        if tpLockEnabled and tpLockedPart then return end
        
        -- Remove old TP selection box if it exists
        if tpSelectionBox then 
            tpSelectionBox:Destroy() 
            tpSelectionBox = nil 
        end
        
        tpLockedPart = part
        
        -- Check if this part is already in selectedParts - reuse its selection box
        local existingBox = selectionBoxes[part]
        if existingBox then
            -- Change color to indicate TP mode
            existingBox.Color3 = Color3.fromRGB(255, 100, 255)
            existingBox.LineThickness = 0.3
            tpSelectionBox = existingBox
        else
            -- Create new selection box for TP
            tpSelectionBox = Instance.new("SelectionBox")
            tpSelectionBox.Adornee = part
            tpSelectionBox.Color3 = Color3.fromRGB(255, 100, 255)
            tpSelectionBox.LineThickness = 0.3
            tpSelectionBox.Transparency = 0.2
            tpSelectionBox.Parent = part
        end
        
        updateTpSelectionStatus()
        setNetworkOwnership(part)
    end

    local function teleportPart(part, position)
        replicateToServer(function()
            setNetworkOwnership(part)
            if part and part.Parent and not part.Anchored then
                local offset = part.Position - part.CFrame.Position
                part.CFrame = CFrame.new(position + offset, position + offset + part.CFrame.LookVector)
                task.wait()
                part.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                print("Teleported " .. part.Name .. " to " .. tostring(position))
            end
        end)
    end

    local function clearTpSelection()
        if tpSelectionBox and tpSelectionBox.Parent then 
            -- Restore original color if it's a shared selection box
            if tpLockedPart and selectionBoxes[tpLockedPart] == tpSelectionBox then
                tpSelectionBox.Color3 = Color3.fromRGB(0, 255, 255)
                tpSelectionBox.LineThickness = 0.2
            else
                tpSelectionBox:Destroy()
            end
        end
        tpSelectionBox = nil
        tpLockedPart = nil
        tpLockEnabled = false
        tpAtCursorEnabled = false
        updateTpSelectionStatus()
    end

    function updateTpSelectionStatus()
        if screenGui then
            local statusLabel = screenGui:FindFirstChild("MainFrame")
                and screenGui.MainFrame:FindFirstChild("GridContainer")
                and screenGui.MainFrame.GridContainer:FindFirstChild("UnAnchoredTP")
                and screenGui.MainFrame.GridContainer.UnAnchoredTP:FindFirstChild("StatusLabel")
            if statusLabel then
                if not tpLockedPart then
                    statusLabel.Text = "Select a part from Selection panel.\nThen enable Lock & TP here!"
                else
                    local lockStatus = tpLockEnabled and "ðŸ”’ LOCKED" or "ðŸ”“ unlocked"
                    local tpStatus = tpAtCursorEnabled and "âœ… TP ON" or "âŒ tp off"
                    statusLabel.Text = "Selected: " .. tpLockedPart.Name .. "\n" .. lockStatus .. " | " .. tpStatus
                end
            end
        end
    end

    local function applyImpulse(direction, force)
        for _, part in ipairs(selectedParts) do
            replicateToServer(function()
                setNetworkOwnership(part)
                local impulse = direction * force * part.Mass
                part:ApplyImpulse(impulse)
                print("Applied impulse " .. tostring(impulse) .. " to " .. part.Name)
            end)
        end
    end

    local maxSelectedParts = 2 -- NEW: Configurable max selection
    local selectedConstraintForEditing = nil -- NEW: Store selected constraint for editing
    local constraintSelectionBoxes = {} -- NEW: Store selection boxes for constraints
    local constraintEditorPanel = nil -- NEW: Constraint editor panel reference

    local function onPartClicked(part)
        if not isToolEquipped then return end
        if part.Parent == player.Character then return end
        
        if studSelectMode and mouse then
            local studData = getClosestStudPosition(part, mouse.Hit.Position)
            if not studData then return end
            
            for i, stud in ipairs(selectedStuds) do
                if stud.part == part and (stud.localPos - studData.localPos).Magnitude < 0.1 then
                    table.remove(selectedStuds, i)
                    if selectionBoxes[stud] and selectionBoxes[stud].visualPart then
                        selectionBoxes[stud].visualPart:Destroy()
                        selectionBoxes[stud] = nil
                    end
                    updateSelectionStatus()
                    return
                end
            end
            
            if #selectedStuds >= maxSelectedParts then
                local oldestStud = selectedStuds[1]
                if selectionBoxes[oldestStud] and selectionBoxes[oldestStud].visualPart then
                    selectionBoxes[oldestStud].visualPart:Destroy()
                    selectionBoxes[oldestStud] = nil
                end
                table.remove(selectedStuds, 1)
            end
            
            table.insert(selectedStuds, studData)
            
            local studPart = Instance.new("Part")
            studPart.Size = Vector3.new(0.4, 0.2, 0.4)
            studPart.CFrame = CFrame.new(studData.worldPos)
            studPart.Anchored = true
            studPart.CanCollide = false
            studPart.Transparency = 1
            studPart.Parent = workspace
            
            local selectionBox = Instance.new("SelectionBox")
            selectionBox.Adornee = studPart
            selectionBox.Color3 = Color3.fromRGB(255, 255, 0)
            selectionBox.LineThickness = 0.3
            selectionBox.Transparency = 0.2
            selectionBox.Parent = studPart
            
            selectionBoxes[studData] = {visualPart = studPart, box = selectionBox}
            studData.visualPart = studPart
            
            updateSelectionStatus()
            return
        end
        
        for i, selectedPart in ipairs(selectedParts) do
            if selectedPart == part then
                table.remove(selectedParts, i)
                if selectionBoxes[part] then 
                    selectionBoxes[part]:Destroy() 
                    selectionBoxes[part] = nil 
                end
                if tpLockedPart == part then
                    tpLockedPart = nil
                    tpSelectionBox = nil
                end
                updateSelectionStatus()
                updateTpSelectionStatus()
                return
            end
        end
        
        if #selectedParts >= maxSelectedParts then
            local oldestPart = selectedParts[1]
            if selectionBoxes[oldestPart] then 
                selectionBoxes[oldestPart]:Destroy() 
                selectionBoxes[oldestPart] = nil 
            end
            table.remove(selectedParts, 1)
        end
        
        table.insert(selectedParts, part)
        
        local selectionBox = Instance.new("SelectionBox")
        selectionBox.Adornee = part
        selectionBox.Color3 = Color3.fromRGB(0, 255, 255)
        selectionBox.LineThickness = 0.01
        selectionBox.Transparency = 0.3
        selectionBox.Parent = part
        selectionBoxes[part] = selectionBox
        
        updateSelectionStatus()
        setNetworkOwnership(part)
        
        if constraintMode == "Face" and mouse then
            selectedFaces[part] = getClosestFace(part, mouse.Hit.Position)
            print("Selected face: " .. tostring(selectedFaces[part]))
        end
    end

    local function clearSelection()
        for part, selectionBox in pairs(selectionBoxes) do
            if selectionBox and selectionBox.Parent then selectionBox:Destroy() end
        end
        selectionBoxes = {}
        selectedParts = {}
        selectedStuds = {}
        selectedFaces = {}
        
        tpLockedPart = nil
        tpSelectionBox = nil
        tpLockEnabled = false
        tpAtCursorEnabled = false
        
        updateSelectionStatus()
        updateTpSelectionStatus()
    end

    function updateSelectionStatus()
        if screenGui then
            local statusLabel = screenGui:FindFirstChild("MainFrame")
                and screenGui.MainFrame:FindFirstChild("GridContainer")
                and screenGui.MainFrame.GridContainer:FindFirstChild("Selection")
                and screenGui.MainFrame.GridContainer.Selection:FindFirstChild("StatusLabel")
            if statusLabel then
                if studSelectMode then
                    local count = #selectedStuds
                    if count == 0 then
                        statusLabel.Text = "Click studs to select them"
                    elseif count == 1 then
                        statusLabel.Text = "Selected: 1 stud\n(Click another for constraints)"
                    else
                        statusLabel.Text = "Selected: 2 studs"
                    end
                else
                    local count = #selectedParts
                    if count == 0 then
                        statusLabel.Text = "Click parts to select them"
                    elseif count == 1 then
                        statusLabel.Text = "Selected: " .. selectedParts[1].Name .. "\n(Click another for constraints)"
                    else
                        statusLabel.Text = "Selected: " .. selectedParts[1].Name .. "\nand " .. selectedParts[2].Name
                    end
                end
            end
        end
    end

    -- NEW: Keybind Manager Storage
    local activeKeybinds = {} -- {id: {parts, velocity, mode, keys, triggerType, connection}}
    local nextKeybindId = 1
    
    local function createConstraintsPanel(parent)
        local panel = createPanel(parent, "â›“ï¸ Constraints", 1)
        panel.Size = UDim2.new(0, 280, 0, 280)
        
        local dropdown = createDropdown(panel, {"Rope", "Rod", "Hinge", "BallSocket", "Chain", "Plane", "Cylindrical", "Prismatic", "Spring", "NoCollision"})
        dropdown.Position = UDim2.new(0, 10, 0, 40)
        dropdown.Size = UDim2.new(0, 110, 0, 25)
        
        -- Spring visual toggle
        local springVisLabel = Instance.new("TextLabel")
        springVisLabel.Size = UDim2.new(0, 80, 0, 25)
        springVisLabel.Position = UDim2.new(0, 10, 0, 75)
        springVisLabel.BackgroundTransparency = 1
        springVisLabel.Text = "Spring Visual:"
        springVisLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
        springVisLabel.TextSize = 9
        springVisLabel.Font = Enum.Font.GothamBold
        springVisLabel.TextXAlignment = Enum.TextXAlignment.Left
        springVisLabel.Parent = panel
        
        local springVisBtn, updateSpringVis = createToggleButton(panel, "Show", UDim2.new(0, 60, 0, 25), UDim2.new(0, 95, 0, 75), true)
        springVisBtn.MouseButton1Click:Connect(function()
            local state = not springVisBtn:GetAttribute("ToggleState")
            springVisBtn:SetAttribute("ToggleState", state)
            updateSpringVis(state)
        end)
        
        -- Mode dropdown for attachment positioning
        local modeDropdown = createDropdown(panel, {"Core", "Face", "Auto Face", "Anti-AutoFace"})
        modeDropdown.Position = UDim2.new(0, 165, 0, 40)
        modeDropdown.Size = UDim2.new(0, 80, 0, 25)
        modeDropdown.MouseButton1Click:Connect(function()
            task.wait(0.1)
            constraintMode = modeDropdown.Text:gsub(" â–¼", "")
        end)
        
        -- Chain mode dropdown
        local chainLabel = Instance.new("TextLabel")
        chainLabel.Size = UDim2.new(0, 70, 0, 25)
        chainLabel.Position = UDim2.new(0, 10, 0, 75)
        chainLabel.BackgroundTransparency = 1
        chainLabel.Text = "Chain Mode:"
        chainLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
        chainLabel.TextSize = 9
        chainLabel.Font = Enum.Font.GothamBold
        chainLabel.TextXAlignment = Enum.TextXAlignment.Left
        chainLabel.Parent = panel
        
        local chainDropdown = createDropdown(panel, {"Chain", "First to All"})
        chainDropdown.Position = UDim2.new(0, 85, 0, 75)
        chainDropdown.Size = UDim2.new(0, 80, 0, 25)
        local chainModeValue = "Chain"
        chainDropdown.MouseButton1Click:Connect(function()
            task.wait(0.1)
            chainModeValue = chainDropdown.Text:gsub(" â–¼", "")
        end)
        
        local visBtn, updateVis = createToggleButton(panel, "Visual", UDim2.new(0, 50, 0, 25), UDim2.new(0, 10, 0, 110), constraintVisual)
        visBtn.MouseButton1Click:Connect(function()
            constraintVisual = not constraintVisual
            visBtn:SetAttribute("ToggleState", constraintVisual)
            updateVis(constraintVisual)
        end)
        
        local collBtn, updateColl = createToggleButton(panel, "Coll", UDim2.new(0, 50, 0, 25), UDim2.new(0, 70, 0, 110), constraintCollision)
        collBtn.MouseButton1Click:Connect(function()
            constraintCollision = not constraintCollision
            collBtn:SetAttribute("ToggleState", constraintCollision)
            updateColl(constraintCollision)
        end)
        
        -- NoCollision special buttons
        local noCollLabel = Instance.new("TextLabel")
        noCollLabel.Size = UDim2.new(1, -20, 0, 20)
        noCollLabel.Position = UDim2.new(0, 10, 0, 145)
        noCollLabel.BackgroundTransparency = 1
        noCollLabel.Text = "NoCollision Quick Apply:"
        noCollLabel.TextColor3 = Color3.fromRGB(255, 200, 100)
        noCollLabel.TextSize = 10
        noCollLabel.Font = Enum.Font.GothamBold
        noCollLabel.TextXAlignment = Enum.TextXAlignment.Left
        noCollLabel.Parent = panel
        
        local noCollSelectedBtn = createButton(panel, "Selected Only", UDim2.new(0, 90, 0, 25), UDim2.new(0, 10, 0, 170))
        noCollSelectedBtn.BackgroundColor3 = Color3.fromRGB(100, 100, 200)
        noCollSelectedBtn.TextSize = 10
        noCollSelectedBtn.MouseButton1Click:Connect(function()
            applyConstraint("NoCollision â–¼")
        end)
        
        local noCollAllBtn = createButton(panel, "All Parts", UDim2.new(0, 70, 0, 25), UDim2.new(0, 110, 0, 170))
        noCollAllBtn.BackgroundColor3 = Color3.fromRGB(150, 100, 200)
        noCollAllBtn.TextSize = 10
        noCollAllBtn.MouseButton1Click:Connect(function()
            applyNoCollisionToAllParts()
        end)
        
        local noCollRemoveBtn = createButton(panel, "Remove All NC", UDim2.new(0, 85, 0, 25), UDim2.new(0, 190, 0, 170))
        noCollRemoveBtn.BackgroundColor3 = Color3.fromRGB(200, 100, 100)
        noCollRemoveBtn.TextSize = 9
        noCollRemoveBtn.MouseButton1Click:Connect(function()
            removeAllNoCollisionConstraints()
        end)
        
        -- Collision Constraint buttons
        local collLabel = Instance.new("TextLabel")
        collLabel.Size = UDim2.new(1, -20, 0, 20)
        collLabel.Position = UDim2.new(0, 10, 0, 205)
        collLabel.BackgroundTransparency = 1
        collLabel.Text = "Collision (Force Collisions):"
        collLabel.TextColor3 = Color3.fromRGB(100, 255, 100)
        collLabel.TextSize = 10
        collLabel.Font = Enum.Font.GothamBold
        collLabel.TextXAlignment = Enum.TextXAlignment.Left
        collLabel.Parent = panel
        
        local collSelectedBtn = createButton(panel, "Selected Only", UDim2.new(0, 90, 0, 25), UDim2.new(0, 10, 0, 230))
        collSelectedBtn.BackgroundColor3 = Color3.fromRGB(100, 200, 100)
        collSelectedBtn.TextSize = 10
        collSelectedBtn.MouseButton1Click:Connect(function()
            applyCollisionConstraint()
        end)
        
        local collRemoveBtn = createButton(panel, "Remove All Coll", UDim2.new(0, 90, 0, 25), UDim2.new(0, 110, 0, 230))
        collRemoveBtn.BackgroundColor3 = Color3.fromRGB(200, 100, 100)
        collRemoveBtn.TextSize = 9
        collRemoveBtn.MouseButton1Click:Connect(function()
            removeAllCollisionConstraints()
        end)
        
        local applyBtn = createButton(panel, "Apply", UDim2.new(0, 80, 0, 30), UDim2.new(0, 10, 1, -40))
        applyBtn.MouseButton1Click:Connect(function() 
            local showSpring = springVisBtn:GetAttribute("ToggleState")
            applyConstraint(dropdown.Text, showSpring, chainModeValue)
        end)
        
        local removeBtn = createButton(panel, "Remove All", UDim2.new(0, 90, 0, 30), UDim2.new(1, -100, 1, -40))
        removeBtn.BackgroundColor3 = Color3.fromRGB(150, 50, 50)
        removeBtn.MouseButton1Click:Connect(function()
            for _, part in ipairs(selectedParts) do
                for _, child in pairs(part:GetChildren()) do
                    if child:IsA("Constraint") or child:IsA("Attachment") then
                        child:Destroy()
                    end
                end
                print("Removed all constraints from " .. part.Name)
            end
        end)
    end

    local function createVelocityPanel(parent)
        local panel = createPanel(parent, "ðŸš€ Linear Velocity", 2)
        panel.Size = UDim2.new(0, 280, 0, 240)
        
        local methodDropdown = createDropdown(panel, {"BodyVelocity", "AssemblyLinearVelocity", "VectorForce"})
        methodDropdown.Position = UDim2.new(0, 10, 0, 40)
        methodDropdown.Size = UDim2.new(0, 130, 0, 25)
        
        local modeDropdown = createDropdown(panel, {"Always On", "Keybind Move"})
        modeDropdown.Position = UDim2.new(0, 150, 0, 40)
        modeDropdown.Size = UDim2.new(0, 100, 0, 25)
        
        -- NEW: Velocity to Axis dropdown with Thruster mode
        local velAxisLabel = Instance.new("TextLabel")
        velAxisLabel.Size = UDim2.new(0, 80, 0, 20)
        velAxisLabel.Position = UDim2.new(0, 10, 0, 70)
        velAxisLabel.BackgroundTransparency = 1
        velAxisLabel.Text = "Velocity to Axis:"
        velAxisLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
        velAxisLabel.TextSize = 9
        velAxisLabel.Font = Enum.Font.GothamBold
        velAxisLabel.TextXAlignment = Enum.TextXAlignment.Left
        velAxisLabel.Parent = panel
        
        local velAxisDropdown = createDropdown(panel, {"Off", "Velocity to Axis", "Updating Velocity to Axis", "Thruster"})
        velAxisDropdown.Position = UDim2.new(0, 95, 0, 70)
        velAxisDropdown.Size = UDim2.new(0, 155, 0, 25)
        
        local xInput = createNumberInput(panel, "X", UDim2.new(0, 10, 0, 105))
        local yInput = createNumberInput(panel, "Y", UDim2.new(0, 95, 0, 105))
        local zInput = createNumberInput(panel, "Z", UDim2.new(0, 180, 0, 105))
        
        -- Thruster Force input (hidden by default)
        local thrusterForceInput = createNumberInput(panel, "Force", UDim2.new(0, 10, 0, 105))
        thrusterForceInput.Size = UDim2.new(0, 240, 0, 25)
        thrusterForceInput.Text = "50"
        thrusterForceInput.PlaceholderText = "Forward Force"
        thrusterForceInput.Visible = false
        
        -- Show/hide inputs based on mode
        velAxisDropdown.MouseButton1Click:Connect(function()
            task.wait(0.1)
            local mode = velAxisDropdown.Text:gsub(" â–¼", "")
            if mode == "Thruster" then
                xInput.Visible = false
                yInput.Visible = false
                zInput.Visible = false
                thrusterForceInput.Visible = true
            else
                xInput.Visible = true
                yInput.Visible = true
                zInput.Visible = true
                thrusterForceInput.Visible = false
            end
        end)
        
        -- Keybind controls
        local keybindInput = createNumberInput(panel, "Keys (use +)", UDim2.new(0, 10, 0, 105))
        keybindInput.Size = UDim2.new(0, 100, 0, 25)
        keybindInput.Text = "W"
        keybindInput.PlaceholderText = "W+LeftShift"
        
        local triggerDropdown = createDropdown(panel, {"Hold", "Toggle", "OnPress", "OnRelease"})
        triggerDropdown.Position = UDim2.new(0, 120, 0, 105)
        triggerDropdown.Size = UDim2.new(0, 80, 0, 25)
        
        local addKeybindBtn = createButton(panel, "Add Keybind", UDim2.new(0, 90, 0, 25), UDim2.new(0, 210, 0, 105))
        addKeybindBtn.BackgroundColor3 = Color3.fromRGB(100, 150, 200)
        
        local applyBtn = createButton(panel, "Apply Velocity", UDim2.new(0.5, -5, 0, 30), UDim2.new(0, 10, 1, -40))
        applyBtn.MouseButton1Click:Connect(function()
            local method = methodDropdown.Text:gsub(" â–¼", "")
            local mode = modeDropdown.Text:gsub(" â–¼", "")
            local velAxisMode = velAxisDropdown.Text:gsub(" â–¼", "")
            
            if velAxisMode == "Thruster" then
                local force = tonumber(thrusterForceInput.Text) or 50
                applyVelocity(Vector3.new(0, 0, force), method, mode, nil, velAxisMode)
            else
                local x = tonumber(xInput.Text) or 0
                local y = tonumber(yInput.Text) or 0
                local z = tonumber(zInput.Text) or 0
                applyVelocity(Vector3.new(x, y, z), method, mode, nil, velAxisMode)
            end
        end)
        
        addKeybindBtn.MouseButton1Click:Connect(function()
            local x = tonumber(xInput.Text) or 0
            local y = tonumber(yInput.Text) or 0
            local z = tonumber(zInput.Text) or 0
            local method = methodDropdown.Text:gsub(" â–¼", "")
            local keysStr = keybindInput.Text
            local triggerType = triggerDropdown.Text:gsub(" â–¼", "")
            
            local keys = {}
            for key in keysStr:gmatch("[^+]+") do
                table.insert(keys, key:match("^%s*(.-)%s*$"))
            end
            
            local velocity = Vector3.new(x, y, z)
            local keybindData = {
                id = nextKeybindId,
                type = "LinVel",
                parts = {unpack(selectedParts)},
                velocity = velocity,
                method = method,
                keys = keys,
                triggerType = triggerType,
                enabled = true,
                isActive = false
            }
            
            -- Create keybind connection
            local keysPressed = {}
            local toggleState = false
            
            local connection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
                if gameProcessed or not keybindData.enabled then return end
                
                for _, key in ipairs(keys) do
                    local keyEnum = Enum.KeyCode[key] or Enum.UserInputType[key]
                    if input.KeyCode == keyEnum or input.UserInputType == keyEnum then
                        keysPressed[key] = true
                        
                        local allPressed = true
                        for _, k in ipairs(keys) do
                            if not keysPressed[k] then allPressed = false break end
                        end
                        
                        if allPressed then
                            if triggerType == "Toggle" then
                                toggleState = not toggleState
                                keybindData.isActive = toggleState
                            elseif triggerType == "OnPress" then
                                keybindData.isActive = true
                            elseif triggerType == "Hold" then
                                keybindData.isActive = true
                            end
                        end
                    end
                end
            end)
            
            local releaseConnection = UserInputService.InputEnded:Connect(function(input)
                for _, key in ipairs(keys) do
                    local keyEnum = Enum.KeyCode[key] or Enum.UserInputType[key]
                    if input.KeyCode == keyEnum or input.UserInputType == keyEnum then
                        keysPressed[key] = false
                        
                        if triggerType == "Hold" then
                            keybindData.isActive = false
                        elseif triggerType == "OnRelease" then
                            local wasAllPressed = true
                            for _, k in ipairs(keys) do
                                if not keysPressed[k] then wasAllPressed = false break end
                            end
                            if wasAllPressed then keybindData.isActive = true end
                        end
                    end
                end
            end)
            
            local updateConnection = RunService.Heartbeat:Connect(function()
                if not keybindData.enabled then return end
                
                for _, part in ipairs(keybindData.parts) do
                    if part.Parent and keybindData.isActive then
                        applyVelocity({part}, keybindData.velocity, keybindData.method, "Always On", nil)
                    end
                end
                
                if triggerType == "OnPress" or triggerType == "OnRelease" then
                    keybindData.isActive = false
                end
            end)
            
            keybindData.connection = connection
            keybindData.releaseConnection = releaseConnection
            keybindData.updateConnection = updateConnection
            activeKeybinds[nextKeybindId] = keybindData
            nextKeybindId = nextKeybindId + 1
            
            print("âœ… Added LinVel keybind #" .. keybindData.id .. " | Keys: " .. table.concat(keys, "+"))
        end)
    end

    local function createAngularVelocityPanel(parent)
        local panel = createPanel(parent, "ðŸŒªï¸ Angular Velocity", 3)
        panel.Size = UDim2.new(0, 280, 0, 270)
        
        local methodDropdown = createDropdown(panel, {"BodyAngularVelocity", "BodyGyro", "AssemblyAngularVelocity", "Torque"})
        methodDropdown.Position = UDim2.new(0, 10, 0, 40)
        methodDropdown.Size = UDim2.new(0, 120, 0, 25)
        
        local modeDropdown = createDropdown(panel, {"Spinnable Movable", "Restricted Unmovable", "Restricted Movable", "Spinnable Unmovable", "Keybind Spin"})
        modeDropdown.Position = UDim2.new(0, 140, 0, 40)
        modeDropdown.Size = UDim2.new(0, 130, 0, 25)
        
        -- NEW: Spin to Axis dropdown
        local spinAxisLabel = Instance.new("TextLabel")
        spinAxisLabel.Size = UDim2.new(0, 80, 0, 20)
        spinAxisLabel.Position = UDim2.new(0, 10, 0, 70)
        spinAxisLabel.BackgroundTransparency = 1
        spinAxisLabel.Text = "Spin to Axis:"
        spinAxisLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
        spinAxisLabel.TextSize = 9
        spinAxisLabel.Font = Enum.Font.GothamBold
        spinAxisLabel.TextXAlignment = Enum.TextXAlignment.Left
        spinAxisLabel.Parent = panel
        
        local spinAxisDropdown = createDropdown(panel, {"Off", "Spin to Axis", "Updating Spin to Axis"})
        spinAxisDropdown.Position = UDim2.new(0, 90, 0, 70)
        spinAxisDropdown.Size = UDim2.new(0, 130, 0, 25)
        
        local infoLabel = Instance.new("TextLabel")
        infoLabel.Size = UDim2.new(1, -20, 0, 15)
        infoLabel.Position = UDim2.new(0, 10, 0, 100)
        infoLabel.BackgroundTransparency = 1
        infoLabel.Text = "XYZ: Spin direction & speed"
        infoLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
        infoLabel.TextSize = 9
        infoLabel.Font = Enum.Font.Gotham
        infoLabel.TextWrapped = true
        infoLabel.TextXAlignment = Enum.TextXAlignment.Left
        infoLabel.Parent = panel
        
        local xInput = createNumberInput(panel, "X", UDim2.new(0, 10, 0, 120))
        xInput.Size = UDim2.new(0, 70, 0, 25)
        local yInput = createNumberInput(panel, "Y", UDim2.new(0, 90, 0, 120))
        yInput.Size = UDim2.new(0, 70, 0, 25)
        local zInput = createNumberInput(panel, "Z", UDim2.new(0, 170, 0, 120))
        zInput.Size = UDim2.new(0, 70, 0, 25)
        
        -- Keybind controls
        local keybindLabel = Instance.new("TextLabel")
        keybindLabel.Size = UDim2.new(1, -20, 0, 15)
        keybindLabel.Position = UDim2.new(0, 10, 0, 150)
        keybindLabel.BackgroundTransparency = 1
        keybindLabel.Text = "Keybind (for Keybind Spin mode):"
        keybindLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
        keybindLabel.TextSize = 9
        keybindLabel.Font = Enum.Font.GothamBold
        keybindLabel.TextWrapped = true
        keybindLabel.TextXAlignment = Enum.TextXAlignment.Left
        keybindLabel.Parent = panel
        
        local keybindInput = Instance.new("TextBox")
        keybindInput.Size = UDim2.new(0, 150, 0, 25)
        keybindInput.Position = UDim2.new(0, 10, 0, 170)
        keybindInput.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
        keybindInput.BorderSizePixel = 0
        keybindInput.PlaceholderText = "E, LeftControl, etc"
        keybindInput.Text = "E"
        keybindInput.TextColor3 = Color3.fromRGB(255, 255, 255)
        keybindInput.TextSize = 12
        keybindInput.Font = Enum.Font.Gotham
        keybindInput.Parent = panel
        
        local keybindCorner = Instance.new("UICorner")
        keybindCorner.CornerRadius = UDim.new(0, 4)
        keybindCorner.Parent = keybindInput
        
        local addKeybindBtn = createButton(panel, "Add Keybind", UDim2.new(0, 100, 0, 25), UDim2.new(0, 170, 0, 170))
        addKeybindBtn.BackgroundColor3 = Color3.fromRGB(100, 150, 200)
        addKeybindBtn.TextSize = 11
        
        local applyBtn = createButton(panel, "Apply Angular", UDim2.new(1, -20, 0, 30), UDim2.new(0, 10, 1, -40))
        applyBtn.MouseButton1Click:Connect(function()
            local x = tonumber(xInput.Text) or 0
            local y = tonumber(yInput.Text) or 0
            local z = tonumber(zInput.Text) or 0
            local method = methodDropdown.Text:gsub(" â–¼", "")
            local mode = modeDropdown.Text:gsub(" â–¼", "")
            local keybind = keybindInput.Text
            local spinAxis = spinAxisDropdown.Text:gsub(" â–¼", "")
            applyAngularVelocity(Vector3.new(x, y, z), mode, method, keybind, spinAxis)
        end)
        
        addKeybindBtn.MouseButton1Click:Connect(function()
            local x = tonumber(xInput.Text) or 0
            local y = tonumber(yInput.Text) or 0
            local z = tonumber(zInput.Text) or 0
            local method = methodDropdown.Text:gsub(" â–¼", "")
            local keybind = keybindInput.Text
            applyAngularVelocity(Vector3.new(x, y, z), "Keybind Spin", method, keybind)
        end)
    end

    local function createZeroGravityPanel(parent)
        local panel = createPanel(parent, "ðŸŒŒ Zero Gravity", 4)
        local infoLabel = Instance.new("TextLabel")
        infoLabel.Size = UDim2.new(1, -20, 0, 50)
        infoLabel.Position = UDim2.new(0, 10, 0, 40)
        infoLabel.BackgroundTransparency = 1
        infoLabel.Text = "Cancels gravity force only.\nPart floats freely.\nClick again to remove."
        infoLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
        infoLabel.TextSize = 12
        infoLabel.TextWrapped = true
        infoLabel.Font = Enum.Font.Gotham
        infoLabel.Parent = panel
        local applyBtn = createButton(panel, "Toggle Zero-G", UDim2.new(0.5, -5, 0, 30), UDim2.new(0, 10, 1, -40))
        applyBtn.MouseButton1Click:Connect(function() toggleZeroGravity() end)
    end

    local function createWeightPanel(parent)
        local panel = createPanel(parent, "âš–ï¸ Physics Editor", 5)
        local dInput = createNumberInput(panel, "Density", UDim2.new(0, 10, 0, 40))
        dInput.Size = UDim2.new(0, 60, 0, 25)
        local fInput = createNumberInput(panel, "Friction", UDim2.new(0, 80, 0, 40))
        fInput.Size = UDim2.new(0, 60, 0, 25)
        fInput.Text = "inf"
        local eInput = createNumberInput(panel, "Elastic", UDim2.new(0, 150, 0, 40))
        eInput.Size = UDim2.new(0, 60, 0, 25)
        local applyBtn = createButton(panel, "Apply Physics", UDim2.new(0.5, -5, 0, 25), UDim2.new(0, 10, 0, 75))
        applyBtn.MouseButton1Click:Connect(function()
            local d = tonumber(dInput.Text) or 0
            local f = fInput.Text == "inf" and math.huge or (tonumber(fInput.Text) or 0)
            local e = tonumber(eInput.Text) or 0
            applyPhysicsProperties(d, f, e)
        end)
        local wInput = createNumberInput(panel, "Mass", UDim2.new(0, 10, 0, 110))
        wInput.Size = UDim2.new(0, 80, 0, 25)
        local wBtn = createButton(panel, "Weight", UDim2.new(0, 60, 0, 25), UDim2.new(0, 100, 0, 110))
        wBtn.MouseButton1Click:Connect(function() applyWeight(tonumber(wInput.Text) or 0) end)
    end

    local function createGyroBalancerPanel(parent)
        local panel = createPanel(parent, "âš–ï¸ Gyro Balancer", 6)
        local orientationDropdown = createDropdown(panel, {"Upright", "Level", "Original", "VelocityAligned"})
        orientationDropdown.Position = UDim2.new(0, 10, 0, 40)
        orientationDropdown.Size = UDim2.new(0, 80, 0, 25)
        local typeDropdown = createDropdown(panel, {"BodyPosition", "AlignOrientation", "BodyGyro"})
        typeDropdown.Position = UDim2.new(0, 100, 0, 40)
        typeDropdown.Size = UDim2.new(0, 90, 0, 25)
        local powerInput = createNumberInput(panel, "Power", UDim2.new(0, 200, 0, 40))
        powerInput.Text = "50"
        powerInput.Size = UDim2.new(0, 50, 0, 25)
        local applyBtn = createButton(panel, "Apply Gyro", UDim2.new(0, 90, 0, 25), UDim2.new(0, 10, 0, 75))
        applyBtn.MouseButton1Click:Connect(function()
            local orientation = orientationDropdown.Text:gsub(" â–¼", "")
            local gyroType = typeDropdown.Text:gsub(" â–¼", "")
            local power = math.clamp(tonumber(powerInput.Text) or 50, 0, 100)
            applyGyroBalancer(orientation, power, gyroType)
        end)
        local removeBtn = createButton(panel, "Remove Gyro", UDim2.new(0, 90, 0, 25), UDim2.new(0, 110, 0, 75))
        removeBtn.BackgroundColor3 = Color3.fromRGB(150, 50, 50)
        removeBtn.MouseButton1Click:Connect(function()
            for _, part in ipairs(selectedParts) do
                if gyroStabilizers[part] then
                    if gyroStabilizers[part].connection then gyroStabilizers[part].connection:Disconnect() end
                    if gyroStabilizers[part].bodyPosition then gyroStabilizers[part].bodyPosition:Destroy() end
                    if gyroStabilizers[part].bodyAngularVelocity then gyroStabilizers[part].bodyAngularVelocity:Destroy() end
                    if gyroStabilizers[part].attachment then gyroStabilizers[part].attachment:Destroy() end
                    if gyroStabilizers[part].alignOrientation then gyroStabilizers[part].alignOrientation:Destroy() end
                    if gyroStabilizers[part].bodyGyro then gyroStabilizers[part].bodyGyro:Destroy() end
                    gyroStabilizers[part] = nil
                    print("Removed gyro balancer from " .. part.Name)
                end
            end
        end)
    end

    local function createFrozenFlingerPanel(parent)
        local panel = createPanel(parent, "â„ï¸ Frozen Flinger", 7)
        local powerInput = createNumberInput(panel, "Power", UDim2.new(0, 10, 0, 40))
        powerInput.Text = "100"
        powerInput.Size = UDim2.new(0, 80, 0, 30)
        local applyBtn = createButton(panel, "Apply", UDim2.new(0, 60, 0, 30), UDim2.new(0, 100, 0, 40))
        applyBtn.MouseButton1Click:Connect(function() applyFrozenFlinger(math.max(1, tonumber(powerInput.Text) or 100)) end)
        local disableBtn = createButton(panel, "Disable", UDim2.new(0, 60, 0, 30), UDim2.new(0, 170, 0, 40))
        disableBtn.BackgroundColor3 = Color3.fromRGB(150, 50, 50)
        disableBtn.MouseButton1Click:Connect(function() removeFrozenFlinger() end)
    end

    local function createPositionLockPanel(parent)
        local panel = createPanel(parent, "ðŸ”’ Position Lock", 8)
        local applyBtn = createButton(panel, "Lock Position", UDim2.new(0.5, -5, 0, 30), UDim2.new(0, 10, 0, 50))
        applyBtn.MouseButton1Click:Connect(function() applyPositionLock() end)
        local removeBtn = createButton(panel, "Unlock", UDim2.new(0.5, -5, 0, 30), UDim2.new(0.5, 5, 0, 50))
        removeBtn.BackgroundColor3 = Color3.fromRGB(150, 50, 50)
        removeBtn.MouseButton1Click:Connect(function() removePositionLock() end)
    end

    local function createUnAnchoredTPPanel(parent)
        local panel = createPanel(parent, "ðŸŽ¯ UnAnchored TP", 9)
        local statusLabel = Instance.new("TextLabel")
        statusLabel.Name = "StatusLabel"
        statusLabel.Size = UDim2.new(1, -20, 0, 50)
        statusLabel.Position = UDim2.new(0, 10, 0, 40)
        statusLabel.BackgroundTransparency = 1
        statusLabel.Text = "Select a part from Selection panel.\nThen enable Lock & TP here!"
        statusLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
        statusLabel.TextSize = 11
        statusLabel.TextWrapped = true
        statusLabel.Font = Enum.Font.Gotham
        statusLabel.Parent = panel
        local lockBtn, updateLockColor = createToggleButton(panel, "Lock On", UDim2.new(0, 80, 0, 25), UDim2.new(0, 10, 0, 100), false)
        lockBtn.MouseButton1Click:Connect(function()
            if #selectedParts > 0 and not selectedParts[#selectedParts].Anchored then
                tpLockEnabled = not tpLockEnabled
                lockBtn:SetAttribute("ToggleState", tpLockEnabled)
                updateLockColor(tpLockEnabled)
                
                -- Set the last selected part as TP target
                if tpLockEnabled then
                    onTpPartClicked(selectedParts[#selectedParts])
                end
                
                updateTpSelectionStatus()
            else
                warn("Select an unanchored part first!")
            end
        end)
        local tpBtn, updateTpColor = createToggleButton(panel, "TP AT CURSOR", UDim2.new(0, 100, 0, 25), UDim2.new(0, 100, 0, 100), false)
        tpBtn.MouseButton1Click:Connect(function()
            if tpLockedPart then
                tpAtCursorEnabled = not tpAtCursorEnabled
                tpBtn:SetAttribute("ToggleState", tpAtCursorEnabled)
                updateTpColor(tpAtCursorEnabled)
                updateTpSelectionStatus()
            else
                warn("Lock a part first!")
            end
        end)
        local clearBtn = createButton(panel, "Clear", UDim2.new(0, 60, 0, 25), UDim2.new(0, 210, 0, 100))
        clearBtn.MouseButton1Click:Connect(function()
            clearTpSelection()
            updateLockColor(false)
            updateTpColor(false)
        end)
    end

    local function createSelectionPanel(parent)
        local panel = createPanel(parent, "ðŸŽ¯ Selection", 10)
        
        local statusLabel = Instance.new("TextLabel")
        statusLabel.Name = "StatusLabel"
        statusLabel.Size = UDim2.new(1, -20, 0, 40)
        statusLabel.Position = UDim2.new(0, 10, 0, 40)
        statusLabel.BackgroundTransparency = 1
        statusLabel.Text = "Click parts to select them"
        statusLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
        statusLabel.TextSize = 12
        statusLabel.TextWrapped = true
        statusLabel.Font = Enum.Font.Gotham
        statusLabel.Parent = panel
        
        -- Max selection input
        local maxLabel = Instance.new("TextLabel")
        maxLabel.Size = UDim2.new(0, 100, 0, 25)
        maxLabel.Position = UDim2.new(0, 10, 0, 85)
        maxLabel.BackgroundTransparency = 1
        maxLabel.Text = "Max Selection:"
        maxLabel.TextColor3 = Color3.fromRGB(255, 200, 100)
        maxLabel.TextSize = 10
        maxLabel.Font = Enum.Font.GothamBold
        maxLabel.TextXAlignment = Enum.TextXAlignment.Left
        maxLabel.Parent = panel
        
        local maxInput = createNumberInput(panel, "1-inf", UDim2.new(0, 120, 0, 85))
        maxInput.Size = UDim2.new(0, 60, 0, 25)
        maxInput.Text = "2"
        
        local setMaxBtn = createButton(panel, "Set", UDim2.new(0, 40, 0, 25), UDim2.new(0, 190, 0, 85))
        setMaxBtn.MouseButton1Click:Connect(function()
            local newMax = math.max(1, tonumber(maxInput.Text) or 2)
            maxSelectedParts = newMax
            print("Max selection set to: " .. newMax)
            
            -- Trim current selection if it exceeds new max
            while #selectedParts > maxSelectedParts do
                local oldestPart = selectedParts[1]
                if selectionBoxes[oldestPart] then 
                    selectionBoxes[oldestPart]:Destroy() 
                    selectionBoxes[oldestPart] = nil 
                end
                table.remove(selectedParts, 1)
            end
            updateSelectionStatus()
        end)
        
        local studBtn, updateStudBtn = createToggleButton(panel, "Stud Mode", UDim2.new(0, 80, 0, 25), UDim2.new(0, 10, 0, 120), false)
        studBtn.MouseButton1Click:Connect(function()
            studSelectMode = not studSelectMode
            studBtn:SetAttribute("ToggleState", studSelectMode)
            updateStudBtn(studSelectMode)
            print("Stud selection: " .. (studSelectMode and "ON" or "OFF"))
        end)
        
        -- Select Character button
        local selectCharBtn = createButton(panel, "Select Character", UDim2.new(0, 110, 0, 25), UDim2.new(0, 100, 0, 120))
        selectCharBtn.BackgroundColor3 = Color3.fromRGB(100, 150, 200)
        selectCharBtn.MouseButton1Click:Connect(function()
            if player.Character then
                -- Clear current selection first
                clearSelection()
                
                -- Select all character parts
                for _, part in ipairs(player.Character:GetDescendants()) do
                    if part:IsA("BasePart") then
                        -- Check if we're at max
                        if #selectedParts >= maxSelectedParts then
                            break
                        end
                        
                        table.insert(selectedParts, part)
                        
                        local selectionBox = Instance.new("SelectionBox")
                        selectionBox.Adornee = part
                        selectionBox.Color3 = Color3.fromRGB(255, 150, 0)
                        selectionBox.LineThickness = 0.2
                        selectionBox.Transparency = 0.3
                        selectionBox.Parent = part
                        selectionBoxes[part] = selectionBox
                        
                        setNetworkOwnership(part)
                    end
                end
                
                updateSelectionStatus()
                print("Selected " .. #selectedParts .. " character parts")
            else
                warn("Character not found!")
            end
        end)
        
        local clearBtn = createButton(panel, "Clear Selection", UDim2.new(0.5, -5, 0, 30), UDim2.new(0, 10, 1, -40))
        clearBtn.MouseButton1Click:Connect(function() clearSelection() end)
    end

    local function createShowForcesPanel(parent)
        local panel = createPanel(parent, "ðŸ‘ï¸ Show Forces", 11)
        local btn = createButton(panel, "Toggle Force Viz", UDim2.new(0.5, -5, 0, 30), UDim2.new(0, 10, 0, 50))
        btn.MouseButton1Click:Connect(function() toggleShowForces() end)
    end

    local function createFreezeMotionPanel(parent)
        local panel = createPanel(parent, "â¸ï¸ Freeze Motion", 12)
        local btn = createButton(panel, "Toggle Freeze", UDim2.new(0.5, -5, 0, 30), UDim2.new(0, 10, 0, 50))
        btn.MouseButton1Click:Connect(function() toggleFreezeMotion() end)
    end

    local function createTimeScalePanel(parent)
        local panel = createPanel(parent, "â±ï¸ Time Scale", 13)
        local input = createNumberInput(panel, "Scale", UDim2.new(0, 10, 0, 40))
        input.Text = "1"
        input.Size = UDim2.new(0, 80, 0, 25)
        local btn = createButton(panel, "Apply", UDim2.new(0, 60, 0, 25), UDim2.new(0, 100, 0, 40))
        btn.MouseButton1Click:Connect(function() applyTimeScale(tonumber(input.Text) or 1) end)
    end

    local function createPhysicsRecorderPanel(parent)
        local panel = createPanel(parent, "ðŸŽ¬ Recorder", 14)
        local input = createNumberInput(panel, "Name", UDim2.new(0, 10, 0, 40))
        input.Size = UDim2.new(0, 100, 0, 25)
        input.Text = "rec1"
        local recBtn = createButton(panel, "Record", UDim2.new(0, 50, 0, 25), UDim2.new(0, 120, 0, 40))
        recBtn.MouseButton1Click:Connect(function() startRecording(input.Text) end)
        local stopBtn = createButton(panel, "Stop", UDim2.new(0, 50, 0, 25), UDim2.new(0, 180, 0, 40))
        stopBtn.MouseButton1Click:Connect(function() stopRecording(input.Text) end)
        local playBtn = createButton(panel, "Play", UDim2.new(0, 50, 0, 25), UDim2.new(0, 10, 0, 75))
        playBtn.MouseButton1Click:Connect(function() playbackRecording(input.Text) end)
    end

    local function createGravityGunPanel(parent)
        local panel = createPanel(parent, "ðŸ”« Gravity Gun", 15)
        local btn, updateColor = createToggleButton(panel, "Toggle Gravity Gun", UDim2.new(0.5, -5, 0, 30), UDim2.new(0, 10, 0, 50), gravityGunActive)
        btn.MouseButton1Click:Connect(function()
            toggleGravityGun()
            btn:SetAttribute("ToggleState", gravityGunActive)
            updateColor(gravityGunActive)
        end)
    end

    local function createPhysicsPaintPanel(parent)
        local panel = createPanel(parent, "ðŸŽ¨ Physics Paint", 16)
        local dropdown = createDropdown(panel, {"Slippery", "Bouncy", "Magnetic", "Gooey", "Buoyancy"})
        dropdown.Position = UDim2.new(0, 10, 0, 40)
        dropdown.Size = UDim2.new(0, 120, 0, 25)
        local btn = createButton(panel, "Apply Paint", UDim2.new(0, 80, 0, 25), UDim2.new(0, 140, 0, 40))
        btn.MouseButton1Click:Connect(function() applyPhysicsPaint(dropdown.Text:gsub(" â–¼", "")) end)
    end

    local function createKineticAmplifierPanel(parent)
        local panel = createPanel(parent, "âš¡ Kinetic Amplifier", 17)
        local applyBtn = createButton(panel, "Apply Amplifier", UDim2.new(0.5, -5, 0, 25), UDim2.new(0, 10, 0, 50))
        applyBtn.MouseButton1Click:Connect(function() applyKineticAmplifier() end)
        local releaseBtn = createButton(panel, "Release Energy", UDim2.new(0.5, -5, 0, 25), UDim2.new(0.5, 5, 0, 50))
        releaseBtn.BackgroundColor3 = Color3.fromRGB(255, 100, 50)
        releaseBtn.MouseButton1Click:Connect(function() releaseKineticAmplifier() end)
    end

    local function createBlackHolePanel(parent)
        local panel = createPanel(parent, "ðŸŒ‘ Black Hole", 18)
        local input = createNumberInput(panel, "Strength", UDim2.new(0, 10, 0, 40))
        input.Text = "1000"
        input.Size = UDim2.new(0, 80, 0, 25)
        local applyBtn = createButton(panel, "Apply", UDim2.new(0, 60, 0, 25), UDim2.new(0, 100, 0, 40))
        applyBtn.MouseButton1Click:Connect(function() applyBlackHole(tonumber(input.Text) or 1000) end)
        local removeBtn = createButton(panel, "Remove", UDim2.new(0, 60, 0, 25), UDim2.new(0, 170, 0, 40))
        removeBtn.BackgroundColor3 = Color3.fromRGB(150, 50, 50)
        removeBtn.MouseButton1Click:Connect(function() removeBlackHole() end)
    end

    local function createBuoyancyPanel(parent)
        local panel = createPanel(parent, "ðŸŒŠ Buoyancy Paint", 19)
        local modeDropdown = createDropdown(panel, {"Normal", "Hydrophobic"})
        modeDropdown.Position = UDim2.new(0, 10, 0, 40)
        modeDropdown.Size = UDim2.new(0, 100, 0, 25)
        local dragInput = createNumberInput(panel, "Drag", UDim2.new(0, 120, 0, 40))
        dragInput.Text = "0.5"
        dragInput.Size = UDim2.new(0, 60, 0, 25)
        local applyBtn = createButton(panel, "Apply", UDim2.new(0, 60, 0, 25), UDim2.new(0, 10, 0, 75))
        applyBtn.MouseButton1Click:Connect(function() 
            local mode = modeDropdown.Text:gsub(" â–¼", "")
            local drag = tonumber(dragInput.Text) or 0.5
            applyBuoyancyPaint(mode, drag) 
        end)
        local removeBtn = createButton(panel, "Remove", UDim2.new(0, 60, 0, 25), UDim2.new(0, 80, 0, 75))
        removeBtn.BackgroundColor3 = Color3.fromRGB(150, 50, 50)
        removeBtn.MouseButton1Click:Connect(function() removeBuoyancyPaint() end)
    end

    local function createMomentumAbsorberPanel(parent)
        local panel = createPanel(parent, "âš¡ Momentum Absorber", 20)
        local modeDropdown = createDropdown(panel, {"Burst", "Pulse", "Redirect"})
        modeDropdown.Position = UDim2.new(0, 10, 0, 40)
        modeDropdown.Size = UDim2.new(0, 100, 0, 25)
        local applyBtn = createButton(panel, "Apply", UDim2.new(0, 60, 0, 25), UDim2.new(0, 120, 0, 40))
        applyBtn.MouseButton1Click:Connect(function() 
            local mode = modeDropdown.Text:gsub(" â–¼", "")
            applyMomentumAbsorber(mode) 
        end)
        local releaseBtn = createButton(panel, "Release", UDim2.new(0, 70, 0, 25), UDim2.new(0, 10, 0, 75))
        releaseBtn.BackgroundColor3 = Color3.fromRGB(255, 150, 50)
        releaseBtn.MouseButton1Click:Connect(function() releaseMomentumAbsorber() end)
        local removeBtn = createButton(panel, "Remove", UDim2.new(0, 70, 0, 25), UDim2.new(0, 90, 0, 75))
        removeBtn.BackgroundColor3 = Color3.fromRGB(150, 50, 50)
        removeBtn.MouseButton1Click:Connect(function() removeMomentumAbsorber() end)
    end

    local function createForceReflectionPanel(parent)
        local panel = createPanel(parent, "ðŸ”® Force Reflection", 21)
        local coefInput = createNumberInput(panel, "Coef", UDim2.new(0, 10, 0, 40))
        coefInput.Text = "1.0"
        coefInput.Size = UDim2.new(0, 50, 0, 25)
        local rotBtn, updateRot = createToggleButton(panel, "Rot", UDim2.new(0, 40, 0, 25), UDim2.new(0, 70, 0, 40), false)
        local mirrorBtn, updateMirror = createToggleButton(panel, "Mirror", UDim2.new(0, 60, 0, 25), UDim2.new(0, 120, 0, 40), false)
        local applyBtn = createButton(panel, "Apply", UDim2.new(0, 60, 0, 25), UDim2.new(0, 10, 0, 75))
        applyBtn.MouseButton1Click:Connect(function() 
            local coef = tonumber(coefInput.Text) or 1.0
            local rot = rotBtn:GetAttribute("ToggleState")
            local mirror = mirrorBtn:GetAttribute("ToggleState")
            applyForceReflection(coef, rot, mirror) 
        end)
        rotBtn.MouseButton1Click:Connect(function()
            local state = not rotBtn:GetAttribute("ToggleState")
            rotBtn:SetAttribute("ToggleState", state)
            updateRot(state)
        end)
        mirrorBtn.MouseButton1Click:Connect(function()
            local state = not mirrorBtn:GetAttribute("ToggleState")
            mirrorBtn:SetAttribute("ToggleState", state)
            updateMirror(state)
        end)
        local removeBtn = createButton(panel, "Remove", UDim2.new(0, 60, 0, 25), UDim2.new(0, 80, 0, 75))
        removeBtn.BackgroundColor3 = Color3.fromRGB(150, 50, 50)
        removeBtn.MouseButton1Click:Connect(function() removeForceReflection() end)
    end

    local function createShockwaveGeneratorPanel(parent)
        local panel = createPanel(parent, "ðŸ’¥ Shockwave Generator", 23)
        
        -- MODE 1: Apply to Parts
        local mode1Label = Instance.new("TextLabel")
        mode1Label.Size = UDim2.new(1, -20, 0, 20)
        mode1Label.Position = UDim2.new(0, 10, 0, 40)
        mode1Label.BackgroundTransparency = 1
        mode1Label.Text = "MODE 1: Apply to Selected Parts"
        mode1Label.TextColor3 = Color3.fromRGB(255, 200, 100)
        mode1Label.TextSize = 11
        mode1Label.Font = Enum.Font.GothamBold
        mode1Label.TextXAlignment = Enum.TextXAlignment.Left
        mode1Label.Parent = panel
        
        local m1FreqInput = createNumberInput(panel, "Freq(Hz)", UDim2.new(0, 10, 0, 65))
        m1FreqInput.Text = "1"
        m1FreqInput.Size = UDim2.new(0, 50, 0, 25)
        
        local m1StrengthInput = createNumberInput(panel, "Str", UDim2.new(0, 70, 0, 65))
        m1StrengthInput.Text = "100"
        m1StrengthInput.Size = UDim2.new(0, 50, 0, 25)
        
        local m1RadiusInput = createNumberInput(panel, "Rad", UDim2.new(0, 130, 0, 65))
        m1RadiusInput.Text = "50"
        m1RadiusInput.Size = UDim2.new(0, 50, 0, 25)
        
        local m1ApplyBtn = createButton(panel, "Apply M1", UDim2.new(0, 70, 0, 25), UDim2.new(0, 190, 0, 65))
        m1ApplyBtn.MouseButton1Click:Connect(function()
            local freq = tonumber(m1FreqInput.Text) or 1
            local str = tonumber(m1StrengthInput.Text) or 100
            local rad = tonumber(m1RadiusInput.Text) or 50
            applyShockwaveGenerator("Mode1Apply", freq, str, rad)
        end)
        
        local m1RemoveBtn = createButton(panel, "Remove", UDim2.new(0, 50, 0, 25), UDim2.new(0, 10, 0, 95))
        m1RemoveBtn.BackgroundColor3 = Color3.fromRGB(150, 50, 50)
        m1RemoveBtn.MouseButton1Click:Connect(function() removeShockwaveGenerator() end)
        
        -- MODE 2: At Mouse Position
        local mode2Label = Instance.new("TextLabel")
        mode2Label.Size = UDim2.new(1, -20, 0, 20)
        mode2Label.Position = UDim2.new(0, 10, 1, -65)
        mode2Label.BackgroundTransparency = 1
        mode2Label.Text = "MODE 2: At Mouse Position"
        mode2Label.TextColor3 = Color3.fromRGB(100, 200, 255)
        mode2Label.TextSize = 11
        mode2Label.Font = Enum.Font.GothamBold
        mode2Label.TextXAlignment = Enum.TextXAlignment.Left
        mode2Label.Parent = panel
        
        local m2SubmodeDropdown = createDropdown(panel, {"2A: Constant", "2B: Frequency"})
        m2SubmodeDropdown.Position = UDim2.new(0, 10, 1, -40)
        m2SubmodeDropdown.Size = UDim2.new(0, 90, 0, 25)
        
        local m2FreqInput = createNumberInput(panel, "Freq", UDim2.new(0, 110, 1, -40))
        m2FreqInput.Text = "2"
        m2FreqInput.Size = UDim2.new(0, 40, 0, 25)
        
        local m2ToggleBtn, updateM2Color = createToggleButton(panel, "Toggle M2", UDim2.new(0, 80, 0, 25), UDim2.new(0, 160, 1, -40), shockwaveMode2Active)
        m2ToggleBtn.MouseButton1Click:Connect(function()
            local submode = m2SubmodeDropdown.Text:find("2A") and "ConstantShockwave" or "FrequencyShockwave"
            local freq = tonumber(m2FreqInput.Text) or 2
            local str = tonumber(m1StrengthInput.Text) or 100
            local rad = tonumber(m1RadiusInput.Text) or 50
            toggleShockwaveMode2(submode, freq, str, rad)
            m2ToggleBtn:SetAttribute("ToggleState", shockwaveMode2Active)
            updateM2Color(shockwaveMode2Active)
        end)
    end

    local function createExclusiveZeroGPanel(parent)
        local panel = createPanel(parent, "ðŸŒŒ Exclusive Zero-G", 24)
        
        local infoLabel = Instance.new("TextLabel")
        infoLabel.Size = UDim2.new(1, -20, 0, 40)
        infoLabel.Position = UDim2.new(0, 10, 0, 40)
        infoLabel.BackgroundTransparency = 1
        infoLabel.Text = "One-time apply cancels gravity for ALL\ncurrent unanchored parts. Click again to reapply!"
        infoLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
        infoLabel.TextSize = 11
        infoLabel.TextWrapped = true
        infoLabel.Font = Enum.Font.Gotham
        infoLabel.Parent = panel
        
        local applyBtn = createButton(panel, "Apply Zero-G", UDim2.new(0.5, -5, 0, 30), UDim2.new(0, 10, 0, 85))
        applyBtn.MouseButton1Click:Connect(function()
            applyExclusiveZeroGravity()
        end)
        
        local clearBtn = createButton(panel, "Clear", UDim2.new(0.5, -5, 0, 30), UDim2.new(0.5, 5, 0, 85))
        clearBtn.BackgroundColor3 = Color3.fromRGB(150, 50, 50)
        clearBtn.MouseButton1Click:Connect(function()
            clearExclusiveZeroGravity()
        end)
    end

    local function createOrbiterCorePanel(parent)
        local panel = createPanel(parent, "ðŸŒ€ Orbiter Core", 25)
        
        local freqInput = createNumberInput(panel, "Freq", UDim2.new(0, 10, 0, 40))
        freqInput.Text = "2"
        freqInput.Size = UDim2.new(0, 50, 0, 25)
        
        local radiusInput = createNumberInput(panel, "Radius", UDim2.new(0, 70, 0, 40))
        radiusInput.Text = "10"
        radiusInput.Size = UDim2.new(0, 50, 0, 25)
        
        local speedInput = createNumberInput(panel, "Speed", UDim2.new(0, 130, 0, 40))
        speedInput.Text = "5"
        speedInput.Size = UDim2.new(0, 50, 0, 25)
        
        local infoLabel = Instance.new("TextLabel")
        infoLabel.Size = UDim2.new(1, -20, 0, 35)
        infoLabel.Position = UDim2.new(0, 10, 0, 75)
        infoLabel.BackgroundTransparency = 1
        infoLabel.Text = "Select ANCHORED part!\nOrbits ALL unanchored parts around it."
        infoLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
        infoLabel.TextSize = 10
        infoLabel.TextWrapped = true
        infoLabel.Font = Enum.Font.Gotham
        infoLabel.Parent = panel
        
        local applyBtn = createButton(panel, "Apply Orbiter", UDim2.new(0, 90, 0, 25), UDim2.new(0, 10, 1, -35))
        applyBtn.MouseButton1Click:Connect(function()
            local freq = tonumber(freqInput.Text) or 2
            local rad = tonumber(radiusInput.Text) or 10
            local speed = tonumber(speedInput.Text) or 5
            applyOrbiterCore(freq, rad, speed)
        end)
        
        local removeBtn = createButton(panel, "Remove", UDim2.new(0, 70, 0, 25), UDim2.new(1, -80, 1, -35))
        removeBtn.BackgroundColor3 = Color3.fromRGB(150, 50, 50)
        removeBtn.MouseButton1Click:Connect(function() removeOrbiterCore() end)
    end

    local function createGlobalPhysicsPaintPanel(parent)
        local panel = createPanel(parent, "ðŸŽ¨ Global Physics Paint", 26)
        
        local infoLabel = Instance.new("TextLabel")
        infoLabel.Size = UDim2.new(1, -20, 0, 30)
        infoLabel.Position = UDim2.new(0, 10, 0, 40)
        infoLabel.BackgroundTransparency = 1
        infoLabel.Text = "Apply physics paint to ALL unanchored parts"
        infoLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
        infoLabel.TextSize = 11
        infoLabel.TextWrapped = true
        infoLabel.Font = Enum.Font.Gotham
        infoLabel.Parent = panel
        
        local dropdown = createDropdown(panel, {"Slippery", "Bouncy", "Magnetic", "Gooey"})
        dropdown.Position = UDim2.new(0, 10, 0, 75)
        dropdown.Size = UDim2.new(0, 120, 0, 25)
        
        local applyBtn = createButton(panel, "Apply to All", UDim2.new(0, 80, 0, 25), UDim2.new(0, 140, 0, 75))
        applyBtn.MouseButton1Click:Connect(function()
            local paintType = dropdown.Text:gsub(" â–¼", "")
            applyGlobalPhysicsPaint(paintType)
        end)
        
        local clearBtn = createButton(panel, "Clear All", UDim2.new(0.5, -5, 0, 25), UDim2.new(0, 10, 1, -35))
        clearBtn.BackgroundColor3 = Color3.fromRGB(150, 50, 50)
        clearBtn.MouseButton1Click:Connect(function() clearGlobalPhysicsPaint() end)
    end

    local function createGravityDistorterPanel(parent)
        local panel = createPanel(parent, "ðŸŒ— Gravity Distorter", 22)
        local xInput = createNumberInput(panel, "X", UDim2.new(0, 10, 0, 40))
        xInput.Size = UDim2.new(0, 40, 0, 25)
        xInput.Text = "0"
        local yInput = createNumberInput(panel, "Y", UDim2.new(0, 60, 0, 40))
        yInput.Size = UDim2.new(0, 40, 0, 25)
        yInput.Text = "-1"
        local zInput = createNumberInput(panel, "Z", UDim2.new(0, 110, 0, 40))
        zInput.Size = UDim2.new(0, 40, 0, 25)
        zInput.Text = "0"
        local strengthInput = createNumberInput(panel, "Str", UDim2.new(0, 160, 0, 40))
        strengthInput.Size = UDim2.new(0, 50, 0, 25)
        strengthInput.Text = "100"
        local radiusInput = createNumberInput(panel, "Rad", UDim2.new(0, 220, 0, 40))
        radiusInput.Size = UDim2.new(0, 50, 0, 25)
        radiusInput.Text = "50"
        local modeDropdown = createDropdown(panel, {"Normal", "Chaotic", "Vortex", "Inverse", "InsideOnly"})
        modeDropdown.Position = UDim2.new(0, 10, 0, 75)
        modeDropdown.Size = UDim2.new(0, 100, 0, 25)
        local applyBtn = createButton(panel, "Apply", UDim2.new(0, 60, 0, 25), UDim2.new(0, 120, 0, 75))
        applyBtn.MouseButton1Click:Connect(function()
            local x = tonumber(xInput.Text) or 0
            local y = tonumber(yInput.Text) or -1
            local z = tonumber(zInput.Text) or 0
            local str = tonumber(strengthInput.Text) or 100
            local rad = tonumber(radiusInput.Text) or 50
            local mode = modeDropdown.Text:gsub(" â–¼", "")
            applyGravityDistorter(Vector3.new(x, y, z), str, rad, mode)
        end)
        local removeBtn = createButton(panel, "Remove", UDim2.new(0, 60, 0, 25), UDim2.new(0, 190, 0, 75))
        removeBtn.BackgroundColor3 = Color3.fromRGB(150, 50, 50)
        removeBtn.MouseButton1Click:Connect(function() removeGravityDistorter() end)
    end

    local function createExponentialTweenPanel(parent)
        local panel = createPanel(parent, "ðŸ“ Exponential Tween", 23)
        
        -- Position 1
        local pos1Label = Instance.new("TextLabel")
        pos1Label.Size = UDim2.new(0, 60, 0, 20)
        pos1Label.Position = UDim2.new(0, 10, 0, 40)
        pos1Label.BackgroundTransparency = 1
        pos1Label.Text = "Position 1:"
        pos1Label.TextColor3 = Color3.fromRGB(200, 200, 200)
        pos1Label.TextSize = 10
        pos1Label.Font = Enum.Font.GothamBold
        pos1Label.TextXAlignment = Enum.TextXAlignment.Left
        pos1Label.Parent = panel
        
        local x1Input = createNumberInput(panel, "X", UDim2.new(0, 10, 0, 60))
        x1Input.Size = UDim2.new(0, 40, 0, 25)
        x1Input.Text = "0"
        local y1Input = createNumberInput(panel, "Y", UDim2.new(0, 60, 0, 60))
        y1Input.Size = UDim2.new(0, 40, 0, 25)
        y1Input.Text = "10"
        local z1Input = createNumberInput(panel, "Z", UDim2.new(0, 110, 0, 60))
        z1Input.Size = UDim2.new(0, 40, 0, 25)
        z1Input.Text = "0"
        
        local pos1EasingDropdown = createDropdown(panel, {"In", "Out"})
        pos1EasingDropdown.Position = UDim2.new(0, 160, 0, 60)
        pos1EasingDropdown.Size = UDim2.new(0, 60, 0, 25)
        
        -- Position 2
        local pos2Label = Instance.new("TextLabel")
        pos2Label.Size = UDim2.new(0, 60, 0, 20)
        pos2Label.Position = UDim2.new(0, 10, 0, 90)
        pos2Label.BackgroundTransparency = 1
        pos2Label.Text = "Position 2:"
        pos2Label.TextColor3 = Color3.fromRGB(200, 200, 200)
        pos2Label.TextSize = 10
        pos2Label.Font = Enum.Font.GothamBold
        pos2Label.TextXAlignment = Enum.TextXAlignment.Left
        pos2Label.Parent = panel
        
        local x2Input = createNumberInput(panel, "X", UDim2.new(0, 10, 0, 110))
        x2Input.Size = UDim2.new(0, 40, 0, 25)
        x2Input.Text = "0"
        local y2Input = createNumberInput(panel, "Y", UDim2.new(0, 60, 0, 110))
        y2Input.Size = UDim2.new(0, 40, 0, 25)
        y2Input.Text = "-10"
        local z2Input = createNumberInput(panel, "Z", UDim2.new(0, 110, 0, 110))
        z2Input.Size = UDim2.new(0, 40, 0, 25)
        z2Input.Text = "0"
        
        local pos2EasingDropdown = createDropdown(panel, {"In", "Out"})
        pos2EasingDropdown.Position = UDim2.new(0, 160, 0, 110)
        pos2EasingDropdown.Size = UDim2.new(0, 60, 0, 25)
        
        -- Time
        local timeInput = createNumberInput(panel, "Time (s)", UDim2.new(0, 230, 0, 60))
        timeInput.Size = UDim2.new(0, 50, 0, 25)
        timeInput.Text = "2"
        
        local applyBtn = createButton(panel, "Apply Tween", UDim2.new(0, 90, 0, 25), UDim2.new(0, 10, 1, -35))
        applyBtn.MouseButton1Click:Connect(function()
            local x1 = tonumber(x1Input.Text) or 0
            local y1 = tonumber(y1Input.Text) or 10
            local z1 = tonumber(z1Input.Text) or 0
            local x2 = tonumber(x2Input.Text) or 0
            local y2 = tonumber(y2Input.Text) or -10
            local z2 = tonumber(z2Input.Text) or 0
            local time = tonumber(timeInput.Text) or 2
            local pos1Easing = pos1EasingDropdown.Text:gsub(" â–¼", "")
            local pos2Easing = pos2EasingDropdown.Text:gsub(" â–¼", "")
            applyExponentialTween(Vector3.new(x1, y1, z1), Vector3.new(x2, y2, z2), time, pos1Easing, pos2Easing)
        end)
        
        local removeBtn = createButton(panel, "Remove", UDim2.new(0, 70, 0, 25), UDim2.new(1, -80, 1, -35))
        removeBtn.BackgroundColor3 = Color3.fromRGB(150, 50, 50)
        removeBtn.MouseButton1Click:Connect(function() removeExponentialTween() end)
    end

    -- NEW: Linear Oscillate storage
    local linearOscillateParts = {}
    
    -- NEW: Angular Oscillate storage
    local angularOscillateParts = {}
    
    local function getClosestStudPosition(part, clickPos)
        if not part:IsA("BasePart") then return nil end
        local studSize = 0.2
        local relPos = part.CFrame:PointToObjectSpace(clickPos)
        local topY = part.Size.Y / 2
        if math.abs(relPos.Y - topY) > 0.5 then return nil end
        local studX = math.floor(relPos.X / studSize + 0.5) * studSize
        local studZ = math.floor(relPos.Z / studSize + 0.5) * studSize
        local studWorldPos = part.CFrame:PointToWorldSpace(Vector3.new(studX, topY, studZ))
        return {part = part, localPos = Vector3.new(studX, topY, studZ), worldPos = studWorldPos}
    end

    -- NEW: Linear Oscillate function with advanced easing types
    local function applyLinearOscillate(pos1, pos2, time, easingType, directionMode)
        easingType = easingType or "Linear"
        directionMode = directionMode or "InOut"
        
        for _, part in ipairs(selectedParts) do
            replicateToServer(function()
                setNetworkOwnership(part)
                
                if linearOscillateParts[part] then
                    if linearOscillateParts[part].connection then linearOscillateParts[part].connection:Disconnect() end
                    if linearOscillateParts[part].bodyPosition then linearOscillateParts[part].bodyPosition:Destroy() end
                    if linearOscillateParts[part].bodyGyro then linearOscillateParts[part].bodyGyro:Destroy() end
                    if linearOscillateParts[part].vectorForce then linearOscillateParts[part].vectorForce:Destroy() end
                    if linearOscillateParts[part].attachment then linearOscillateParts[part].attachment:Destroy() end
                end
                
                local bodyPosition = Instance.new("BodyPosition")
                bodyPosition.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                bodyPosition.D = 5000
                bodyPosition.P = 50000
                bodyPosition.Parent = part
                
                local bodyGyro = Instance.new("BodyGyro")
                bodyGyro.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
                bodyGyro.D = 5000
                bodyGyro.P = 50000
                bodyGyro.CFrame = part.CFrame
                bodyGyro.Parent = part
                
                local attachment = Instance.new("Attachment")
                attachment.Parent = part
                
                local vectorForce = Instance.new("VectorForce")
                vectorForce.Attachment0 = attachment
                vectorForce.ApplyAtCenterOfMass = true
                vectorForce.RelativeTo = Enum.ActuatorRelativeTo.World
                vectorForce.Force = Vector3.new(0, part.Mass * workspace.Gravity, 0)
                vectorForce.Parent = part
                
                local startPos = part.Position
                local targetPos1 = startPos + pos1
                local targetPos2 = startPos + pos2
                local movingToPos1 = true
                local startTime = tick()
                
                local function easingFunction(t, easingType, directionMode)
                    if directionMode == "Linear" or easingType == "Linear" then return t end
                    if easingType == "Constant" then return t < 1 and 0 or 1 end
                    local isToPos1 = movingToPos1
                    if easingType == "Quadratic" then
                        if directionMode == "InOut" then
                            return isToPos1 and t * t or 1 - (1 - t) * (1 - t)
                        elseif directionMode == "InIn" then return t * t
                        else return 1 - (1 - t) * (1 - t) end
                    elseif easingType == "Cubic" then
                        if directionMode == "InOut" then
                            return isToPos1 and t * t * t or 1 - math.pow(1 - t, 3)
                        elseif directionMode == "InIn" then return t * t * t
                        else return 1 - math.pow(1 - t, 3) end
                    elseif easingType == "Sine" then
                        if directionMode == "InOut" then
                            return isToPos1 and 1 - math.cos((t * math.pi) / 2) or math.sin((t * math.pi) / 2)
                        elseif directionMode == "InIn" then return 1 - math.cos((t * math.pi) / 2)
                        else return math.sin((t * math.pi) / 2) end
                    elseif easingType == "Exponential" then
                        if directionMode == "InOut" then
                            return isToPos1 and (t == 0 and 0 or math.pow(2, 10 * (t - 1))) or (t == 1 and 1 or 1 - math.pow(2, -10 * t))
                        elseif directionMode == "InIn" then return t == 0 and 0 or math.pow(2, 10 * (t - 1))
                        else return t == 1 and 1 or 1 - math.pow(2, -10 * t) end
                    elseif easingType == "Elastic" then
                        if t == 0 or t == 1 then return t end
                        if directionMode == "InOut" then
                            return isToPos1 and -math.pow(2, 10 * (t - 1)) * math.sin((t - 1.1) * 5 * math.pi) or math.pow(2, -10 * t) * math.sin((t - 0.1) * 5 * math.pi) + 1
                        elseif directionMode == "InIn" then return -math.pow(2, 10 * (t - 1)) * math.sin((t - 1.1) * 5 * math.pi)
                        else return math.pow(2, -10 * t) * math.sin((t - 0.1) * 5 * math.pi) + 1 end
                    elseif easingType == "Bounce" then
                        if directionMode == "OutOut" or (directionMode == "InOut" and not isToPos1) then
                            if t < 1/2.75 then return 7.5625 * t * t
                            elseif t < 2/2.75 then t = t - 1.5/2.75 return 7.5625 * t * t + 0.75
                            elseif t < 2.5/2.75 then t = t - 2.25/2.75 return 7.5625 * t * t + 0.9375
                            else t = t - 2.625/2.75 return 7.5625 * t * t + 0.984375 end
                        else return 1 - easingFunction(1 - t, "Bounce", "OutOut") end
                    end
                    return t
                end
                
                local connection = RunService.Heartbeat:Connect(function()
                    if not part.Parent then connection:Disconnect() return end
                    
                    local elapsed = (tick() - startTime) % (time * 2)
                    local alpha, targetPos
                    
                    if elapsed < time then
                        movingToPos1 = true
                        alpha = elapsed / time
                        targetPos = targetPos1
                    else
                        movingToPos1 = false
                        alpha = (elapsed - time) / time
                        targetPos = targetPos2
                    end
                    
                    local easedAlpha = easingFunction(alpha, easingType, directionMode)
                    local currentPos = (movingToPos1 and startPos or targetPos1):Lerp(targetPos, easedAlpha)
                    
                    bodyPosition.Position = currentPos
                    bodyGyro.CFrame = part.CFrame
                    part.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                    part.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                end)
                
                linearOscillateParts[part] = {bodyPosition = bodyPosition, bodyGyro = bodyGyro, attachment = attachment, vectorForce = vectorForce, connection = connection}
                print("Applied Linear Oscillate to " .. part.Name)
            end)
        end
    end
    
    local function removeLinearOscillate()
        for _, part in ipairs(selectedParts) do
            if linearOscillateParts[part] then
                if linearOscillateParts[part].currentConnection then linearOscillateParts[part].currentConnection:Disconnect() end
                if linearOscillateParts[part].connection then linearOscillateParts[part].connection:Disconnect() end
                if linearOscillateParts[part].bodyPosition then linearOscillateParts[part].bodyPosition:Destroy() end
                if linearOscillateParts[part].bodyGyro then linearOscillateParts[part].bodyGyro:Destroy() end
                if linearOscillateParts[part].vectorForce then linearOscillateParts[part].vectorForce:Destroy() end
                if linearOscillateParts[part].attachment then linearOscillateParts[part].attachment:Destroy() end
                linearOscillateParts[part] = nil
                print("Removed Linear Oscillate from " .. part.Name)
            end
        end
    end

    -- NEW: Rotation Lock storage
    local rotationLockParts = {}
    
    local function applyRotationLock(allowedAxis)
        allowedAxis = allowedAxis or "None"
        for _, part in ipairs(selectedParts) do
            replicateToServer(function()
                setNetworkOwnership(part)
                
                if rotationLockParts[part] then
                    if rotationLockParts[part].connection then rotationLockParts[part].connection:Disconnect() end
                    if rotationLockParts[part].bodyPosition then rotationLockParts[part].bodyPosition:Destroy() end
                    if rotationLockParts[part].bodyGyro then rotationLockParts[part].bodyGyro:Destroy() end
                end
                
                local bodyPosition = Instance.new("BodyPosition")
                bodyPosition.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                bodyPosition.Position = part.Position
                bodyPosition.D = 5000
                bodyPosition.P = 50000
                bodyPosition.Parent = part
                
                local bodyGyro = Instance.new("BodyGyro")
                bodyGyro.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
                bodyGyro.D = 5000
                bodyGyro.P = 50000
                bodyGyro.CFrame = part.CFrame
                bodyGyro.Parent = part
                
                local lockedCFrame = part.CFrame
                
                local connection = RunService.Heartbeat:Connect(function()
                    if part.Parent then
                        bodyPosition.Position = part.Position
                        part.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                        
                        if allowedAxis == "None" then
                            bodyGyro.CFrame = lockedCFrame
                            part.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                        else
                            local currentAngVel = part.AssemblyAngularVelocity
                            local filteredVel = Vector3.new(0, 0, 0)
                            
                            if allowedAxis == "X" then
                                filteredVel = Vector3.new(currentAngVel.X, 0, 0)
                            elseif allowedAxis == "Y" then
                                filteredVel = Vector3.new(0, currentAngVel.Y, 0)
                            elseif allowedAxis == "Z" then
                                filteredVel = Vector3.new(0, 0, currentAngVel.Z)
                            end
                            
                            part.AssemblyAngularVelocity = filteredVel
                            
                            local currentCFrame = part.CFrame
                            local lockedPos = currentCFrame.Position
                            local lockedLook = lockedCFrame.LookVector
                            local lockedUp = lockedCFrame.UpVector
                            
                            if allowedAxis == "X" then
                                local currentRight = currentCFrame.RightVector
                                bodyGyro.CFrame = CFrame.fromMatrix(lockedPos, currentRight, lockedUp)
                            elseif allowedAxis == "Y" then
                                bodyGyro.CFrame = CFrame.fromMatrix(lockedPos, lockedLook, currentCFrame.UpVector)
                            elseif allowedAxis == "Z" then
                                local currentLook = currentCFrame.LookVector
                                bodyGyro.CFrame = CFrame.fromMatrix(lockedPos, lockedLook, lockedUp)
                            end
                        end
                    else
                        connection:Disconnect()
                    end
                end)
                
                rotationLockParts[part] = {
                    bodyPosition = bodyPosition,
                    bodyGyro = bodyGyro,
                    connection = connection,
                    lockedCFrame = lockedCFrame,
                    allowedAxis = allowedAxis
                }
                
                print("Applied Rotation Lock (" .. allowedAxis .. " only) to " .. part.Name)
            end)
        end
    end
    
    local function removeRotationLock()
        for _, part in ipairs(selectedParts) do
            if rotationLockParts[part] then
                if rotationLockParts[part].connection then rotationLockParts[part].connection:Disconnect() end
                if rotationLockParts[part].bodyPosition then rotationLockParts[part].bodyPosition:Destroy() end
                if rotationLockParts[part].bodyGyro then rotationLockParts[part].bodyGyro:Destroy() end
                rotationLockParts[part] = nil
                print("Removed Rotation Lock from " .. part.Name)
            end
        end
    end
    
    local function createRotationLockPanel(parent)
        local panel = createPanel(parent, "ðŸ” Rotation Lock", 25)
        local infoLabel = Instance.new("TextLabel")
        infoLabel.Size = UDim2.new(1, -20, 0, 30)
        infoLabel.Position = UDim2.new(0, 10, 0, 40)
        infoLabel.BackgroundTransparency = 1
        infoLabel.Text = "Stops falling/moving. Can rotate on axis:"
        infoLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
        infoLabel.TextSize = 11
        infoLabel.TextWrapped = true
        infoLabel.Font = Enum.Font.Gotham
        infoLabel.Parent = panel
        local dropdown = createDropdown(panel, {"None", "X", "Y", "Z"})
        dropdown.Position = UDim2.new(0, 10, 0, 75)
        dropdown.Size = UDim2.new(0, 80, 0, 25)
        local applyBtn = createButton(panel, "Apply", UDim2.new(0, 70, 0, 25), UDim2.new(0, 100, 0, 75))
        applyBtn.MouseButton1Click:Connect(function() 
            local axis = dropdown.Text:gsub(" â–¼", "")
            applyRotationLock(axis) 
        end)
        local removeBtn = createButton(panel, "Remove", UDim2.new(0, 70, 0, 25), UDim2.new(0, 180, 0, 75))
        removeBtn.BackgroundColor3 = Color3.fromRGB(150, 50, 50)
        removeBtn.MouseButton1Click:Connect(function() removeRotationLock() end)
    end

    local function createLinearOscillatePanel(parent)
        local panel = createPanel(parent, "ðŸ”„ Linear Oscillate", 26)
        
        local typeDropdown = createDropdown(panel, {"Linear", "Constant", "Quadratic", "Cubic", "Sine", "Exponential", "Elastic", "Bounce"})
        typeDropdown.Position = UDim2.new(0, 10, 0, 40)
        typeDropdown.Size = UDim2.new(0, 90, 0, 25)
        
        local modeDropdown = createDropdown(panel, {"InOut", "InIn", "OutOut", "Linear"})
        modeDropdown.Position = UDim2.new(0, 110, 0, 40)
        modeDropdown.Size = UDim2.new(0, 70, 0, 25)
        
        local x1Input = createNumberInput(panel, "X1", UDim2.new(0, 10, 0, 75))
        x1Input.Size = UDim2.new(0, 50, 0, 25)
        x1Input.Text = "0"
        local y1Input = createNumberInput(panel, "Y1", UDim2.new(0, 70, 0, 75))
        y1Input.Size = UDim2.new(0, 50, 0, 25)
        y1Input.Text = "5"
        local z1Input = createNumberInput(panel, "Z1", UDim2.new(0, 130, 0, 75))
        z1Input.Size = UDim2.new(0, 50, 0, 25)
        z1Input.Text = "0"
        
        local x2Input = createNumberInput(panel, "X2", UDim2.new(0, 10, 0, 105))
        x2Input.Size = UDim2.new(0, 50, 0, 25)
        x2Input.Text = "0"
        local y2Input = createNumberInput(panel, "Y2", UDim2.new(0, 70, 0, 105))
        y2Input.Size = UDim2.new(0, 50, 0, 25)
        y2Input.Text = "-5"
        local z2Input = createNumberInput(panel, "Z2", UDim2.new(0, 130, 0, 105))
        z2Input.Size = UDim2.new(0, 50, 0, 25)
        z2Input.Text = "0"
        
        local timeInput = createNumberInput(panel, "Time", UDim2.new(0, 190, 0, 75))
        timeInput.Size = UDim2.new(0, 50, 0, 25)
        timeInput.Text = "2"
        
        local applyBtn = createButton(panel, "Apply", UDim2.new(0, 70, 0, 25), UDim2.new(0, 190, 0, 105))
        applyBtn.MouseButton1Click:Connect(function()
            local x1 = tonumber(x1Input.Text) or 0
            local y1 = tonumber(y1Input.Text) or 5
            local z1 = tonumber(z1Input.Text) or 0
            local x2 = tonumber(x2Input.Text) or 0
            local y2 = tonumber(y2Input.Text) or -5
            local z2 = tonumber(z2Input.Text) or 0
            local time = tonumber(timeInput.Text) or 2
            local easingType = typeDropdown.Text:gsub(" â–¼", "")
            local directionMode = modeDropdown.Text:gsub(" â–¼", "")
            applyLinearOscillate(Vector3.new(x1, y1, z1), Vector3.new(x2, y2, z2), time, easingType, directionMode)
        end)
        
        local removeBtn = createButton(panel, "Remove", UDim2.new(0, 70, 0, 25), UDim2.new(0, 190, 1, -35))
        removeBtn.BackgroundColor3 = Color3.fromRGB(150, 50, 50)
        removeBtn.MouseButton1Click:Connect(function() removeLinearOscillate() end)
    end
    
    local function applyAngularOscillate(ang1, ang2, time, easingType, directionMode)
        easingType = easingType or "Linear"
        directionMode = directionMode or "InOut"
        
        for _, part in ipairs(selectedParts) do
            replicateToServer(function()
                setNetworkOwnership(part)
                
                if angularOscillateParts[part] then
                    if angularOscillateParts[part].connection then angularOscillateParts[part].connection:Disconnect() end
                    if angularOscillateParts[part].bodyGyro then angularOscillateParts[part].bodyGyro:Destroy() end
                    if angularOscillateParts[part].bodyPosition then angularOscillateParts[part].bodyPosition:Destroy() end
                    if angularOscillateParts[part].vectorForce then angularOscillateParts[part].vectorForce:Destroy() end
                    if angularOscillateParts[part].attachment then angularOscillateParts[part].attachment:Destroy() end
                end
                
                local bodyPosition = Instance.new("BodyPosition")
                bodyPosition.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                bodyPosition.Position = part.Position
                bodyPosition.D = 5000
                bodyPosition.P = 50000
                bodyPosition.Parent = part
                
                local bodyGyro = Instance.new("BodyGyro")
                bodyGyro.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
                bodyGyro.D = 5000
                bodyGyro.P = 50000
                bodyGyro.Parent = part
                
                local attachment = Instance.new("Attachment")
                attachment.Parent = part
                
                local vectorForce = Instance.new("VectorForce")
                vectorForce.Attachment0 = attachment
                vectorForce.ApplyAtCenterOfMass = true
                vectorForce.RelativeTo = Enum.ActuatorRelativeTo.World
                vectorForce.Force = Vector3.new(0, part.Mass * workspace.Gravity, 0)
                vectorForce.Parent = part
                
                local baseRotation = part.CFrame - part.CFrame.Position
                local rotation1 = CFrame.Angles(math.rad(ang1.X), math.rad(ang1.Y), math.rad(ang1.Z))
                local rotation2 = CFrame.Angles(math.rad(ang2.X), math.rad(ang2.Y), math.rad(ang2.Z))
                local movingToAng1 = true
                local startTime = tick()
                
                local function easingFunction(t, easingType, directionMode)
                    if directionMode == "Linear" or easingType == "Linear" then return t end
                    if easingType == "Constant" then return t < 1 and 0 or 1 end
                    local isToAng1 = movingToAng1
                    if easingType == "Quadratic" then
                        if directionMode == "InOut" then return isToAng1 and t * t or 1 - (1 - t) * (1 - t)
                        elseif directionMode == "InIn" then return t * t
                        else return 1 - (1 - t) * (1 - t) end
                    elseif easingType == "Cubic" then
                        if directionMode == "InOut" then return isToAng1 and t * t * t or 1 - math.pow(1 - t, 3)
                        elseif directionMode == "InIn" then return t * t * t
                        else return 1 - math.pow(1 - t, 3) end
                    elseif easingType == "Sine" then
                        if directionMode == "InOut" then return isToAng1 and 1 - math.cos((t * math.pi) / 2) or math.sin((t * math.pi) / 2)
                        elseif directionMode == "InIn" then return 1 - math.cos((t * math.pi) / 2)
                        else return math.sin((t * math.pi) / 2) end
                    elseif easingType == "Exponential" then
                        if directionMode == "InOut" then return isToAng1 and (t == 0 and 0 or math.pow(2, 10 * (t - 1))) or (t == 1 and 1 or 1 - math.pow(2, -10 * t))
                        elseif directionMode == "InIn" then return t == 0 and 0 or math.pow(2, 10 * (t - 1))
                        else return t == 1 and 1 or 1 - math.pow(2, -10 * t) end
                    end
                    return t
                end
                
                local connection = RunService.Heartbeat:Connect(function()
                    if not part.Parent then connection:Disconnect() return end
                    
                    local elapsed = (tick() - startTime) % (time * 2)
                    local alpha, targetRotation
                    
                    if elapsed < time then
                        movingToAng1 = true
                        alpha = elapsed / time
                        targetRotation = rotation1
                    else
                        movingToAng1 = false
                        alpha = (elapsed - time) / time
                        targetRotation = rotation2
                    end
                    
                    local easedAlpha = easingFunction(alpha, easingType, directionMode)
                    local currentRotation = (movingToAng1 and baseRotation or (baseRotation * rotation1)):Lerp(baseRotation * targetRotation, easedAlpha)
                    
                    bodyPosition.Position = part.Position
                    bodyGyro.CFrame = CFrame.new(part.Position) * currentRotation
                    part.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                    part.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                end)
                
                angularOscillateParts[part] = {bodyGyro = bodyGyro, bodyPosition = bodyPosition, attachment = attachment, vectorForce = vectorForce, connection = connection}
                print("Applied Angular Oscillate to " .. part.Name)
            end)
        end
    end

    
    local function removeAngularOscillate()
        for _, part in ipairs(selectedParts) do
            if angularOscillateParts[part] then
                if angularOscillateParts[part].currentConnection then angularOscillateParts[part].currentConnection:Disconnect() end
                if angularOscillateParts[part].connection then angularOscillateParts[part].connection:Disconnect() end
                if angularOscillateParts[part].bodyGyro then angularOscillateParts[part].bodyGyro:Destroy() end
                angularOscillateParts[part] = nil
                print("Removed Angular Oscillate from " .. part.Name)
            end
        end
    end
    
    local function createAngularOscillatePanel(parent)
        local panel = createPanel(parent, "ðŸŒ€ Angular Oscillate", 27)
        
        local typeDropdown = createDropdown(panel, {"Linear", "Constant", "Quadratic", "Cubic", "Sine", "Exponential"})
        typeDropdown.Position = UDim2.new(0, 10, 0, 40)
        typeDropdown.Size = UDim2.new(0, 90, 0, 25)
        
        local modeDropdown = createDropdown(panel, {"InOut", "InIn", "OutOut", "Linear"})
        modeDropdown.Position = UDim2.new(0, 110, 0, 40)
        modeDropdown.Size = UDim2.new(0, 70, 0, 25)
        
        local x1Input = createNumberInput(panel, "X1Â°", UDim2.new(0, 10, 0, 75))
        x1Input.Size = UDim2.new(0, 50, 0, 25)
        x1Input.Text = "0"
        local y1Input = createNumberInput(panel, "Y1Â°", UDim2.new(0, 70, 0, 75))
        y1Input.Size = UDim2.new(0, 50, 0, 25)
        y1Input.Text = "45"
        local z1Input = createNumberInput(panel, "Z1Â°", UDim2.new(0, 130, 0, 75))
        z1Input.Size = UDim2.new(0, 50, 0, 25)
        z1Input.Text = "0"
        
        local x2Input = createNumberInput(panel, "X2Â°", UDim2.new(0, 10, 0, 105))
        x2Input.Size = UDim2.new(0, 50, 0, 25)
        x2Input.Text = "0"
        local y2Input = createNumberInput(panel, "Y2Â°", UDim2.new(0, 70, 0, 105))
        y2Input.Size = UDim2.new(0, 50, 0, 25)
        y2Input.Text = "-45"
        local z2Input = createNumberInput(panel, "Z2Â°", UDim2.new(0, 130, 0, 105))
        z2Input.Size = UDim2.new(0, 50, 0, 25)
        z2Input.Text = "0"
        
        local timeInput = createNumberInput(panel, "Time", UDim2.new(0, 190, 0, 75))
        timeInput.Size = UDim2.new(0, 50, 0, 25)
        timeInput.Text = "2"
        
        local applyBtn = createButton(panel, "Apply", UDim2.new(0, 70, 0, 25), UDim2.new(0, 190, 0, 105))
        applyBtn.MouseButton1Click:Connect(function()
            local x1 = tonumber(x1Input.Text) or 0
            local y1 = tonumber(y1Input.Text) or 45
            local z1 = tonumber(z1Input.Text) or 0
            local x2 = tonumber(x2Input.Text) or 0
            local y2 = tonumber(y2Input.Text) or -45
            local z2 = tonumber(z2Input.Text) or 0
            local time = tonumber(timeInput.Text) or 2
            local easingType = typeDropdown.Text:gsub(" â–¼", "")
            local directionMode = modeDropdown.Text:gsub(" â–¼", "")
            applyAngularOscillate(Vector3.new(x1, y1, z1), Vector3.new(x2, y2, z2), time, easingType, directionMode)
        end)
        
        local removeBtn = createButton(panel, "Remove", UDim2.new(0, 70, 0, 25), UDim2.new(0, 190, 1, -35))
        removeBtn.BackgroundColor3 = Color3.fromRGB(150, 50, 50)
        removeBtn.MouseButton1Click:Connect(function() removeAngularOscillate() end)
    end

    -- NEW: Skybox Teleporter (EXTREME COORDINATES - Corruption Zone & Beyond)
    local skyboxCoordinates = {
        -- Color Box Layer (~2^20 = 1,048,576)
        ["Color Box +X"] = Vector3.new(1048576, 0, 0),
        ["Color Box -X"] = Vector3.new(-1048576, 0, 0),
        ["Color Box +Y"] = Vector3.new(0, 1048576, 0),
        ["Color Box -Y"] = Vector3.new(0, -1048576, 0),
        ["Color Box +Z"] = Vector3.new(0, 0, 1048576),
        ["Color Box -Z"] = Vector3.new(0, 0, -1048576),
        
        -- Glitch Box Layer (~2^27 = 134,217,728)
        ["Glitch Box +X"] = Vector3.new(134217728, 0, 0),
        ["Glitch Box -X"] = Vector3.new(-134217728, 0, 0),
        ["Glitch Box +Y"] = Vector3.new(0, 134217728, 0),
        ["Glitch Box -Y"] = Vector3.new(0, -134217728, 0),
        ["Glitch Box +Z"] = Vector3.new(0, 0, 134217728),
        ["Glitch Box -Z"] = Vector3.new(0, 0, -134217728),
        
        -- Gray Box Layer (~2^31 = 2,147,483,648)
        ["Gray Box +X"] = Vector3.new(2147483647, 0, 0),
        ["Gray Box -X"] = Vector3.new(-2147483647, 0, 0),
        ["Gray Box +Y"] = Vector3.new(0, 2147483647, 0),
        ["Gray Box -Y"] = Vector3.new(0, -2147483647, 0),
        ["Gray Box +Z"] = Vector3.new(0, 0, 2147483647),
        ["Gray Box -Z"] = Vector3.new(0, 0, -2147483647),
        
        -- The Void (~2^40 = 1,099,511,627,776 - 1 TRILLION)
        ["The Void +X"] = Vector3.new(1099511627776, 0, 0),
        ["The Void -X"] = Vector3.new(-1099511627776, 0, 0),
        ["The Void +Y"] = Vector3.new(0, 1099511627776, 0),
        ["The Void -Y"] = Vector3.new(0, -1099511627776, 0),
        ["The Void +Z"] = Vector3.new(0, 0, 1099511627776),
        ["The Void -Z"] = Vector3.new(0, 0, -1099511627776),
        
        -- CORRUPTION ZONE (~2^47 = 140,737,488,355,328 - 140 TRILLION)
        ["Corruption +X"] = Vector3.new(140737488355328, 0, 0),
        ["Corruption -X"] = Vector3.new(-140737488355328, 0, 0),
        ["Corruption +Y"] = Vector3.new(0, 140737488355328, 0),
        ["Corruption -Y"] = Vector3.new(0, -140737488355328, 0),
        ["Corruption +Z"] = Vector3.new(0, 0, 140737488355328),
        ["Corruption -Z"] = Vector3.new(0, 0, -140737488355328),
        
        -- EXTREME VOID (~2^53 = 9,007,199,254,740,992 - 9 QUADRILLION)
        ["Extreme Void +X"] = Vector3.new(9007199254740992, 0, 0),
        ["Extreme Void -X"] = Vector3.new(-9007199254740992, 0, 0),
        ["Extreme Void +Y"] = Vector3.new(0, 9007199254740992, 0),
        ["Extreme Void -Y"] = Vector3.new(0, -9007199254740992, 0),
        ["Extreme Void +Z"] = Vector3.new(0, 0, 9007199254740992),
        ["Extreme Void -Z"] = Vector3.new(0, 0, -9007199254740992)
    }
    
    local function teleportToSkybox(destination)
        if not skyboxCoordinates[destination] then
            warn("Unknown skybox destination: " .. destination)
            return
        end
        
        local targetPos = skyboxCoordinates[destination]
        
        for _, part in ipairs(selectedParts) do
            replicateToServer(function()
                setNetworkOwnership(part)
                
                if part and part.Parent and not part.Anchored then
                    part.CFrame = CFrame.new(targetPos)
                    part.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                    part.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                    
                    task.wait(0.1)
                    part.CFrame = CFrame.new(targetPos)
                    
                    print("ðŸŒŒ Teleported " .. part.Name .. " to " .. destination .. " at " .. tostring(targetPos))
                elseif part.Anchored then
                    warn("âš ï¸ Cannot teleport anchored part: " .. part.Name)
                end
            end)
        end
    end
    
    local function teleportToCustomCoords(x, y, z, addMode)
        for _, part in ipairs(selectedParts) do
            replicateToServer(function()
                setNetworkOwnership(part)
                
                if part and part.Parent and not part.Anchored then
                    local targetPos
                    if addMode then
                        -- Add mode: add to current position
                        targetPos = part.Position + Vector3.new(x, y, z)
                    else
                        -- Set mode: absolute position
                        targetPos = Vector3.new(x, y, z)
                    end
                    
                    part.CFrame = CFrame.new(targetPos)
                    part.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                    part.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                    
                    task.wait(0.1)
                    part.CFrame = CFrame.new(targetPos)
                    
                    if addMode then
                        print("ðŸŽ¯ Moved " .. part.Name .. " by offset: " .. tostring(Vector3.new(x, y, z)) .. " â†’ now at " .. tostring(targetPos))
                    else
                        print("ðŸŽ¯ Teleported " .. part.Name .. " to custom coords: " .. tostring(targetPos))
                    end
                elseif part.Anchored then
                    warn("âš ï¸ Cannot teleport anchored part: " .. part.Name)
                end
            end)
        end
    end
    
    -- NEW: Sentinel System Storage
    local sentinelParts = {}
    local sentinelTeams = {}
    local sentinelUpdateConnection = nil
    local sentinelDisplayToggle = true
    local sentinelTalkingEnabled = true
    local tf2ModeEnabled = false
    
    -- TF2 Class Loadouts
    local tf2Classes = {
        Scout = {
            weapons = {"Scattergun", "Pistol", "Baseball Bat"},
            speed = 24,
            health = 125,
            color = Color3.fromRGB(100, 255, 100)
        },
        Soldier = {
            weapons = {"Rocket Launcher", "Shotgun", "Shovel"},
            speed = 16,
            health = 200,
            color = Color3.fromRGB(255, 150, 100)
        },
        Pyro = {
            weapons = {"Flamethrower", "Shotgun", "Fire Axe"},
            speed = 18,
            health = 175,
            color = Color3.fromRGB(255, 100, 100)
        },
        Demoman = {
            weapons = {"Grenade Launcher", "Sticky Bomb", "Bottle"},
            speed = 18,
            health = 175,
            color = Color3.fromRGB(150, 100, 255)
        },
        Heavy = {
            weapons = {"Minigun", "Shotgun", "Fists"},
            speed = 12,
            health = 300,
            color = Color3.fromRGB(255, 100, 255)
        },
        Engineer = {
            weapons = {"Shotgun", "Pistol", "Wrench"},
            speed = 18,
            health = 125,
            color = Color3.fromRGB(255, 200, 100)
        },
        Medic = {
            weapons = {"Syringe Gun", "Medi Gun", "Bonesaw"},
            speed = 20,
            health = 150,
            color = Color3.fromRGB(200, 255, 255)
        },
        Sniper = {
            weapons = {"Sniper Rifle", "SMG", "Kukri"},
            speed = 18,
            health = 125,
            color = Color3.fromRGB(255, 255, 100)
        },
        Spy = {
            weapons = {"Revolver", "Knife", "Sapper"},
            speed = 20,
            health = 125,
            color = Color3.fromRGB(150, 150, 255)
        }
    }
    
    local function createSentinel(part, behavior, movementMode, flightEnabled, team, speed, displayName, weapon1, weapon2, weapon3, tf2Class)
        behavior = behavior or "Wanderer"
        movementMode = movementMode or "Realistic"
        flightEnabled = flightEnabled or false
        team = team or "Neutral"
        speed = speed or 16
        displayName = displayName or part.Name
        weapon1 = weapon1 or "None"
        weapon2 = weapon2 or "None"
        weapon3 = weapon3 or "None"
        tf2Class = tf2Class or "None"
        
        -- TF2 Mode overrides
        if tf2ModeEnabled and tf2Class ~= "None" and tf2Classes[tf2Class] then
            local classData = tf2Classes[tf2Class]
            weapon1 = classData.weapons[1]
            weapon2 = classData.weapons[2]
            weapon3 = classData.weapons[3]
            speed = classData.speed
            
            -- Force team to be RED or BLU only
            if team ~= "RED" and team ~= "BLU" then
                team = math.random() > 0.5 and "RED" or "BLU"
            end
            
            -- Force Fighter behavior in TF2 mode
            behavior = "Fighter"
        end
        
        replicateToServer(function()
            setNetworkOwnership(part)
            
            -- CRITICAL: Remove ALL existing physics effects before creating Sentinel
            if velocityControls[part] then
                if velocityControls[part].connection then velocityControls[part].connection:Disconnect() end
                if velocityControls[part].bodyVel then velocityControls[part].bodyVel:Destroy() end
                if velocityControls[part].vectorForce then velocityControls[part].vectorForce:Destroy() end
                if velocityControls[part].attachment then velocityControls[part].attachment:Destroy() end
                if velocityControls[part].keybindConnection then velocityControls[part].keybindConnection:Disconnect() end
                velocityControls[part] = nil
            end
            
            if angularControls[part] then
                if angularControls[part].connection then angularControls[part].connection:Disconnect() end
                if angularControls[part].bodyAngVel then angularControls[part].bodyAngVel:Destroy() end
                if angularControls[part].bodyPosition then angularControls[part].bodyPosition:Destroy() end
                if angularControls[part].bodyGyro then angularControls[part].bodyGyro:Destroy() end
                if angularControls[part].attachment then angularControls[part].attachment:Destroy() end
                if angularControls[part].torqueForce then angularControls[part].torqueForce:Destroy() end
                if angularControls[part].weldConstraint then angularControls[part].weldConstraint:Destroy() end
                if angularControls[part].anchorPart then angularControls[part].anchorPart:Destroy() end
                if angularControls[part].keybindConnection then angularControls[part].keybindConnection:Disconnect() end
                if angularControls[part].safetyConnection then angularControls[part].safetyConnection:Disconnect() end
                angularControls[part] = nil
            end
            
            if gravityForces[part] then
                if gravityForces[part].connection then gravityForces[part].connection:Disconnect() end
                if gravityForces[part].vectorForce then gravityForces[part].vectorForce:Destroy() end
                if gravityForces[part].attachment then gravityForces[part].attachment:Destroy() end
                gravityForces[part] = nil
            end
            
            if gyroStabilizers[part] then
                if gyroStabilizers[part].connection then gyroStabilizers[part].connection:Disconnect() end
                if gyroStabilizers[part].bodyPosition then gyroStabilizers[part].bodyPosition:Destroy() end
                if gyroStabilizers[part].bodyAngularVelocity then gyroStabilizers[part].bodyAngularVelocity:Destroy() end
                if gyroStabilizers[part].attachment then gyroStabilizers[part].attachment:Destroy() end
                if gyroStabilizers[part].alignOrientation then gyroStabilizers[part].alignOrientation:Destroy() end
                if gyroStabilizers[part].bodyGyro then gyroStabilizers[part].bodyGyro:Destroy() end
                gyroStabilizers[part] = nil
            end
            
            if positionLocks[part] then
                if positionLocks[part].connection then positionLocks[part].connection:Disconnect() end
                if positionLocks[part].bodyPosition then positionLocks[part].bodyPosition:Destroy() end
                if positionLocks[part].bodyVelocity then positionLocks[part].bodyVelocity:Destroy() end
                positionLocks[part] = nil
            end
            
            if frozenFlingers[part] then
                if frozenFlingers[part].connection then frozenFlingers[part].connection:Disconnect() end
                if frozenFlingers[part].weld then frozenFlingers[part].weld:Destroy() end
                if frozenFlingers[part].anchorPart then frozenFlingers[part].anchorPart:Destroy() end
                frozenFlingers[part] = nil
            end
            
            -- Clean up any existing Sentinel data
            if sentinelParts[part] then
                if sentinelParts[part].connection then sentinelParts[part].connection:Disconnect() end
                if sentinelParts[part].bodyPosition then sentinelParts[part].bodyPosition:Destroy() end
                if sentinelParts[part].bodyGyro then sentinelParts[part].bodyGyro:Destroy() end
                if sentinelParts[part].attachment then sentinelParts[part].attachment:Destroy() end
                if sentinelParts[part].vectorForce then sentinelParts[part].vectorForce:Destroy() end
            end
            
            -- Remove any lingering BodyMovers that might cause issues
            for _, child in ipairs(part:GetChildren()) do
                if child:IsA("BodyMover") or child:IsA("BodyGyro") or child:IsA("BodyPosition") or 
                   child:IsA("BodyVelocity") or child:IsA("BodyAngularVelocity") or 
                   child:IsA("BodyForce") or child:IsA("BodyThrust") then
                    child:Destroy()
                end
            end
            
            -- Reset velocities
            part.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
            part.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
            
            -- Create NEW physics objects for Sentinel
            local bodyPosition = Instance.new("BodyPosition")
            bodyPosition.MaxForce = Vector3.new(100, 100, 100) -- Lower force for Realistic mode
            bodyPosition.Position = part.Position
            bodyPosition.D = 500
            bodyPosition.P = 2000
            bodyPosition.Parent = part
            
            local bodyGyro = Instance.new("BodyGyro")
            bodyGyro.MaxTorque = Vector3.new(5000, 5000, 5000)
            bodyGyro.D = 500
            bodyGyro.P = 3000
            bodyGyro.Parent = part
            
            local attachment = Instance.new("Attachment")
            attachment.Parent = part
            
            local vectorForce = Instance.new("VectorForce")
            vectorForce.Attachment0 = attachment
            vectorForce.ApplyAtCenterOfMass = true
            vectorForce.RelativeTo = Enum.ActuatorRelativeTo.World
            vectorForce.Force = Vector3.new(0, part.Mass * workspace.Gravity, 0)
            vectorForce.Parent = part
            
            -- Sentinel state
            local state = {
                targetPos = part.Position,
                currentAngle = 0,
                aggro = 0,
                maxAggro = 100,
                isJumping = false,
                jumpCooldown = 0,
                spinSpeed = 0,
                wanderTimer = 0,
                wanderCooldown = math.random(2, 5),
                isFlying = flightEnabled,
                pivotOffset = Vector3.new(0, 0, 0),
                targetEnemy = nil,
                idleTime = 0,
                speed = speed,
                displayName = displayName,
                chatTimer = 0,
                chatCooldown = math.random(5, 15),
                fightChallengeTimer = 0,
                isInFight = false,
                fightTarget = nil,
                health = 100,
                maxHealth = 100,
                weapons = {weapon1, weapon2, weapon3},
                currentWeapon = 1,
                tf2Class = tf2Class,
                isTF2Mode = tf2ModeEnabled
            }
            
            -- Visual indicator for team with chat bubble
            local billboard = Instance.new("BillboardGui")
            billboard.Size = UDim2.new(0, 100, 0, 80)
            billboard.Adornee = part
            billboard.AlwaysOnTop = true
            billboard.Parent = part
            
            local chatBubble = Instance.new("Frame")
            chatBubble.Size = UDim2.new(1, 0, 0, 25)
            chatBubble.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
            chatBubble.BackgroundTransparency = 0.2
            chatBubble.BorderSizePixel = 0
            chatBubble.Visible = false
            chatBubble.Parent = billboard
            
            local chatCorner = Instance.new("UICorner")
            chatCorner.CornerRadius = UDim.new(0, 8)
            chatCorner.Parent = chatBubble
            
            local chatLabel = Instance.new("TextLabel")
            chatLabel.Size = UDim2.new(1, -10, 1, -5)
            chatLabel.Position = UDim2.new(0, 5, 0, 2)
            chatLabel.BackgroundTransparency = 1
            chatLabel.Text = ""
            chatLabel.TextColor3 = Color3.fromRGB(0, 0, 0)
            chatLabel.TextSize = 10
            chatLabel.Font = Enum.Font.Gotham
            chatLabel.TextWrapped = true
            chatLabel.Parent = chatBubble
            
            -- Team color and display name
            local teamColor = Color3.fromRGB(255, 255, 255)
            local displayText = "ðŸ¤– " .. displayName
            
            if tf2ModeEnabled and tf2Class ~= "None" then
                -- TF2 Mode - Show class with team color
                if team == "RED" then
                    teamColor = Color3.fromRGB(255, 100, 100)
                elseif team == "BLU" then
                    teamColor = Color3.fromRGB(100, 100, 255)
                end
                
                -- Color the part itself
                if tf2Classes[tf2Class] then
                    part.Color = tf2Classes[tf2Class].color
                end
                
                displayText = team .. " " .. tf2Class
            end
            
            local teamLabel = Instance.new("TextLabel")
            teamLabel.Size = UDim2.new(1, 0, 0, 20)
            teamLabel.Position = UDim2.new(0, 0, 0, 30)
            teamLabel.BackgroundTransparency = 1
            teamLabel.Text = displayText
            teamLabel.TextColor3 = teamColor
            teamLabel.TextSize = 14
            teamLabel.Font = Enum.Font.GothamBold
            teamLabel.TextStrokeTransparency = 0.5
            teamLabel.Visible = sentinelDisplayToggle
            teamLabel.Parent = billboard
            
            local behaviorLabel = Instance.new("TextLabel")
            behaviorLabel.Size = UDim2.new(1, 0, 0, 15)
            behaviorLabel.Position = UDim2.new(0, 0, 0, 50)
            behaviorLabel.BackgroundTransparency = 1
            
            if tf2ModeEnabled and tf2Class ~= "None" then
                behaviorLabel.Text = "HP: " .. state.health .. " | " .. weapon1
            else
                behaviorLabel.Text = "[" .. team .. "] " .. behavior .. " [" .. weapon1 .. "]"
            end
            
            behaviorLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
            behaviorLabel.TextSize = 10
            behaviorLabel.Font = Enum.Font.Gotham
            behaviorLabel.TextStrokeTransparency = 0.5
            behaviorLabel.Visible = sentinelDisplayToggle
            behaviorLabel.Parent = billboard
            
            local healthBar = Instance.new("Frame")
            healthBar.Size = UDim2.new(1, 0, 0, 5)
            healthBar.Position = UDim2.new(0, 0, 0, 68)
            healthBar.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
            healthBar.BorderSizePixel = 0
            healthBar.Visible = sentinelDisplayToggle
            healthBar.Parent = billboard
            
            local healthFill = Instance.new("Frame")
            healthFill.Size = UDim2.new(1, 0, 1, 0)
            healthFill.BackgroundColor3 = Color3.fromRGB(50, 200, 50)
            healthFill.BorderSizePixel = 0
            healthFill.Parent = healthBar
            
            -- Helper function to show chat
            local function showChat(message, duration)
                duration = duration or 3
                chatLabel.Text = message
                chatBubble.Visible = true
                task.delay(duration, function()
                    if chatBubble and chatBubble.Parent then
                        chatBubble.Visible = false
                    end
                end)
            end
            
            -- Helper function to generate REAL AI chat using Google Gemini API
            local function generateChat(context)
                -- Check if HTTP is enabled
                if not game:GetService("HttpService").HttpEnabled then
                    local fallbacks = {
                        idle = {"Hello!", "Nice day!", "Hmm...", "What's up?", "..."},
                        fight = {"Let's fight!", "Come at me!", "Ready?", "Bring it!", "Fight me!"},
                        victory = {"I won!", "Too easy!", "GG!", "Victory!", "Nice try!"},
                        defeat = {"Oof...", "I lost...", "GG...", "You win...", "Nooo!"},
                        peace = {"Let's be friends!", "Peace?", "Team up?", "Truce?", "Alliance?"},
                        curious = {"What's that?", "Interesting...", "I wonder...", "Hmm?", "Cool!"},
                        challenge = {"Wanna fight?", "1v1?", "Fight me!", "Challenge!", "You vs me?"},
                        reject = {"Nah", "No thanks", "Maybe later", "Not now", "Pass"},
                        follow = {"Coming!", "Wait up!", "I'll follow!", "Lead the way!", "Right behind you!"},
                        avoid = {"Stay back!", "Don't come closer!", "Leave me alone!", "Go away!", "Not interested!"}
                    }
                    return fallbacks[context] and fallbacks[context][math.random(1, #fallbacks[context])] or "..."
                end
                
                -- Check if API key is set
                if not _G.GoogleAPIKey or _G.GoogleAPIKey == "" then
                    local fallbacks = {
                        idle = {"Hello!", "Nice day!", "Hmm...", "What's up?", "..."},
                        fight = {"Let's fight!", "Come at me!", "Ready?", "Bring it!", "Fight me!"},
                        victory = {"I won!", "Too easy!", "GG!", "Victory!", "Nice try!"},
                        defeat = {"Oof...", "I lost...", "GG...", "You win...", "Nooo!"},
                        peace = {"Let's be friends!", "Peace?", "Team up?", "Truce?", "Alliance?"},
                        curious = {"What's that?", "Interesting...", "I wonder...", "Hmm?", "Cool!"},
                        challenge = {"Wanna fight?", "1v1?", "Fight me!", "Challenge!", "You vs me?"},
                        reject = {"Nah", "No thanks", "Maybe later", "Not now", "Pass"},
                        follow = {"Coming!", "Wait up!", "I'll follow!", "Lead the way!", "Right behind you!"},
                        avoid = {"Stay back!", "Don't come closer!", "Leave me alone!", "Go away!", "Not interested!"}
                    }
                    return fallbacks[context] and fallbacks[context][math.random(1, #fallbacks[context])] or "..."
                end
                
                -- Check if we've tested API yet
                if _G.GeminiAPIWorking == false then
                    local fallbacks = {
                        idle = {"Hey there!", "Sup!", "Hello world!", "Greetings!", "Hi!"},
                        fight = {"FIGHT ME!", "Let's GO!", "Come on!", "Bring it!", "BATTLE!"},
                        victory = {"VICTORY!", "I win!", "Too easy!", "GG!", "YESS!"},
                        defeat = {"Noooo!", "I lost...", "Dang it!", "Oof!", "GG..."},
                        peace = {"Friends?", "Let's team!", "Truce!", "Alliance?", "Peace!"},
                        curious = {"Wow!", "Interesting!", "What's this?", "Ooh!", "Cool!"},
                        challenge = {"Fight me?", "1v1 bro?", "Wanna go?", "Let's battle!", "Challenge!"},
                        reject = {"Nah", "Maybe later", "No thanks", "Pass", "Not now"},
                        follow = {"Coming!", "Wait up!", "Following you!", "Lead on!", "Behind you!"},
                        avoid = {"Back off!", "Stay away!", "Don't follow me!", "Leave me!", "No way!"}
                    }
                    return fallbacks[context] and fallbacks[context][math.random(1, #fallbacks[context])] or "..."
                end
                
                -- Try REAL Google Gemini API
                local success, result = pcall(function()
                    local HttpService = game:GetService("HttpService")
                    
                    local prompt = ""
                    if context == "idle" then
                        prompt = "You are a friendly AI robot. Say ONE short sentence (5-8 words max) as a casual greeting. Just the sentence, nothing else."
                    elseif context == "fight" then
                        prompt = "You are a battle robot. Say ONE short battle cry (3-6 words). Just the cry, nothing else."
                    elseif context == "victory" then
                        prompt = "You just won! Say ONE short victory phrase (3-5 words). Just the phrase, nothing else."
                    elseif context == "defeat" then
                        prompt = "You just lost. Say ONE short defeat reaction (3-5 words). Just the reaction, nothing else."
                    elseif context == "peace" then
                        prompt = "You want to be friends. Say ONE short friendly phrase (3-6 words). Just the phrase, nothing else."
                    elseif context == "curious" then
                        prompt = "You found something cool. Say ONE short curious phrase (3-5 words). Just the phrase, nothing else."
                    elseif context == "challenge" then
                        prompt = "Challenge someone to fight. Say ONE short challenge (3-5 words). Just the challenge, nothing else."
                    elseif context == "reject" then
                        prompt = "Decline politely. Say ONE short rejection (2-4 words). Just the rejection, nothing else."
                    elseif context == "follow" then
                        prompt = "You will follow someone. Say ONE short phrase (3-5 words). Just the phrase, nothing else."
                    elseif context == "avoid" then
                        prompt = "You want someone to leave. Say ONE short phrase (3-5 words). Just the phrase, nothing else."
                    end
                    
                    local url = "https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=" .. _G.GoogleAPIKey
                    
                    local requestBody = HttpService:JSONEncode({
                        contents = {{
                            parts = {{
                                text = prompt
                            }}
                        }},
                        generationConfig = {
                            maxOutputTokens = 15,
                            temperature = 0.95,
                            topP = 1,
                            topK = 40
                        }
                    })
                    
                    local response = HttpService:PostAsync(url, requestBody, Enum.HttpContentType.ApplicationJson, false)
                    local data = HttpService:JSONDecode(response)
                    
                    if data.candidates and data.candidates[1] and data.candidates[1].content and data.candidates[1].content.parts and data.candidates[1].content.parts[1] then
                        local text = data.candidates[1].content.parts[1].text
                        text = text:gsub('"', ''):gsub("'", ""):gsub("\n", " ")
                        text = text:match("^%s*(.-)%s*$")
                        if #text > 40 then text = text:sub(1, 40) end
                        
                        if _G.GeminiAPIWorking == nil then
                            _G.GeminiAPIWorking = true
                            print("âœ… Google Gemini AI is working! Sentinels now have REAL AI chat!")
                        end
                        
                        return text
                    else
                        error("Invalid API response structure")
                    end
                end)
                
                if success and result and result ~= "" then
                    return result
                else
                    if _G.GeminiAPIWorking == nil then
                        _G.GeminiAPIWorking = false
                        warn("âŒ Google Gemini API failed. Using preset messages.")
                    end
                    
                    local fallbacks = {
                        idle = {"Hey there!", "Sup!", "Hello world!", "Greetings!", "Hi!"},
                        fight = {"FIGHT ME!", "Let's GO!", "Come on!", "Bring it!", "BATTLE!"},
                        victory = {"VICTORY!", "I win!", "Too easy!", "GG!", "YESS!"},
                        defeat = {"Noooo!", "I lost...", "Dang it!", "Oof!", "GG..."},
                        peace = {"Friends?", "Let's team!", "Truce!", "Alliance?", "Peace!"},
                        curious = {"Wow!", "Interesting!", "What's this?", "Ooh!", "Cool!"},
                        challenge = {"Fight me?", "1v1 bro?", "Wanna go?", "Let's battle!", "Challenge!"},
                        reject = {"Nah", "Maybe later", "No thanks", "Pass", "Not now"},
                        follow = {"Coming!", "Wait up!", "Following you!", "Lead on!", "Behind you!"},
                        avoid = {"Back off!", "Stay away!", "Don't follow me!", "Leave me!", "No way!"}
                    }
                    return fallbacks[context] and fallbacks[context][math.random(1, #fallbacks[context])] or "..."
                end
            end
            
            -- Helper function to merge team names using Google API
            local function mergeTeamNames(team1, team2)
                if not _G.GoogleAPIKey or _G.GoogleAPIKey == "" then
                    -- Fallback: Simple merge
                    local hash = 0
                    for i = 1, #team1 do hash = hash + string.byte(team1, i) end
                    for i = 1, #team2 do hash = hash + string.byte(team2, i) end
                    math.randomseed(hash)
                    
                    local prefixes = {"New", "United", "Super", "Mega", "Epic", "Cool"}
                    local suffixes = {"Team", "Squad", "Crew", "Gang", "Alliance"}
                    return prefixes[math.random(1, #prefixes)] .. suffixes[math.random(1, #suffixes)]
                end
                
                -- Use Google API to create creative merge
                local success, result = pcall(function()
                    local hash = 0
                    for i = 1, #team1 do hash = hash + string.byte(team1, i) end
                    for i = 1, #team2 do hash = hash + string.byte(team2, i) end
                    math.randomseed(hash)
                    
                    -- Extract parts from both names
                    local part1 = team1:sub(1, math.ceil(#team1/2))
                    local part2 = team2:sub(math.ceil(#team2/2))
                    
                    -- Replace some letters with numbers
                    local merged = part1 .. part2
                    merged = merged:gsub("e", math.random() > 0.5 and "3" or "e")
                    merged = merged:gsub("a", math.random() > 0.5 and "4" or "a")
                    merged = merged:gsub("o", math.random() > 0.5 and "0" or "o")
                    merged = merged:gsub("i", math.random() > 0.5 and "1" or "i")
                    merged = merged:gsub("s", math.random() > 0.5 and "5" or "s")
                    
                    return merged:lower()
                end)
                
                if success and result then
                    return result
                else
                    return "NewTeam"
                end
            end
            
            -- Helper function to teleport to void
            local function teleportToVoid(targetPart)
                if targetPart and targetPart.Parent then
                    replicateToServer(function()
                        setNetworkOwnership(targetPart)
                        local voidPos = Vector3.new(0, -1000000, 0)
                        targetPart.CFrame = CFrame.new(voidPos)
                        targetPart.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                        targetPart.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                        print("ðŸ’€ " .. (sentinelParts[targetPart] and sentinelParts[targetPart].state.displayName or "Unknown") .. " was sent to the void!")
                    end)
                end
            end
            
            -- Helper functions
            local function findNearestPlayer()
                local nearest = nil
                local nearestDist = math.huge
                
                for _, plr in ipairs(Players:GetPlayers()) do
                    if plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
                        local hrp = plr.Character.HumanoidRootPart
                        local dist = (hrp.Position - part.Position).Magnitude
                        
                        if dist < nearestDist then
                            nearestDist = dist
                            nearest = hrp
                        end
                    end
                end
                
                return nearest, nearestDist
            end
            
            local function findNearestEnemy()
                local nearest = nil
                local nearestDist = math.huge
                
                for otherPart, otherData in pairs(sentinelParts) do
                    if otherPart ~= part and otherData.team ~= team and otherPart.Parent then
                        local dist = (otherPart.Position - part.Position).Magnitude
                        if dist < nearestDist then
                            nearestDist = dist
                            nearest = otherPart
                        end
                    end
                end
                
                return nearest, nearestDist
            end
            
            local function findNearestSameTeam()
                local nearest = nil
                local nearestDist = math.huge
                
                for otherPart, otherData in pairs(sentinelParts) do
                    if otherPart ~= part and otherData.team == team and otherPart.Parent then
                        local dist = (otherPart.Position - part.Position).Magnitude
                        if dist < nearestDist then
                            nearestDist = dist
                            nearest = otherPart
                        end
                    end
                end
                
                return nearest, nearestDist
            end
            
            local function makePeace(otherPart)
                if not sentinelParts[otherPart] then return end
                
                -- TF2 Mode - NO PEACE ALLOWED! RED vs BLU forever!
                if tf2ModeEnabled and state.isTF2Mode then
                    if sentinelTalkingEnabled then
                        showChat("No mercy for " .. (team == "RED" and "BLU" or "RED") .. "!", 2)
                    end
                    return
                end
                
                local otherData = sentinelParts[otherPart]
                local newTeamName = mergeTeamNames(team, otherData.team)
                
                -- IMPORTANT: Reset both parts' velocities when teaming up
                part.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                part.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                otherPart.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                otherPart.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                
                -- Update both sentinels to new team
                team = newTeamName
                otherData.team = newTeamName
                state.displayName = newTeamName
                otherData.state.displayName = newTeamName
                
                -- Reset fight states
                state.isInFight = false
                state.fightTarget = nil
                state.targetEnemy = nil
                otherData.state.isInFight = false
                otherData.state.fightTarget = nil
                otherData.state.targetEnemy = nil
                
                -- Update visuals
                behaviorLabel.Text = "[" .. newTeamName .. "] " .. behavior
                if otherData.billboard then
                    local otherBehaviorLabel = otherData.billboard:FindFirstChild("TextLabel")
                    if otherBehaviorLabel then
                        otherBehaviorLabel.Text = "[" .. newTeamName .. "] " .. otherData.behavior
                    end
                end
                
                -- Update team lists
                if not sentinelTeams[newTeamName] then
                    sentinelTeams[newTeamName] = {}
                end
                table.insert(sentinelTeams[newTeamName], part)
                table.insert(sentinelTeams[newTeamName], otherPart)
                
                showChat("We are " .. newTeamName .. " now!", 4)
                if otherData.billboard then
                    local otherChatBubble = otherData.billboard:FindFirstChild("Frame")
                    if otherChatBubble then
                        local otherChatLabel = otherChatBubble:FindFirstChild("TextLabel")
                        if otherChatLabel then
                            otherChatLabel.Text = "Yes! " .. newTeamName .. "!"
                            otherChatBubble.Visible = true
                            task.delay(4, function()
                                if otherChatBubble and otherChatBubble.Parent then
                                    otherChatBubble.Visible = false
                                end
                            end)
                        end
                    end
                end
                
                print("ðŸ¤ " .. state.displayName .. " and " .. otherData.state.displayName .. " made peace! New team: " .. newTeamName)
            end
            
            local function attackTarget(target)
                if target and target.Parent then
                    -- Apply damage force (reduced to prevent excessive flinging)
                    local direction = (target.Position - part.Position).Unit
                    local impulse = direction * part.Mass * 25 -- Reduced from 50
                    part:ApplyImpulse(impulse)
                    
                    if target:IsA("BasePart") and sentinelParts[target] then
                        local targetData = sentinelParts[target]
                        targetData.state.health = math.max(0, targetData.state.health - 10)
                        
                        -- Update health bar
                        if targetData.billboard then
                            local hBar = targetData.billboard:FindFirstChild("Frame", true)
                            if hBar and hBar:FindFirstChild("Frame") then
                                local hFill = hBar:FindFirstChild("Frame")
                                hFill.Size = UDim2.new(targetData.state.health / targetData.state.maxHealth, 0, 1, 0)
                                
                                -- Color based on health
                                if targetData.state.health < 30 then
                                    hFill.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
                                elseif targetData.state.health < 60 then
                                    hFill.BackgroundColor3 = Color3.fromRGB(200, 200, 50)
                                else
                                    hFill.BackgroundColor3 = Color3.fromRGB(50, 200, 50)
                                end
                            end
                        end
                        
                        -- Check if target died
                        if targetData.state.health <= 0 then
                            showChat(generateChat("victory"), 3)
                            if targetData.billboard then
                                local tChatBubble = targetData.billboard:FindFirstChild("Frame")
                                if tChatBubble then
                                    local tChatLabel = tChatBubble:FindFirstChild("TextLabel")
                                    if tChatLabel then
                                        tChatLabel.Text = generateChat("defeat")
                                        tChatBubble.Visible = true
                                    end
                                end
                            end
                            teleportToVoid(target)
                        end
                        
                        -- Reduced counter impulse
                        local counterImpulse = direction * target.Mass * 15 -- Reduced from 30
                        target:ApplyImpulse(counterImpulse)
                    end
                end
            end
            
            -- Main behavior loop
            local connection = RunService.Heartbeat:Connect(function(dt)
                if not part.Parent then
                    connection:Disconnect()
                    return
                end
                
                state.jumpCooldown = math.max(0, state.jumpCooldown - dt)
                state.wanderTimer = state.wanderTimer + dt
                state.idleTime = state.idleTime + dt
                state.chatTimer = state.chatTimer + dt
                state.fightChallengeTimer = state.fightChallengeTimer + dt
                
                -- Random chat (to players and other sentinels)
                if state.chatTimer >= state.chatCooldown then
                    if sentinelTalkingEnabled then
                        local context = "idle"
                        if state.isInFight then
                            context = "fight"
                        elseif behavior == "Curious" then
                            context = "curious"
                        elseif behavior == "Follow People" then
                            context = "follow"
                        elseif behavior == "Avoid People" then
                            context = "avoid"
                        end
                        
                        -- Check for nearby sentinels to chat with
                        local nearbySentinel = nil
                        local nearestSentinelDist = math.huge
                        for otherPart, otherData in pairs(sentinelParts) do
                            if otherPart ~= part and otherPart.Parent then
                                local dist = (otherPart.Position - part.Position).Magnitude
                                if dist < 20 and dist < nearestSentinelDist then
                                    nearestSentinelDist = dist
                                    nearbySentinel = otherPart
                                end
                            end
                        end
                        
                        -- Generate chat based on situation
                        local chatMessage = generateChat(context)
                        showChat(chatMessage, 3)
                        
                        -- If there's a nearby sentinel, make them respond
                        if nearbySentinel and sentinelParts[nearbySentinel] then
                            task.delay(math.random(1, 2), function()
                                if nearbySentinel.Parent and sentinelParts[nearbySentinel] then
                                    local otherData = sentinelParts[nearbySentinel]
                                    local responseContext = "idle"
                                    
                                    -- Determine response based on relationship
                                    if otherData.team == team then
                                        -- Same team - friendly response
                                        if context == "fight" then
                                            responseContext = "fight" -- Join the hype
                                        elseif context == "peace" then
                                            responseContext = "peace"
                                        else
                                            responseContext = "idle" -- Casual chat
                                        end
                                    else
                                        -- Different team - depends on behavior
                                        if otherData.behavior == "Fighter" then
                                            responseContext = math.random() > 0.5 and "challenge" or "reject"
                                        elseif otherData.behavior == "Friendly" then
                                            responseContext = "peace"
                                        else
                                            responseContext = math.random() > 0.5 and "idle" or "curious"
                                        end
                                    end
                                    
                                    -- Show response chat
                                    if otherData.billboard then
                                        local otherChatBubble = otherData.billboard:FindFirstChild("Frame")
                                        if otherChatBubble then
                                            local otherChatLabel = otherChatBubble:FindFirstChild("TextLabel")
                                            if otherChatLabel then
                                                otherChatLabel.Text = generateChat(responseContext)
                                                otherChatBubble.Visible = true
                                                task.delay(3, function()
                                                    if otherChatBubble and otherChatBubble.Parent then
                                                        otherChatBubble.Visible = false
                                                    end
                                                end)
                                            end
                                        end
                                    end
                                end
                            end)
                        end
                    end
                    state.chatTimer = 0
                    state.chatCooldown = math.random(8, 20)
                end
                
                -- Get nearest player
                local nearestPlayer, playerDist = findNearestPlayer()
                
                -- Behavior logic
                if behavior == "Friendly" then
                    if nearestPlayer and playerDist < 50 then
                        state.targetPos = nearestPlayer.Position + Vector3.new(math.random(-5, 5), 0, math.random(-5, 5))
                        state.spinSpeed = 2
                    elseif state.wanderTimer > state.wanderCooldown then
                        state.targetPos = part.Position + Vector3.new(math.random(-20, 20), 0, math.random(-20, 20))
                        state.wanderTimer = 0
                        state.wanderCooldown = math.random(3, 6)
                    end
                    
                    -- Occasionally try to make peace
                    if math.random() < 0.005 then
                        local enemy = findNearestEnemy()
                        if enemy and sentinelTalkingEnabled then
                            showChat(generateChat("peace"), 3)
                            if math.random() > 0.3 then
                                makePeace(enemy)
                            end
                        end
                    end
                    
                elseif behavior == "Follow People" then
                    if nearestPlayer and playerDist < 100 then
                        state.targetPos = nearestPlayer.Position + Vector3.new(math.random(-3, 3), 0, math.random(-3, 3))
                        state.spinSpeed = 1
                        
                        if playerDist < 10 and state.chatTimer >= state.chatCooldown then
                            if sentinelTalkingEnabled then
                                showChat(generateChat("follow"), 2)
                            end
                            state.chatTimer = 0
                            state.chatCooldown = math.random(10, 20)
                        end
                    else
                        if state.wanderTimer > state.wanderCooldown then
                            state.targetPos = part.Position + Vector3.new(math.random(-15, 15), 0, math.random(-15, 15))
                            state.wanderTimer = 0
                            state.wanderCooldown = math.random(3, 6)
                        end
                    end
                    
                elseif behavior == "Avoid People" then
                    if nearestPlayer and playerDist < 30 then
                        local fleeDir = (part.Position - nearestPlayer.Position).Unit
                        state.targetPos = part.Position + fleeDir * 20
                        state.spinSpeed = 3
                        
                        if playerDist < 15 and state.chatTimer >= state.chatCooldown then
                            if sentinelTalkingEnabled then
                                showChat(generateChat("avoid"), 2)
                            end
                            state.chatTimer = 0
                            state.chatCooldown = math.random(8, 15)
                        end
                    else
                        if state.wanderTimer > state.wanderCooldown then
                            state.targetPos = part.Position + Vector3.new(math.random(-20, 20), 0, math.random(-20, 20))
                            state.wanderTimer = 0
                            state.wanderCooldown = math.random(3, 6)
                        end
                    end
                    
                elseif behavior == "Fighter" then
                    local enemy, enemyDist = findNearestEnemy()
                    
                    if enemy then
                        state.targetEnemy = enemy
                        state.targetPos = enemy.Position
                        state.isInFight = true
                        
                        -- Challenge to fight
                        if not state.fightTarget and state.fightChallengeTimer > 5 then
                            state.fightChallengeTimer = 0
                            if sentinelTalkingEnabled then
                                showChat(generateChat("challenge"), 2)
                            end
                            
                            -- 51% accept, 49% reject
                            if math.random() < 0.51 then
                                state.fightTarget = enemy
                                state.spinSpeed = 10
                            else
                                if sentinelTalkingEnabled then
                                    showChat(generateChat("reject"), 2)
                                end
                                state.targetPos = part.Position + Vector3.new(math.random(-15, 15), 0, math.random(-15, 15))
                                state.fightTarget = nil
                            end
                        end
                        
                        if state.fightTarget == enemy then
                            state.spinSpeed = 10
                            
                            if enemyDist < 15 and state.jumpCooldown <= 0 then
                                state.isJumping = true
                                state.jumpCooldown = 2
                                attackTarget(enemy)
                                if sentinelTalkingEnabled then
                                    showChat(generateChat("fight"), 1)
                                end
                            end
                        end
                    else
                        state.isInFight = false
                        state.fightTarget = nil
                        state.spinSpeed = 1
                        
                        if state.wanderTimer > state.wanderCooldown then
                            state.targetPos = part.Position + Vector3.new(math.random(-15, 15), 0, math.random(-15, 15))
                            state.wanderTimer = 0
                            state.wanderCooldown = math.random(2, 4)
                        end
                    end
                    
                elseif behavior == "Curious" then
                    -- Explore and investigate
                    if state.wanderTimer > state.wanderCooldown then
                        state.targetPos = part.Position + Vector3.new(math.random(-30, 30), flightEnabled and math.random(0, 15) or 0, math.random(-30, 30))
                        state.wanderTimer = 0
                        state.wanderCooldown = math.random(2, 5)
                        state.spinSpeed = math.random(0, 4)
                        
                        if math.random() < 0.3 and sentinelTalkingEnabled then
                            showChat(generateChat("curious"), 3)
                        end
                    end
                    
                    -- Sometimes make peace
                    if math.random() < 0.003 then
                        local enemy = findNearestEnemy()
                        if enemy and sentinelTalkingEnabled then
                            showChat(generateChat("peace"), 3)
                            
                            -- Make enemy respond
                            if sentinelParts[enemy] then
                                task.delay(1, function()
                                    if enemy.Parent and sentinelParts[enemy] then
                                        local enemyData = sentinelParts[enemy]
                                        local accept = math.random() > 0.5
                                        
                                        if enemyData.billboard then
                                            local enemyChatBubble = enemyData.billboard:FindFirstChild("Frame")
                                            if enemyChatBubble then
                                                local enemyChatLabel = enemyChatBubble:FindFirstChild("TextLabel")
                                                if enemyChatLabel then
                                                    enemyChatLabel.Text = generateChat(accept and "peace" or "reject")
                                                    enemyChatBubble.Visible = true
                                                    task.delay(3, function()
                                                        if enemyChatBubble and enemyChatBubble.Parent then
                                                            enemyChatBubble.Visible = false
                                                        end
                                                    end)
                                                end
                                            end
                                        end
                                        
                                        if accept then
                                            makePeace(enemy)
                                        end
                                    end
                                end)
                            end
                        end
                    end
                    
                    -- Rarely fight
                    if math.random() < 0.001 then
                        local enemy, enemyDist = findNearestEnemy()
                        if enemy and enemyDist < 20 and sentinelTalkingEnabled then
                            showChat(generateChat("challenge"), 2)
                            
                            -- Make enemy respond
                            if sentinelParts[enemy] then
                                task.delay(1, function()
                                    if enemy.Parent and sentinelParts[enemy] then
                                        local enemyData = sentinelParts[enemy]
                                        local accept = math.random() < 0.51
                                        
                                        if enemyData.billboard then
                                            local enemyChatBubble = enemyData.billboard:FindFirstChild("Frame")
                                            if enemyChatBubble then
                                                local enemyChatLabel = enemyChatBubble:FindFirstChild("TextLabel")
                                                if enemyChatLabel then
                                                    enemyChatLabel.Text = generateChat(accept and "fight" or "reject")
                                                    enemyChatBubble.Visible = true
                                                    task.delay(2, function()
                                                        if enemyChatBubble and enemyChatBubble.Parent then
                                                            enemyChatBubble.Visible = false
                                                        end
                                                    end)
                                                end
                                            end
                                        end
                                    end
                                end)
                            end
                            
                            if math.random() < 0.51 then
                                state.targetPos = enemy.Position
                                state.isInFight = true
                                state.fightTarget = enemy
                            else
                                showChat(generateChat("reject"), 2)
                            end
                        end
                    end
                    
                elseif behavior == "Bird" then
                    state.isFlying = true
                    
                    if nearestPlayer and playerDist < 40 then
                        local fleeDir = (part.Position - nearestPlayer.Position).Unit
                        state.targetPos = part.Position + fleeDir * 20 + Vector3.new(0, 10, 0)
                    elseif state.wanderTimer > state.wanderCooldown then
                        state.targetPos = part.Position + Vector3.new(math.random(-30, 30), math.random(5, 20), math.random(-30, 30))
                        state.wanderTimer = 0
                        state.wanderCooldown = math.random(2, 5)
                    end
                    
                    state.spinSpeed = 0.5
                    
                elseif behavior == "Wanderer" then
                    if state.wanderTimer > state.wanderCooldown then
                        state.targetPos = part.Position + Vector3.new(math.random(-25, 25), 0, math.random(-25, 25))
                        state.wanderTimer = 0
                        state.wanderCooldown = math.random(3, 7)
                        state.spinSpeed = math.random(0, 3)
                    end
                    
                    if math.random() < 0.01 and state.jumpCooldown <= 0 then
                        state.isJumping = true
                        state.jumpCooldown = 3
                    end
                    
                elseif behavior == "FightStopper" then
                    local enemy, enemyDist = findNearestEnemy()
                    
                    if enemy and enemyDist < 40 then
                        if math.random() < 0.5 then
                            -- Try to stop the fight with peace
                            state.targetPos = enemy.Position + Vector3.new(math.random(-5, 5), 0, math.random(-5, 5))
                            state.spinSpeed = 1
                            
                            if enemyDist < 10 then
                                if sentinelTalkingEnabled then
                                    showChat(generateChat("peace"), 2)
                                    
                                    -- Make enemy respond
                                    if sentinelParts[enemy] then
                                        task.delay(1, function()
                                            if enemy.Parent and sentinelParts[enemy] then
                                                local enemyData = sentinelParts[enemy]
                                                local accept = math.random() > 0.6
                                                
                                                if enemyData.billboard then
                                                    local enemyChatBubble = enemyData.billboard:FindFirstChild("Frame")
                                                    if enemyChatBubble then
                                                        local enemyChatLabel = enemyChatBubble:FindFirstChild("TextLabel")
                                                        if enemyChatLabel then
                                                            enemyChatLabel.Text = generateChat(accept and "peace" or "fight")
                                                            enemyChatBubble.Visible = true
                                                            task.delay(2, function()
                                                                if enemyChatBubble and enemyChatBubble.Parent then
                                                                    enemyChatBubble.Visible = false
                                                                end
                                                            end)
                                                        end
                                                    end
                                                end
                                            end
                                        end)
                                    end
                                end
                                if math.random() > 0.6 then
                                    makePeace(enemy)
                                else
                                    local pushDir = (enemy.Position - part.Position).Unit
                                    local pushForce = pushDir * part.Mass * 20
                                    part:ApplyImpulse(-pushForce)
                                end
                            end
                        else
                            -- Make it worse!
                            state.targetPos = enemy.Position
                            state.spinSpeed = 5
                            
                            if enemyDist < 15 and state.jumpCooldown <= 0 then
                                if sentinelTalkingEnabled then
                                    showChat(generateChat("fight"), 1)
                                end
                                attackTarget(enemy)
                                state.jumpCooldown = 2
                            end
                        end
                    else
                        if state.wanderTimer > state.wanderCooldown then
                            state.targetPos = part.Position + Vector3.new(math.random(-20, 20), 0, math.random(-20, 20))
                            state.wanderTimer = 0
                            state.wanderCooldown = math.random(2, 4)
                        end
                    end
                end
                
                -- Movement execution with smooth walking and jumping
                local targetY = state.isFlying and state.targetPos.Y or part.Position.Y
                local moveTarget = Vector3.new(state.targetPos.X, targetY, state.targetPos.Z)
                
                -- SMOOTH JUMPING PHYSICS
                if state.isJumping then
                    -- Apply realistic jump force
                    local jumpForce = Vector3.new(0, part.Mass * 50, 0)
                    part:ApplyImpulse(jumpForce)
                    state.isJumping = false
                    
                    -- Allow forward movement during jump
                    local forwardDir = (moveTarget - part.Position).Unit
                    local jumpMoveForce = Vector3.new(forwardDir.X, 0, forwardDir.Z) * part.Mass * 10
                    part:ApplyImpulse(jumpMoveForce)
                end
                
                -- Calculate movement direction for rotation
                local movementDirection = (moveTarget - part.Position).Unit
                local targetCFrame = CFrame.lookAt(part.Position, part.Position + movementDirection)
                
                -- Check if on ground (for realistic walking)
                local isOnGround = false
                local rayOrigin = part.Position
                local rayDirection = Vector3.new(0, -part.Size.Y/2 - 0.5, 0)
                local raycastParams = RaycastParams.new()
                raycastParams.FilterDescendantsInstances = {part}
                raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
                
                local rayResult = workspace:Raycast(rayOrigin, rayDirection, raycastParams)
                if rayResult then
                    isOnGround = true
                end
                
                -- Apply movement mode
                if movementMode == "Realistic" then
                    -- REALISTIC WALKING with smooth acceleration
                    state.currentAngle = state.currentAngle + (state.spinSpeed * dt)
                    
                    -- Rotate to face movement direction smoothly
                    local facingCFrame = CFrame.lookAt(part.Position, part.Position + movementDirection)
                    local targetRotation = facingCFrame * CFrame.Angles(0, math.rad(state.currentAngle * state.spinSpeed), 0)
                    bodyGyro.CFrame = bodyGyro.CFrame:Lerp(targetRotation, dt * 5)
                    
                    if isOnGround then
                        -- WALKING: smooth ground movement with acceleration
                        local currentVelocity = part.AssemblyLinearVelocity
                        local desiredVelocity = movementDirection * state.speed
                        
                        -- Smooth acceleration (not instant)
                        local acceleration = 20 -- studs/secondÂ²
                        local velocityChange = desiredVelocity - Vector3.new(currentVelocity.X, 0, currentVelocity.Z)
                        local maxChange = acceleration * dt
                        
                        if velocityChange.Magnitude > maxChange then
                            velocityChange = velocityChange.Unit * maxChange
                        end
                        
                        -- Apply walking force (keep Y velocity for jumping/falling)
                        local walkForce = Vector3.new(velocityChange.X, 0, velocityChange.Z) * part.Mass
                        part:ApplyImpulse(walkForce)
                        
                        -- Keep grounded (prevent floating)
                        if currentVelocity.Y > 0.5 then
                            local groundForce = Vector3.new(0, -currentVelocity.Y * part.Mass * 2, 0)
                            part:ApplyImpulse(groundForce)
                        end
                        
                        -- Pivot offset for walking animation
                        local sizeX = part.Size.X
                        local offsetMagnitude = sizeX / 2
                        local offsetDir = math.sin(state.currentAngle * 2)
                        state.pivotOffset = Vector3.new(offsetDir * offsetMagnitude, 0, 0)
                    else
                        -- IN AIR: less control, realistic physics
                        local airControl = 0.3 -- reduced control in air
                        local desiredVelocity = movementDirection * state.speed * airControl
                        local currentVelocity = Vector3.new(part.AssemblyLinearVelocity.X, 0, part.AssemblyLinearVelocity.Z)
                        local velocityChange = (desiredVelocity - currentVelocity) * dt * 5
                        
                        local airForce = Vector3.new(velocityChange.X, 0, velocityChange.Z) * part.Mass
                        part:ApplyImpulse(airForce)
                    end
                    
                    -- Cancel BodyPosition interference for realistic physics
                    bodyPosition.Position = part.Position
                    bodyPosition.MaxForce = Vector3.new(100, 100, 100) -- minimal force, just for stability
                    
                else
                    -- Direct movement mode (original behavior)
                    local lerpSpeed = math.min(dt * 2 * (state.speed / 16), 1)
                    bodyPosition.Position = part.Position:Lerp(moveTarget, lerpSpeed)
                    bodyPosition.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                    
                    -- Rotate to face movement direction
                    local facingCFrame = CFrame.lookAt(part.Position, part.Position + movementDirection)
                    
                    if state.spinSpeed > 0 then
                        state.currentAngle = state.currentAngle + (state.spinSpeed * dt * 10)
                        bodyGyro.CFrame = facingCFrame * CFrame.Angles(0, math.rad(state.currentAngle), 0)
                    else
                        bodyGyro.CFrame = facingCFrame
                    end
                end
                
                -- Continuous rotation for visual effect (only in Direct mode)
                if state.spinSpeed > 0 and movementMode ~= "Realistic" then
                    part.AssemblyAngularVelocity = Vector3.new(0, state.spinSpeed, 0)
                end
            end)
            
            sentinelParts[part] = {
                bodyPosition = bodyPosition,
                bodyGyro = bodyGyro,
                attachment = attachment,
                vectorForce = vectorForce,
                connection = connection,
                billboard = billboard,
                chatBubble = chatBubble,
                teamLabel = teamLabel,
                behaviorLabel = behaviorLabel,
                healthBar = healthBar,
                healthFill = healthFill,
                state = state,
                behavior = behavior,
                movementMode = movementMode,
                team = team,
                speed = speed
            }
            
            -- Add to team list
            if not sentinelTeams[team] then
                sentinelTeams[team] = {}
            end
            table.insert(sentinelTeams[team], part)
            
            print("ðŸ¤– Created Sentinel: " .. displayName .. " | Team: " .. team .. " | Behavior: " .. behavior .. " | Speed: " .. speed)
        end)
    end
    
    local function removeSentinel(part)
        if sentinelParts[part] then
            local data = sentinelParts[part]
            if data.connection then data.connection:Disconnect() end
            if data.bodyPosition then data.bodyPosition:Destroy() end
            if data.bodyGyro then data.bodyGyro:Destroy() end
            if data.attachment then data.attachment:Destroy() end
            if data.vectorForce then data.vectorForce:Destroy() end
            if data.billboard then data.billboard:Destroy() end
            
            -- Remove from team
            if sentinelTeams[data.team] then
                for i, p in ipairs(sentinelTeams[data.team]) do
                    if p == part then
                        table.remove(sentinelTeams[data.team], i)
                        break
                    end
                end
            end
            
            sentinelParts[part] = nil
            print("Removed Sentinel from " .. part.Name)
        end
    end
    
    local function getSentinelInfo(part)
        if sentinelParts[part] then
            return sentinelParts[part]
        end
        return nil
    end
    
    local function createSentinelPanel(parent)
        local panel = createPanel(parent, "ðŸ¤– Sentinel", 29)
        panel.Size = UDim2.new(0, 280, 0, 1500)
        
        local infoLabel = Instance.new("TextLabel")
        infoLabel.Size = UDim2.new(1, -20, 0, 25)
        infoLabel.Position = UDim2.new(0, 10, 0, 40)
        infoLabel.BackgroundTransparency = 1
        infoLabel.Text = "Turn parts into living AI sentinels!"
        infoLabel.TextColor3 = Color3.fromRGB(255, 200, 100)
        infoLabel.TextSize = 10
        infoLabel.Font = Enum.Font.GothamBold
        infoLabel.TextWrapped = true
        infoLabel.Parent = panel
        
        -- TF2 Mode Toggle
        local tf2ModeBtn, updateTF2Mode = createToggleButton(panel, "TF2 Mode", UDim2.new(0, 100, 0, 25), UDim2.new(0, 120, 0, 40), tf2ModeEnabled)
        tf2ModeBtn.MouseButton1Click:Connect(function()
            tf2ModeEnabled = not tf2ModeEnabled
            tf2ModeBtn:SetAttribute("ToggleState", tf2ModeEnabled)
            updateTF2Mode(tf2ModeEnabled)
            
            -- Show/hide relevant controls
            if tf2ModeEnabled then
                behaviorDropdown.Visible = false
                teamInput.Visible = false
                teamLabel.Visible = false
                speedInput.Visible = false
                speedLabel.Visible = false
                weapon1Dropdown.Visible = false
                weapon2Dropdown.Visible = false
                weapon3Dropdown.Visible = false
                weaponLabel.Visible = false
                
                tf2ClassDropdown.Visible = true
                tf2ClassLabel.Visible = true
                tf2TeamDropdown.Visible = true
                tf2TeamLabel.Visible = true
                
                infoLabel.Text = "âš”ï¸ Team Fortress 2 Mode Active!\nClasses have set stats & weapons"
            else
                behaviorDropdown.Visible = true
                teamInput.Visible = true
                teamLabel.Visible = true
                speedInput.Visible = true
                speedLabel.Visible = true
                weapon1Dropdown.Visible = true
                weapon2Dropdown.Visible = true
                weapon3Dropdown.Visible = true
                weaponLabel.Visible = true
                
                tf2ClassDropdown.Visible = false
                tf2ClassLabel.Visible = false
                tf2TeamDropdown.Visible = false
                tf2TeamLabel.Visible = false
                
                infoLabel.Text = "Turn parts into living AI sentinels!"
            end
        end)
        
        -- Behavior dropdown
        local behaviorDropdown = createDropdown(panel, {"Friendly", "Fighter", "Bird", "Wanderer", "FightStopper", "Curious", "Follow People", "Avoid People"})
        behaviorDropdown.Position = UDim2.new(0, 10, 0, 70)
        behaviorDropdown.Size = UDim2.new(0, 120, 0, 25)
        
        -- TF2 Class Dropdown (hidden by default)
        local tf2ClassLabel = Instance.new("TextLabel")
        tf2ClassLabel.Size = UDim2.new(0, 100, 0, 20)
        tf2ClassLabel.Position = UDim2.new(0, 10, 0, 70)
        tf2ClassLabel.BackgroundTransparency = 1
        tf2ClassLabel.Text = "ðŸŽ–ï¸ Class:"
        tf2ClassLabel.TextColor3 = Color3.fromRGB(255, 200, 100)
        tf2ClassLabel.TextSize = 11
        tf2ClassLabel.Font = Enum.Font.GothamBold
        tf2ClassLabel.TextXAlignment = Enum.TextXAlignment.Left
        tf2ClassLabel.Visible = false
        tf2ClassLabel.Parent = panel
        
        local tf2ClassDropdown = createDropdown(panel, {"Scout", "Soldier", "Pyro", "Demoman", "Heavy", "Engineer", "Medic", "Sniper", "Spy"})
        tf2ClassDropdown.Position = UDim2.new(0, 70, 0, 70)
        tf2ClassDropdown.Size = UDim2.new(0, 100, 0, 25)
        tf2ClassDropdown.Visible = false
        
        local tf2TeamLabel = Instance.new("TextLabel")
        tf2TeamLabel.Size = UDim2.new(0, 50, 0, 20)
        tf2TeamLabel.Position = UDim2.new(0, 180, 0, 70)
        tf2TeamLabel.BackgroundTransparency = 1
        tf2TeamLabel.Text = "Team:"
        tf2TeamLabel.TextColor3 = Color3.fromRGB(255, 200, 100)
        tf2TeamLabel.TextSize = 11
        tf2TeamLabel.Font = Enum.Font.GothamBold
        tf2TeamLabel.TextXAlignment = Enum.TextXAlignment.Left
        tf2TeamLabel.Visible = false
        tf2TeamLabel.Parent = panel
        
        local tf2TeamDropdown = createDropdown(panel, {"RED", "BLU"})
        tf2TeamDropdown.Position = UDim2.new(0, 225, 0, 70)
        tf2TeamDropdown.Size = UDim2.new(0, 50, 0, 25)
        tf2TeamDropdown.Visible = false
        
        -- Movement mode dropdown
        local movementDropdown = createDropdown(panel, {"Realistic", "Direct"})
        movementDropdown.Position = UDim2.new(0, 140, 0, 70)
        movementDropdown.Size = UDim2.new(0, 80, 0, 25)
        
        -- Flight toggle
        local flightBtn, updateFlight = createToggleButton(panel, "Flight", UDim2.new(0, 50, 0, 25), UDim2.new(0, 10, 0, 100), false)
        flightBtn.MouseButton1Click:Connect(function()
            local state = not flightBtn:GetAttribute("ToggleState")
            flightBtn:SetAttribute("ToggleState", state)
            updateFlight(state)
        end)
        
        -- Speed input
        local speedLabel = Instance.new("TextLabel")
        speedLabel.Size = UDim2.new(0, 40, 0, 25)
        speedLabel.Position = UDim2.new(0, 70, 0, 100)
        speedLabel.BackgroundTransparency = 1
        speedLabel.Text = "Speed:"
        speedLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
        speedLabel.TextSize = 10
        speedLabel.Font = Enum.Font.GothamBold
        speedLabel.TextXAlignment = Enum.TextXAlignment.Left
        speedLabel.Parent = panel
        
        local speedInput = createNumberInput(panel, "1-inf", UDim2.new(0, 115, 0, 100))
        speedInput.Size = UDim2.new(0, 60, 0, 25)
        speedInput.Text = "16"
        speedInput.PlaceholderText = "1-inf"
        
        -- Team input
        local teamLabel = Instance.new("TextLabel")
        teamLabel.Size = UDim2.new(0, 40, 0, 25)
        teamLabel.Position = UDim2.new(0, 185, 0, 100)
        teamLabel.BackgroundTransparency = 1
        teamLabel.Text = "Team:"
        teamLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
        teamLabel.TextSize = 10
        teamLabel.Font = Enum.Font.GothamBold
        teamLabel.TextXAlignment = Enum.TextXAlignment.Left
        teamLabel.Parent = panel
        
        local teamInput = createNumberInput(panel, "Name", UDim2.new(0, 10, 0, 130))
        teamInput.Size = UDim2.new(1, -20, 0, 25)
        teamInput.Text = "Neutral"
        teamInput.PlaceholderText = "Team Name"
        
        -- Display Name input
        local nameLabel = Instance.new("TextLabel")
        nameLabel.Size = UDim2.new(0, 80, 0, 25)
        nameLabel.Position = UDim2.new(0, 10, 0, 160)
        nameLabel.BackgroundTransparency = 1
        nameLabel.Text = "Display Name:"
        nameLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
        nameLabel.TextSize = 10
        nameLabel.Font = Enum.Font.GothamBold
        nameLabel.TextXAlignment = Enum.TextXAlignment.Left
        nameLabel.Parent = panel
        
        local nameInput = createNumberInput(panel, "Name", UDim2.new(0, 100, 0, 160))
        nameInput.Size = UDim2.new(1, -110, 0, 25)
        nameInput.Text = "Bot"
        nameInput.PlaceholderText = "Display Name"
        
        -- Weapon Loadouts
        local weaponLabel = Instance.new("TextLabel")
        weaponLabel.Size = UDim2.new(1, -20, 0, 20)
        weaponLabel.Position = UDim2.new(0, 10, 0, 195)
        weaponLabel.BackgroundTransparency = 1
        weaponLabel.Text = "âš”ï¸ Weapon Loadout:"
        weaponLabel.TextColor3 = Color3.fromRGB(255, 200, 100)
        weaponLabel.TextSize = 11
        weaponLabel.Font = Enum.Font.GothamBold
        weaponLabel.TextXAlignment = Enum.TextXAlignment.Left
        weaponLabel.Parent = panel
        
        local weapon1Dropdown = createDropdown(panel, {"None", "Sword", "Gun", "Laser", "Rocket", "Sniper", "Shotgun", "Plasma", "Lightning", "Freeze Ray"})
        weapon1Dropdown.Position = UDim2.new(0, 10, 0, 220)
        weapon1Dropdown.Size = UDim2.new(0, 80, 0, 25)
        
        local weapon2Dropdown = createDropdown(panel, {"None", "Sword", "Gun", "Laser", "Rocket", "Sniper", "Shotgun", "Plasma", "Lightning", "Freeze Ray"})
        weapon2Dropdown.Position = UDim2.new(0, 100, 0, 220)
        weapon2Dropdown.Size = UDim2.new(0, 80, 0, 25)
        
        local weapon3Dropdown = createDropdown(panel, {"None", "Sword", "Gun", "Laser", "Rocket", "Sniper", "Shotgun", "Plasma", "Lightning", "Freeze Ray"})
        weapon3Dropdown.Position = UDim2.new(0, 190, 0, 220)
        weapon3Dropdown.Size = UDim2.new(0, 80, 0, 25)
        
        -- Display Toggle
        local displayToggleBtn, updateDisplayToggle = createToggleButton(panel, "Show Names", UDim2.new(0, 100, 0, 25), UDim2.new(0, 10, 0, 255), sentinelDisplayToggle)
        displayToggleBtn.MouseButton1Click:Connect(function()
            sentinelDisplayToggle = not sentinelDisplayToggle
            displayToggleBtn:SetAttribute("ToggleState", sentinelDisplayToggle)
            updateDisplayToggle(sentinelDisplayToggle)
            
            -- Update all sentinel displays
            for _, data in pairs(sentinelParts) do
                if data.teamLabel then data.teamLabel.Visible = sentinelDisplayToggle end
                if data.behaviorLabel then data.behaviorLabel.Visible = sentinelDisplayToggle end
                if data.healthBar then data.healthBar.Visible = sentinelDisplayToggle end
            end
        end)
        
        -- Talking Toggle
        local talkingToggleBtn, updateTalkingToggle = createToggleButton(panel, "Talking", UDim2.new(0, 100, 0, 25), UDim2.new(0, 120, 0, 255), sentinelTalkingEnabled)
        talkingToggleBtn.MouseButton1Click:Connect(function()
            sentinelTalkingEnabled = not sentinelTalkingEnabled
            talkingToggleBtn:SetAttribute("ToggleState", sentinelTalkingEnabled)
            updateTalkingToggle(sentinelTalkingEnabled)
            
            -- Hide all active chat bubbles if talking is disabled
            if not sentinelTalkingEnabled then
                for _, data in pairs(sentinelParts) do
                    if data.chatBubble then
                        data.chatBubble.Visible = false
                    end
                end
            end
        end)
        
        -- Team list label
        local teamsLabel = Instance.new("TextLabel")
        teamsLabel.Size = UDim2.new(1, -20, 0, 40)
        teamsLabel.Position = UDim2.new(0, 10, 0, 290)
        teamsLabel.BackgroundTransparency = 1
        teamsLabel.Text = "Teams: Neutral"
        teamsLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
        teamsLabel.TextSize = 9
        teamsLabel.Font = Enum.Font.Gotham
        teamsLabel.TextWrapped = true
        teamsLabel.TextXAlignment = Enum.TextXAlignment.Left
        teamsLabel.Parent = panel
        
        local function updateTeamsList()
            local teamsList = "Teams: "
            local count = 0
            for team, parts in pairs(sentinelTeams) do
                if #parts > 0 then
                    if count > 0 then teamsList = teamsList .. ", " end
                    teamsList = teamsList .. team .. "(" .. #parts .. ")"
                    count = count + 1
                end
            end
            if count == 0 then teamsList = "Teams: None" end
            teamsLabel.Text = teamsList
        end
        
        -- Apply button
        local applyBtn = createButton(panel, "Create Sentinel", UDim2.new(1, -20, 0, 30), UDim2.new(0, 10, 0, 340))
        applyBtn.BackgroundColor3 = Color3.fromRGB(50, 200, 50)
        applyBtn.MouseButton1Click:Connect(function()
            local behavior = behaviorDropdown.Text:gsub(" â–¼", "")
            local movement = movementDropdown.Text:gsub(" â–¼", "")
            local flight = flightBtn:GetAttribute("ToggleState")
            local team = teamInput.Text
            local speed = math.max(1, tonumber(speedInput.Text) or 16)
            local displayName = nameInput.Text
            local weapon1 = weapon1Dropdown.Text:gsub(" â–¼", "")
            local weapon2 = weapon2Dropdown.Text:gsub(" â–¼", "")
            local weapon3 = weapon3Dropdown.Text:gsub(" â–¼", "")
            local tf2Class = "None"
            
            -- TF2 Mode overrides
            if tf2ModeEnabled then
                tf2Class = tf2ClassDropdown.Text:gsub(" â–¼", "")
                team = tf2TeamDropdown.Text:gsub(" â–¼", "")
                behavior = "Fighter" -- Force Fighter in TF2 mode
                displayName = team .. " " .. tf2Class
            end
            
            for _, part in ipairs(selectedParts) do
                createSentinel(part, behavior, movement, flight, team, speed, displayName, weapon1, weapon2, weapon3, tf2Class)
            end
            
            updateTeamsList()
        end)
        
        -- Remove button
        local removeBtn = createButton(panel, "Remove", UDim2.new(0.5, -5, 0, 30), UDim2.new(0, 10, 0, 380))
        removeBtn.BackgroundColor3 = Color3.fromRGB(150, 50, 50)
        removeBtn.MouseButton1Click:Connect(function()
            for _, part in ipairs(selectedParts) do
                removeSentinel(part)
            end
            updateTeamsList()
        end)
        
        -- Info button
        local infoBtn = createButton(panel, "Info", UDim2.new(0.5, -5, 0, 30), UDim2.new(0.5, 5, 0, 380))
        infoBtn.BackgroundColor3 = Color3.fromRGB(50, 150, 200)
        infoBtn.MouseButton1Click:Connect(function()
            if #selectedParts > 0 then
                local part = selectedParts[1]
                local info = getSentinelInfo(part)
                if info then
                    print("ðŸ¤– Sentinel Info for " .. part.Name)
                    print("Display Name: " .. info.state.displayName)
                    print("Team: " .. info.team)
                    print("Behavior: " .. info.behavior)
                    print("Movement: " .. info.movementMode)
                    print("Speed: " .. info.speed)
                    print("Weapons: " .. table.concat(info.state.weapons, ", "))
                    print("Health: " .. math.floor(info.state.health) .. "/" .. info.state.maxHealth)
                    print("In Fight: " .. tostring(info.state.isInFight))
                    if info.state.isTF2Mode then
                        print("ðŸŽ–ï¸ TF2 Class: " .. info.state.tf2Class)
                    end
                else
                    warn("Selected part is not a Sentinel")
                end
            end
            updateTeamsList()
        end)
        
        -- Update teams list periodically
        task.spawn(function()
            while panel.Parent do
                updateTeamsList()
                task.wait(2)
            end
        end)
    end

    local function createSkyboxTeleporterPanel(parent)
        local panel = createPanel(parent, "ðŸŒŒ Skybox Teleporter", 30)
        
        local infoLabel = Instance.new("TextLabel")
        infoLabel.Size = UDim2.new(1, -20, 0, 30)
        infoLabel.Position = UDim2.new(0, 10, 0, 40)
        infoLabel.BackgroundTransparency = 1
        infoLabel.Text = "Teleport to EXTREME coordinates!\nUp to 9 QUADRILLION studs! Others can see!"
        infoLabel.TextColor3 = Color3.fromRGB(255, 100, 255)
        infoLabel.TextSize = 10
        infoLabel.TextWrapped = true
        infoLabel.Font = Enum.Font.GothamBold
        infoLabel.Parent = panel
        
        -- Mode Selector
        local modeDropdown = createDropdown(panel, {"Preset Zones", "Custom Coords"})
        modeDropdown.Position = UDim2.new(0, 10, 0, 75)
        modeDropdown.Size = UDim2.new(0, 100, 0, 25)
        
        -- PRESET MODE CONTROLS
        local presetFrame = Instance.new("Frame")
        presetFrame.Name = "PresetFrame"
        presetFrame.Size = UDim2.new(1, 0, 0, 90)
        presetFrame.Position = UDim2.new(0, 0, 0, 100)
        presetFrame.BackgroundTransparency = 1
        presetFrame.Parent = panel
        
        local zoneDropdown = createDropdown(presetFrame, {"Color Box", "Glitch Box", "Gray Box", "The Void", "Corruption", "Extreme Void"})
        zoneDropdown.Position = UDim2.new(0, 10, 0, 0)
        zoneDropdown.Size = UDim2.new(0, 110, 0, 25)
        
        local directionDropdown = createDropdown(presetFrame, {"+X", "-X", "+Y", "-Y", "+Z", "-Z"})
        directionDropdown.Position = UDim2.new(0, 130, 0, 0)
        directionDropdown.Size = UDim2.new(0, 60, 0, 25)
        
        local coordsLabel = Instance.new("TextLabel")
        coordsLabel.Size = UDim2.new(1, -20, 0, 20)
        coordsLabel.Position = UDim2.new(0, 10, 0, 30)
        coordsLabel.BackgroundTransparency = 1
        coordsLabel.Text = "Coords will show here"
        coordsLabel.TextColor3 = Color3.fromRGB(150, 255, 150)
        coordsLabel.TextSize = 9
        coordsLabel.Font = Enum.Font.Code
        coordsLabel.TextXAlignment = Enum.TextXAlignment.Left
        coordsLabel.Parent = presetFrame
        
        local function updateCoords()
            local zone = zoneDropdown.Text:gsub(" â–¼", "")
            local direction = directionDropdown.Text:gsub(" â–¼", "")
            local destination = zone .. " " .. direction
            
            if skyboxCoordinates[destination] then
                local pos = skyboxCoordinates[destination]
                coordsLabel.Text = string.format("â†’ %.0f, %.0f, %.0f", pos.X, pos.Y, pos.Z)
            end
        end
        
        zoneDropdown.MouseButton1Click:Connect(updateCoords)
        directionDropdown.MouseButton1Click:Connect(updateCoords)
        
        local presetTpBtn = createButton(presetFrame, "ðŸš€ APPLY", UDim2.new(1, -20, 0, 30), UDim2.new(0, 10, 0, 55))
        presetTpBtn.BackgroundColor3 = Color3.fromRGB(50, 200, 50)
        presetTpBtn.TextSize = 14
        presetTpBtn.MouseButton1Click:Connect(function()
            local zone = zoneDropdown.Text:gsub(" â–¼", "")
            local direction = directionDropdown.Text:gsub(" â–¼", "")
            local destination = zone .. " " .. direction
            teleportToSkybox(destination)
        end)
        
        -- CUSTOM MODE CONTROLS
        local customFrame = Instance.new("Frame")
        customFrame.Name = "CustomFrame"
        customFrame.Size = UDim2.new(1, 0, 0, 90)
        customFrame.Position = UDim2.new(0, 0, 0, 100)
        customFrame.BackgroundTransparency = 1
        customFrame.Visible = false
        customFrame.Parent = panel
        
        local customLabel = Instance.new("TextLabel")
        customLabel.Size = UDim2.new(1, -20, 0, 20)
        customLabel.Position = UDim2.new(0, 10, 0, 0)
        customLabel.BackgroundTransparency = 1
        customLabel.Text = "Enter Custom Coordinates:"
        customLabel.TextColor3 = Color3.fromRGB(255, 200, 100)
        customLabel.TextSize = 10
        customLabel.Font = Enum.Font.GothamBold
        customLabel.TextXAlignment = Enum.TextXAlignment.Left
        customLabel.Parent = customFrame
        
        local xInput = createNumberInput(customFrame, "X", UDim2.new(0, 10, 0, 25))
        xInput.Size = UDim2.new(0, 70, 0, 25)
        xInput.Text = "0"
        
        local yInput = createNumberInput(customFrame, "Y", UDim2.new(0, 90, 0, 25))
        yInput.Size = UDim2.new(0, 70, 0, 25)
        yInput.Text = "100"
        
        local zInput = createNumberInput(customFrame, "Z", UDim2.new(0, 170, 0, 25))
        zInput.Size = UDim2.new(0, 70, 0, 25)
        zInput.Text = "0"
        
        local customTpBtn = createButton(customFrame, "ðŸŽ¯ APPLY", UDim2.new(1, -20, 0, 30), UDim2.new(0, 10, 0, 55))
        customTpBtn.BackgroundColor3 = Color3.fromRGB(50, 200, 50)
        customTpBtn.TextSize = 14
        customTpBtn.MouseButton1Click:Connect(function()
            local x = tonumber(xInput.Text) or 0
            local y = tonumber(yInput.Text) or 0
            local z = tonumber(zInput.Text) or 0
            teleportToCustomCoords(x, y, z)
        end)
        
        -- Mode Switcher
        modeDropdown.MouseButton1Click:Connect(function()
            task.wait(0.1)
            local mode = modeDropdown.Text:gsub(" â–¼", "")
            if mode == "Custom Coords" then
                presetFrame.Visible = false
                customFrame.Visible = true
            else
                presetFrame.Visible = true
                customFrame.Visible = false
            end
        end)
    end

    local function createMainGui()
        screenGui = Instance.new("ScreenGui")
        screenGui.Name = "PhysicsToolGui"
        screenGui.ResetOnSpawn = false
        screenGui.Parent = playerGui
        
        mainFrame = Instance.new("Frame")
        mainFrame.Name = "MainFrame"
        mainFrame.Size = UDim2.new(0, 600, 0, 400)
        mainFrame.Position = UDim2.new(0.5, -300, 0.5, -200)
        mainFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
        mainFrame.BorderSizePixel = 0
        mainFrame.Parent = screenGui
        
        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 12)
        corner.Parent = mainFrame
        
        local titleBar = Instance.new("Frame")
        titleBar.Name = "TitleBar"
        titleBar.Size = UDim2.new(1, 0, 0, 40)
        titleBar.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
        titleBar.BorderSizePixel = 0
        titleBar.Parent = mainFrame
        
        local titleCorner = Instance.new("UICorner")
        titleCorner.CornerRadius = UDim.new(0, 12)
        titleCorner.Parent = titleBar
        
        local titleLabel = Instance.new("TextLabel")
        titleLabel.Name = "Title"
        titleLabel.Size = UDim2.new(1, -20, 1, 0)
        titleLabel.Position = UDim2.new(0, 10, 0, 0)
        titleLabel.BackgroundTransparency = 1
        titleLabel.Text = "ðŸ”§ Physics Apply Tool [ENHANCED+]"
        titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
        titleLabel.TextSize = 18
        titleLabel.TextXAlignment = Enum.TextXAlignment.Left
        titleLabel.Font = Enum.Font.GothamBold
        titleLabel.Parent = titleBar
        
        local dragging = false
        local dragStart = nil
        local startPos = nil
        
        titleBar.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                dragging = true
                dragStart = input.Position
                startPos = mainFrame.Position
            end
        end)
        
        titleBar.InputChanged:Connect(function(input)
            if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
                local delta = input.Position - dragStart
                mainFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
            end
        end)
        
        titleBar.InputEnded:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then dragging = false end
        end)
        
        UserInputService.InputEnded:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then dragging = false end
        end)
        
        local gridContainer = Instance.new("ScrollingFrame")
        gridContainer.Name = "GridContainer"
        gridContainer.Size = UDim2.new(1, -20, 1, -60)
        gridContainer.Position = UDim2.new(0, 10, 0, 50)
        gridContainer.BackgroundTransparency = 1
        gridContainer.BorderSizePixel = 0
        gridContainer.ScrollBarThickness = 8
        gridContainer.Parent = mainFrame
        
        local gridLayout = Instance.new("UIGridLayout")
        gridLayout.CellSize = UDim2.new(0, 280, 0, 200)
        gridLayout.CellPadding = UDim2.new(0, 10, 0, 10)
        gridLayout.SortOrder = Enum.SortOrder.LayoutOrder
        gridLayout.Parent = gridContainer
        
        createConstraintsPanel(gridContainer)
        createVelocityPanel(gridContainer)
        createAngularVelocityPanel(gridContainer)
        createZeroGravityPanel(gridContainer)
        createWeightPanel(gridContainer)
        createGyroBalancerPanel(gridContainer)
        createFrozenFlingerPanel(gridContainer)
        createPositionLockPanel(gridContainer)
        createUnAnchoredTPPanel(gridContainer)
        createSelectionPanel(gridContainer)
        createShowForcesPanel(gridContainer)
        createFreezeMotionPanel(gridContainer)
        createTimeScalePanel(gridContainer)
        createPhysicsRecorderPanel(gridContainer)
        createGravityGunPanel(gridContainer)
        createPhysicsPaintPanel(gridContainer)
        createKineticAmplifierPanel(gridContainer)
        createBlackHolePanel(gridContainer)
        createMomentumAbsorberPanel(gridContainer)
        createForceReflectionPanel(gridContainer)
        createGravityDistorterPanel(gridContainer)
        createExponentialTweenPanel(gridContainer)
        createRotationLockPanel(gridContainer)
        createLinearOscillatePanel(gridContainer)
        createAngularOscillatePanel(gridContainer)
        createShockwaveGeneratorPanel(gridContainer)
        createSentinelPanel(gridContainer)
        createSkyboxTeleporterPanel(gridContainer)
        
        -- NEW: Constraint Editor Panel
        local function createConstraintEditorPanel(parent)
            local panel = createPanel(parent, "ðŸ”§ Constraint Editor", 31)
            panel.Size = UDim2.new(0, 280, 0, 450)
            constraintEditorPanel = panel
            
            local infoLabel = Instance.new("TextLabel")
            infoLabel.Size = UDim2.new(1, -20, 0, 30)
            infoLabel.Position = UDim2.new(0, 10, 0, 40)
            infoLabel.BackgroundTransparency = 1
            infoLabel.Text = "Select a part with constraints to edit them"
            infoLabel.TextColor3 = Color3.fromRGB(255, 200, 100)
            infoLabel.TextSize = 10
            infoLabel.Font = Enum.Font.GothamBold
            infoLabel.TextWrapped = true
            infoLabel.Parent = panel
            
            -- Constraint List (Scrollable)
            local constraintListLabel = Instance.new("TextLabel")
            constraintListLabel.Size = UDim2.new(1, -20, 0, 20)
            constraintListLabel.Position = UDim2.new(0, 10, 0, 75)
            constraintListLabel.BackgroundTransparency = 1
            constraintListLabel.Text = "Constraints on Selected Part:"
            constraintListLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
            constraintListLabel.TextSize = 11
            constraintListLabel.Font = Enum.Font.GothamBold
            constraintListLabel.TextXAlignment = Enum.TextXAlignment.Left
            constraintListLabel.Parent = panel
            
            local constraintScroll = Instance.new("ScrollingFrame")
            constraintScroll.Size = UDim2.new(1, -20, 0, 120)
            constraintScroll.Position = UDim2.new(0, 10, 0, 100)
            constraintScroll.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
            constraintScroll.BorderSizePixel = 0
            constraintScroll.ScrollBarThickness = 4
            constraintScroll.Parent = panel
            
            local scrollCorner = Instance.new("UICorner")
            scrollCorner.CornerRadius = UDim.new(0, 4)
            scrollCorner.Parent = constraintScroll
            
            local constraintListLayout = Instance.new("UIListLayout")
            constraintListLayout.SortOrder = Enum.SortOrder.LayoutOrder
            constraintListLayout.Padding = UDim.new(0, 3)
            constraintListLayout.Parent = constraintScroll
            
            -- Editor Fields Container
            local editorFrame = Instance.new("Frame")
            editorFrame.Size = UDim2.new(1, -20, 0, 200)
            editorFrame.Position = UDim2.new(0, 10, 0, 230)
            editorFrame.BackgroundTransparency = 1
            editorFrame.Parent = panel
            
            local editorLabel = Instance.new("TextLabel")
            editorLabel.Size = UDim2.new(1, 0, 0, 20)
            editorLabel.Position = UDim2.new(0, 0, 0, 0)
            editorLabel.BackgroundTransparency = 1
            editorLabel.Text = "Select a constraint to edit"
            editorLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
            editorLabel.TextSize = 10
            editorLabel.Font = Enum.Font.GothamBold
            editorLabel.Parent = editorFrame
            
            -- Dynamic input fields (created based on constraint type)
            local inputFields = {}
            
            local function clearInputFields()
                for _, field in pairs(inputFields) do
                    if field then field:Destroy() end
                end
                inputFields = {}
            end
            
            local function createInputField(name, value, yPos)
                local label = Instance.new("TextLabel")
                label.Size = UDim2.new(0, 80, 0, 25)
                label.Position = UDim2.new(0, 0, 0, yPos)
                label.BackgroundTransparency = 1
                label.Text = name .. ":"
                label.TextColor3 = Color3.fromRGB(200, 200, 200)
                label.TextSize = 10
                label.Font = Enum.Font.GothamBold
                label.TextXAlignment = Enum.TextXAlignment.Left
                label.Parent = editorFrame
                
                local input = createNumberInput(editorFrame, tostring(value), UDim2.new(0, 90, 0, yPos))
                input.Size = UDim2.new(0, 160, 0, 25)
                input.Text = tostring(value)
                
                table.insert(inputFields, label)
                table.insert(inputFields, input)
                
                return input
            end
            
            local function updateConstraintList()
                -- Clear existing buttons
                for _, child in ipairs(constraintScroll:GetChildren()) do
                    if child:IsA("TextButton") then child:Destroy() end
                end
                
                if #selectedParts == 0 then
                    infoLabel.Text = "Select a part with constraints to edit them"
                    editorLabel.Text = "Select a constraint to edit"
                    clearInputFields()
                    return
                end
                
                local part = selectedParts[1]
                local constraints = {}
                
                -- Find all constraints connected to this part (check attachments)
                for _, obj in ipairs(workspace:GetDescendants()) do
                    if obj:IsA("Constraint") then
                        local att0 = obj:FindFirstChild("Attachment0")
                        local att1 = obj:FindFirstChild("Attachment1")
                        
                        if att0 and att0.Parent == part then
                            if not table.find(constraints, obj) then
                                table.insert(constraints, obj)
                            end
                        end
                        
                        if att1 and att1.Parent == part then
                            if not table.find(constraints, obj) then
                                table.insert(constraints, obj)
                            end
                        end
                    end
                end
                
                if #constraints == 0 then
                    infoLabel.Text = "No constraints found on " .. part.Name
                    editorLabel.Text = "Select a constraint to edit"
                    clearInputFields()
                else
                    infoLabel.Text = "Found " .. #constraints .. " constraint(s) on " .. part.Name
                    
                    for i, constraint in ipairs(constraints) do
                        local btn = Instance.new("TextButton")
                        btn.Size = UDim2.new(1, -8, 0, 30)
                        btn.BackgroundColor3 = Color3.fromRGB(60, 60, 70)
                        btn.BorderSizePixel = 0
                        btn.Text = constraint.ClassName
                        btn.TextColor3 = Color3.fromRGB(255, 255, 255)
                        btn.TextSize = 11
                        btn.Font = Enum.Font.Gotham
                        btn.Parent = constraintScroll
                        
                        local btnCorner = Instance.new("UICorner")
                        btnCorner.CornerRadius = UDim.new(0, 4)
                        btnCorner.Parent = btn
                        
                        btn.MouseButton1Click:Connect(function()
                            selectedConstraintForEditing = constraint
                            editorLabel.Text = "Editing: " .. constraint.ClassName
                            clearInputFields()
                            
                            -- Highlight selected button
                            for _, otherBtn in ipairs(constraintScroll:GetChildren()) do
                                if otherBtn:IsA("TextButton") then
                                    otherBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 70)
                                end
                            end
                            btn.BackgroundColor3 = Color3.fromRGB(70, 130, 180)
                            
                            -- Create input fields based on constraint type
                            local yOffset = 25
                            
                            if constraint:IsA("RopeConstraint") then
                                inputFields.Length = createInputField("Length", constraint.Length, yOffset)
                                yOffset = yOffset + 30
                                inputFields.Visible = createInputField("Visible", constraint.Visible and 1 or 0, yOffset)
                                yOffset = yOffset + 30
                                inputFields.Restitution = createInputField("Restitution", constraint.Restitution, yOffset)
                                
                            elseif constraint:IsA("RodConstraint") then
                                inputFields.Length = createInputField("Length", constraint.Length, yOffset)
                                
                            elseif constraint:IsA("SpringConstraint") then
                                inputFields.FreeLength = createInputField("FreeLength", constraint.FreeLength, yOffset)
                                yOffset = yOffset + 30
                                inputFields.Stiffness = createInputField("Stiffness", constraint.Stiffness, yOffset)
                                yOffset = yOffset + 30
                                inputFields.Damping = createInputField("Damping", constraint.Damping, yOffset)
                                yOffset = yOffset + 30
                                inputFields.Visible = createInputField("Visible", constraint.Visible and 1 or 0, yOffset)
                                
                            elseif constraint:IsA("HingeConstraint") then
                                inputFields.LimitsEnabled = createInputField("LimitsEnabled", constraint.LimitsEnabled and 1 or 0, yOffset)
                                yOffset = yOffset + 30
                                if constraint.LimitsEnabled then
                                    inputFields.LowerAngle = createInputField("LowerAngle", constraint.LowerAngle, yOffset)
                                    yOffset = yOffset + 30
                                    inputFields.UpperAngle = createInputField("UpperAngle", constraint.UpperAngle, yOffset)
                                    yOffset = yOffset + 30
                                end
                                inputFields.ActuatorType = createInputField("ActuatorType", constraint.ActuatorType.Value, yOffset)
                                
                            elseif constraint:IsA("BallSocketConstraint") then
                                inputFields.LimitsEnabled = createInputField("LimitsEnabled", constraint.LimitsEnabled and 1 or 0, yOffset)
                                yOffset = yOffset + 30
                                if constraint.LimitsEnabled then
                                    inputFields.UpperAngle = createInputField("UpperAngle", constraint.UpperAngle, yOffset)
                                end
                                
                            elseif constraint:IsA("PrismaticConstraint") then
                                inputFields.LimitsEnabled = createInputField("LimitsEnabled", constraint.LimitsEnabled and 1 or 0, yOffset)
                                yOffset = yOffset + 30
                                if constraint.LimitsEnabled then
                                    inputFields.LowerLimit = createInputField("LowerLimit", constraint.LowerLimit, yOffset)
                                    yOffset = yOffset + 30
                                    inputFields.UpperLimit = createInputField("UpperLimit", constraint.UpperLimit, yOffset)
                                end
                                
                            elseif constraint:IsA("CylindricalConstraint") then
                                inputFields.LimitsEnabled = createInputField("LimitsEnabled", constraint.LimitsEnabled and 1 or 0, yOffset)
                                yOffset = yOffset + 30
                                if constraint.LimitsEnabled then
                                    inputFields.LowerLimit = createInputField("LowerLimit", constraint.LowerLimit, yOffset)
                                    yOffset = yOffset + 30
                                    inputFields.UpperLimit = createInputField("UpperLimit", constraint.UpperLimit, yOffset)
                                end
                            end
                        end)
                    end
                end
                
                constraintScroll.CanvasSize = UDim2.new(0, 0, 0, constraintListLayout.AbsoluteContentSize.Y)
            end
            
            local applyBtn = createButton(panel, "Apply Changes", UDim2.new(1, -20, 0, 30), UDim2.new(0, 10, 1, -40))
            applyBtn.BackgroundColor3 = Color3.fromRGB(50, 200, 50)
            applyBtn.MouseButton1Click:Connect(function()
                if not selectedConstraintForEditing then
                    warn("No constraint selected!")
                    return
                end
                
                local constraint = selectedConstraintForEditing
                
                -- Apply changes based on constraint type
                if constraint:IsA("RopeConstraint") then
                    if inputFields.Length then constraint.Length = tonumber(inputFields.Length.Text) or constraint.Length end
                    if inputFields.Visible then constraint.Visible = (tonumber(inputFields.Visible.Text) or 0) ~= 0 end
                    if inputFields.Restitution then constraint.Restitution = tonumber(inputFields.Restitution.Text) or constraint.Restitution end
                    
                elseif constraint:IsA("RodConstraint") then
                    if inputFields.Length then constraint.Length = tonumber(inputFields.Length.Text) or constraint.Length end
                    
                elseif constraint:IsA("SpringConstraint") then
                    if inputFields.FreeLength then constraint.FreeLength = tonumber(inputFields.FreeLength.Text) or constraint.FreeLength end
                    if inputFields.Stiffness then constraint.Stiffness = tonumber(inputFields.Stiffness.Text) or constraint.Stiffness end
                    if inputFields.Damping then constraint.Damping = tonumber(inputFields.Damping.Text) or constraint.Damping end
                    if inputFields.Visible then constraint.Visible = (tonumber(inputFields.Visible.Text) or 0) ~= 0 end
                    
                elseif constraint:IsA("HingeConstraint") then
                    if inputFields.LimitsEnabled then constraint.LimitsEnabled = (tonumber(inputFields.LimitsEnabled.Text) or 0) ~= 0 end
                    if constraint.LimitsEnabled and inputFields.LowerAngle then constraint.LowerAngle = tonumber(inputFields.LowerAngle.Text) or constraint.LowerAngle end
                    if constraint.LimitsEnabled and inputFields.UpperAngle then constraint.UpperAngle = tonumber(inputFields.UpperAngle.Text) or constraint.UpperAngle end
                    
                elseif constraint:IsA("BallSocketConstraint") then
                    if inputFields.LimitsEnabled then constraint.LimitsEnabled = (tonumber(inputFields.LimitsEnabled.Text) or 0) ~= 0 end
                    if constraint.LimitsEnabled and inputFields.UpperAngle then constraint.UpperAngle = tonumber(inputFields.UpperAngle.Text) or constraint.UpperAngle end
                    
                elseif constraint:IsA("PrismaticConstraint") then
                    if inputFields.LimitsEnabled then constraint.LimitsEnabled = (tonumber(inputFields.LimitsEnabled.Text) or 0) ~= 0 end
                    if constraint.LimitsEnabled and inputFields.LowerLimit then constraint.LowerLimit = tonumber(inputFields.LowerLimit.Text) or constraint.LowerLimit end
                    if constraint.LimitsEnabled and inputFields.UpperLimit then constraint.UpperLimit = tonumber(inputFields.UpperLimit.Text) or constraint.UpperLimit end
                    
                elseif constraint:IsA("CylindricalConstraint") then
                    if inputFields.LimitsEnabled then constraint.LimitsEnabled = (tonumber(inputFields.LimitsEnabled.Text) or 0) ~= 0 end
                    if constraint.LimitsEnabled and inputFields.LowerLimit then constraint.LowerLimit = tonumber(inputFields.LowerLimit.Text) or constraint.LowerLimit end
                    if constraint.LimitsEnabled and inputFields.UpperLimit then constraint.UpperLimit = tonumber(inputFields.UpperLimit.Text) or constraint.UpperLimit end
                end
                
                print("âœ… Applied changes to " .. constraint.ClassName)
            end)
            
            -- Update list when selection changes
            task.spawn(function()
                while panel.Parent do
                    updateConstraintList()
                    task.wait(1)
                end
            end)
        end
        
        createConstraintEditorPanel(gridContainer)
        
        -- NEW: Keybind Settings Panel
        local function createKeybindSettingsPanel(parent)
            local panel = createPanel(parent, "âŒ¨ï¸ Keybind Manager", 31)
            panel.Size = UDim2.new(0, 280, 0, 350)
            
            local infoLabel = Instance.new("TextLabel")
            infoLabel.Size = UDim2.new(1, -20, 0, 30)
            infoLabel.Position = UDim2.new(0, 10, 0, 40)
            infoLabel.BackgroundTransparency = 1
            infoLabel.Text = "Manage all velocity & angular keybinds"
            infoLabel.TextColor3 = Color3.fromRGB(255, 200, 100)
            infoLabel.TextSize = 10
            infoLabel.Font = Enum.Font.GothamBold
            infoLabel.TextWrapped = true
            infoLabel.Parent = panel
            
            local keybindScroll = Instance.new("ScrollingFrame")
            keybindScroll.Size = UDim2.new(1, -20, 0, 200)
            keybindScroll.Position = UDim2.new(0, 10, 0, 75)
            keybindScroll.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
            keybindScroll.BorderSizePixel = 0
            keybindScroll.ScrollBarThickness = 4
            keybindScroll.Parent = panel
            
            local scrollCorner = Instance.new("UICorner")
            scrollCorner.CornerRadius = UDim.new(0, 4)
            scrollCorner.Parent = keybindScroll
            
            local keybindListLayout = Instance.new("UIListLayout")
            keybindListLayout.SortOrder = Enum.SortOrder.LayoutOrder
            keybindListLayout.Padding = UDim.new(0, 5)
            keybindListLayout.Parent = keybindScroll
            
            local function updateKeybindList()
                for _, child in ipairs(keybindScroll:GetChildren()) do
                    if child:IsA("Frame") then child:Destroy() end
                end
                
                for id, data in pairs(activeKeybinds) do
                    local itemFrame = Instance.new("Frame")
                    itemFrame.Size = UDim2.new(1, -8, 0, 80)
                    itemFrame.BackgroundColor3 = Color3.fromRGB(60, 60, 70)
                    itemFrame.BorderSizePixel = 0
                    itemFrame.Parent = keybindScroll
                    
                    local itemCorner = Instance.new("UICorner")
                    itemCorner.CornerRadius = UDim.new(0, 4)
                    itemCorner.Parent = itemFrame
                    
                    local typeLabel = Instance.new("TextLabel")
                    typeLabel.Size = UDim2.new(1, -10, 0, 15)
                    typeLabel.Position = UDim2.new(0, 5, 0, 3)
                    typeLabel.BackgroundTransparency = 1
                    typeLabel.Text = data.type .. " | " .. table.concat(data.keys, "+")
                    typeLabel.TextColor3 = Color3.fromRGB(255, 200, 100)
                    typeLabel.TextSize = 10
                    typeLabel.Font = Enum.Font.GothamBold
                    typeLabel.TextXAlignment = Enum.TextXAlignment.Left
                    typeLabel.Parent = itemFrame
                    
                    local triggerLabel = Instance.new("TextLabel")
                    triggerLabel.Size = UDim2.new(1, -10, 0, 12)
                    triggerLabel.Position = UDim2.new(0, 5, 0, 18)
                    triggerLabel.BackgroundTransparency = 1
                    triggerLabel.Text = "Trigger: " .. data.triggerType
                    triggerLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
                    triggerLabel.TextSize = 8
                    triggerLabel.Font = Enum.Font.Gotham
                    triggerLabel.TextXAlignment = Enum.TextXAlignment.Left
                    triggerLabel.Parent = itemFrame
                    
                    local partsLabel = Instance.new("TextLabel")
                    partsLabel.Size = UDim2.new(1, -10, 0, 12)
                    partsLabel.Position = UDim2.new(0, 5, 0, 30)
                    partsLabel.BackgroundTransparency = 1
                    partsLabel.Text = "Parts: " .. #data.parts
                    partsLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
                    partsLabel.TextSize = 8
                    partsLabel.Font = Enum.Font.Gotham
                    partsLabel.TextXAlignment = Enum.TextXAlignment.Left
                    partsLabel.Parent = itemFrame
                    
                    local enableBtn, updateEnable = createToggleButton(itemFrame, "ON", UDim2.new(0, 40, 0, 20), UDim2.new(0, 5, 0, 55), data.enabled)
                    enableBtn.TextSize = 9
                    enableBtn.MouseButton1Click:Connect(function()
                        data.enabled = not data.enabled
                        enableBtn:SetAttribute("ToggleState", data.enabled)
                        updateEnable(data.enabled)
                    end)
                    
                    local editBtn = createButton(itemFrame, "Edit", UDim2.new(0, 50, 0, 20), UDim2.new(0, 55, 0, 55))
                    editBtn.TextSize = 9
                    editBtn.MouseButton1Click:Connect(function()
                        print("ðŸ”§ Keybind ID: " .. id)
                        print("Type: " .. data.type)
                        print("Keys: " .. table.concat(data.keys, ", "))
                        print("Trigger: " .. data.triggerType)
                        print("Velocity: " .. tostring(data.velocity))
                    end)
                    
                    local removeBtn = createButton(itemFrame, "Del", UDim2.new(0, 50, 0, 20), UDim2.new(0, 115, 0, 55))
                    removeBtn.BackgroundColor3 = Color3.fromRGB(150, 50, 50)
                    removeBtn.TextSize = 9
                    removeBtn.MouseButton1Click:Connect(function()
                        if data.connection then data.connection:Disconnect() end
                        activeKeybinds[id] = nil
                        updateKeybindList()
                        print("Removed keybind #" .. id)
                    end)
                end
                
                keybindScroll.CanvasSize = UDim2.new(0, 0, 0, keybindListLayout.AbsoluteContentSize.Y)
            end
            
            local clearAllBtn = createButton(panel, "Clear All Keybinds", UDim2.new(1, -20, 0, 30), UDim2.new(0, 10, 1, -40))
            clearAllBtn.BackgroundColor3 = Color3.fromRGB(150, 50, 50)
            clearAllBtn.MouseButton1Click:Connect(function()
                for id, data in pairs(activeKeybinds) do
                    if data.connection then data.connection:Disconnect() end
                end
                activeKeybinds = {}
                updateKeybindList()
                print("Cleared all keybinds")
            end)
            
            -- Auto-update list
            task.spawn(function()
                while panel.Parent do
                    updateKeybindList()
                    task.wait(1)
                end
            end)
        end
        
        createKeybindSettingsPanel(gridContainer)
        
        -- EXCLUSIVE TAB
        local exclusiveTab = Instance.new("Frame")
        exclusiveTab.Name = "ExclusiveTab"
        exclusiveTab.Size = UDim2.new(1, -20, 1, -85)
        exclusiveTab.Position = UDim2.new(0, 10, 0, 75)
        exclusiveTab.BackgroundTransparency = 1
        exclusiveTab.BorderSizePixel = 0
        exclusiveTab.Visible = false
        exclusiveTab.Parent = mainFrame
        
        local exclusiveScroll = Instance.new("ScrollingFrame")
        exclusiveScroll.Size = UDim2.new(1, 0, 1, 0)
        exclusiveScroll.BackgroundTransparency = 1
        exclusiveScroll.BorderSizePixel = 0
        exclusiveScroll.ScrollBarThickness = 8
        exclusiveScroll.Parent = exclusiveTab
        
        local exclusiveLayout = Instance.new("UIGridLayout")
        exclusiveLayout.CellSize = UDim2.new(0, 280, 0, 200)
        exclusiveLayout.CellPadding = UDim2.new(0, 10, 0, 10)
        exclusiveLayout.SortOrder = Enum.SortOrder.LayoutOrder
        exclusiveLayout.Parent = exclusiveScroll
        
        createExclusiveZeroGPanel(exclusiveScroll)
        createOrbiterCorePanel(exclusiveScroll)
        createGlobalPhysicsPaintPanel(exclusiveScroll)
        
        exclusiveScroll.CanvasSize = UDim2.new(0, 0, 0, exclusiveLayout.AbsoluteContentSize.Y)
        exclusiveLayout.Changed:Connect(function(property)
            if property == "AbsoluteContentSize" then
                exclusiveScroll.CanvasSize = UDim2.new(0, 0, 0, exclusiveLayout.AbsoluteContentSize.Y)
            end
        end)
        
        -- Tab Switcher
        local tabBar = Instance.new("Frame")
        tabBar.Size = UDim2.new(1, 0, 0, 30)
        tabBar.Position = UDim2.new(0, 0, 0, 35)
        tabBar.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
        tabBar.BorderSizePixel = 0
        tabBar.Parent = mainFrame
        
        local mainTabBtn = Instance.new("TextButton")
        mainTabBtn.Size = UDim2.new(0.5, -5, 1, 0)
        mainTabBtn.Position = UDim2.new(0, 0, 0, 0)
        mainTabBtn.BackgroundColor3 = Color3.fromRGB(70, 130, 180)
        mainTabBtn.BorderSizePixel = 0
        mainTabBtn.Text = "MAIN"
        mainTabBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
        mainTabBtn.TextSize = 14
        mainTabBtn.Font = Enum.Font.GothamBold
        mainTabBtn.Parent = tabBar
        
        local exclusiveTabBtn = Instance.new("TextButton")
        exclusiveTabBtn.Size = UDim2.new(0.5, -5, 1, 0)
        exclusiveTabBtn.Position = UDim2.new(0.5, 5, 0, 0)
        exclusiveTabBtn.BackgroundColor3 = Color3.fromRGB(50, 50, 60)
        exclusiveTabBtn.BorderSizePixel = 0
        exclusiveTabBtn.Text = "EXCLUSIVE"
        exclusiveTabBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
        exclusiveTabBtn.TextSize = 14
        exclusiveTabBtn.Font = Enum.Font.GothamBold
        exclusiveTabBtn.Parent = tabBar
        
        -- Adjust container positions for tabs
        gridContainer.Position = UDim2.new(0, 10, 0, 75)
        gridContainer.Size = UDim2.new(1, -20, 1, -85)
        exclusiveTab.Position = UDim2.new(0, 10, 0, 75)
        exclusiveTab.Size = UDim2.new(1, -20, 1, -85)
        
        mainTabBtn.MouseButton1Click:Connect(function()
            gridContainer.Visible = true
            exclusiveTab.Visible = false
            mainTabBtn.BackgroundColor3 = Color3.fromRGB(70, 130, 180)
            exclusiveTabBtn.BackgroundColor3 = Color3.fromRGB(50, 50, 60)
        end)
        
        exclusiveTabBtn.MouseButton1Click:Connect(function()
            gridContainer.Visible = false
            exclusiveTab.Visible = true
            mainTabBtn.BackgroundColor3 = Color3.fromRGB(50, 50, 60)
            exclusiveTabBtn.BackgroundColor3 = Color3.fromRGB(70, 130, 180)
        end)
        
        gridContainer.CanvasSize = UDim2.new(0, 0, 0, gridLayout.AbsoluteContentSize.Y + 100)
        gridLayout.Changed:Connect(function(property)
            if property == "AbsoluteContentSize" then
                gridContainer.CanvasSize = UDim2.new(0, 0, 0, gridLayout.AbsoluteContentSize.Y + 100)
            end
        end)
    end

    tool.Equipped:Connect(function()
        isToolEquipped = true
        createMainGui()
        mouse = player:GetMouse()
        
        local eKeyPressed = false
        local eKeyConnection
        local frequencyTimer = 0
        local guiVisible = true
        
        mouse.Button1Down:Connect(function()
            local target = mouse.Target
            
            -- Gravity Gun mode
            if gravityGunActive and target and target.Parent ~= player.Character and not target.Anchored then
                if gravityGunPart == target then
                    gravityGunPart = nil
                else
                    gravityGunPart = target
                    setNetworkOwnership(target)
                end
            end
            
            -- Always allow part selection (unless it's the player's character)
            if target and target.Parent ~= player.Character then
                onPartClicked(target)
            end
            
            -- Handle TP at cursor if enabled (can click anywhere)
            if tpAtCursorEnabled and tpLockedPart and not tpLockedPart.Anchored then
                teleportPart(tpLockedPart, mouse.Hit.Position)
            end
        end)
        
        eKeyConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
            if gameProcessed then return end
            
            if input.KeyCode == Enum.KeyCode.E and not eKeyPressed then
                eKeyPressed = true
                frequencyTimer = 0
            elseif input.KeyCode == Enum.KeyCode.P then
                guiVisible = not guiVisible
                if mainFrame then
                    mainFrame.Visible = guiVisible
                end
                print("Physics Tool GUI: " .. (guiVisible and "SHOWN" or "HIDDEN"))
            end
        end)
        
        UserInputService.InputEnded:Connect(function(input)
            if input.KeyCode == Enum.KeyCode.E then
                eKeyPressed = false
                frequencyTimer = 0
            end
        end)
        
        RunService.Heartbeat:Connect(function(dt)
            if gravityGunActive and gravityGunPart and gravityGunPart.Parent then
                local targetPos = mouse.Hit.Position + Vector3.new(0, 3, 0)
                gravityGunPart.AssemblyLinearVelocity = (targetPos - gravityGunPart.Position) * 5
            end
            
            if shockwaveMode2Active and eKeyPressed then
                if shockwaveMode2Submode == "ConstantShockwave" then
                    sendShockwaveAtMouse()
                elseif shockwaveMode2Submode == "FrequencyShockwave" then
                    frequencyTimer = frequencyTimer + dt
                    if frequencyTimer >= (1 / shockwaveMode2Settings.frequency) then
                        sendShockwaveAtMouse()
                        frequencyTimer = 0
                    end
                end
            end
        end)
    end)

    tool.Unequipped:Connect(function()
        isToolEquipped = false
        if screenGui then screenGui:Destroy() screenGui = nil end
        clearSelection()
        clearTpSelection()
        gravityGunActive = false
        gravityGunPart = nil
    end)

    player.CharacterRemoving:Connect(function()
        for part, control in pairs(velocityControls) do
            if control then 
                if control.connection then control.connection:Disconnect() end
                if control.bodyVel then control.bodyVel:Destroy() end
                if control.vectorForce then control.vectorForce:Destroy() end
                if control.attachment then control.attachment:Destroy() end
            end
        end
        for part, control in pairs(angularControls) do
            if control then 
                if control.connection then control.connection:Disconnect() end
                if control.bodyAngVel then control.bodyAngVel:Destroy() end
                if control.attachment then control.attachment:Destroy() end
            end
        end
        for part, gravityData in pairs(gravityForces) do
            if gravityData then
                if gravityData.connection then gravityData.connection:Disconnect() end
                if gravityData.vectorForce then gravityData.vectorForce:Destroy() end
                if gravityData.attachment then gravityData.attachment:Destroy() end
            end
        end
        for part, force in pairs(weightForces) do
            if force then force:Destroy() end
        end
        for part, gyroData in pairs(gyroStabilizers) do
            if gyroData then
                if gyroData.connection then gyroData.connection:Disconnect() end
                if gyroData.bodyPosition then gyroData.bodyPosition:Destroy() end
                if gyroData.bodyAngularVelocity then gyroData.bodyAngularVelocity:Destroy() end
                if gyroData.attachment then gyroData.attachment:Destroy() end
                if gyroData.alignOrientation then gyroData.alignOrientation:Destroy() end
                if gyroData.bodyGyro then gyroData.bodyGyro:Destroy() end
            end
        end
        for part, flingerData in pairs(frozenFlingers) do
            if flingerData then
                if flingerData.connection then flingerData.connection:Disconnect() end
                if flingerData.weld then flingerData.weld:Destroy() end
                if flingerData.anchorPart then flingerData.anchorPart:Destroy() end
            end
        end
        for part, lockData in pairs(positionLocks) do
            if lockData then
                if lockData.connection then lockData.connection:Disconnect() end
                if lockData.bodyPosition then lockData.bodyPosition:Destroy() end
                if lockData.bodyVelocity then lockData.bodyVelocity:Destroy() end
            end
        end
        for part, visuals in pairs(showForcesVisuals) do
            if visuals then
                if visuals.connection then visuals.connection:Disconnect() end
                for _, arrow in pairs(visuals) do
                    if arrow and arrow:IsA("Instance") then arrow:Destroy() end
                end
            end
        end
        for part, data in pairs(frozenMotionParts) do
            if data and data.connection then data.connection:Disconnect() end
        end
        for name, rec in pairs(physicsRecordings) do
            if rec.connection then rec.connection:Disconnect() end
        end
        for part, data in pairs(physicsPaints) do
            if data and data.connection then data.connection:Disconnect() end
        end
        for part, data in pairs(kineticAmplifiers) do
            if data and data.connection then data.connection:Disconnect() end
        end
        for part, data in pairs(blackHoles) do
            if data and data.connection then data.connection:Disconnect() end
        end
        for part, data in pairs(buoyancyParts) do
            if data and data.connection then data.connection:Disconnect() end
        end
        for part, data in pairs(momentumAbsorbers) do
            if data and data.connection then data.connection:Disconnect() end
        end
        for part, data in pairs(forceReflectors) do
            if data and data.connection then data.connection:Disconnect() end
        end
        for part, data in pairs(gravityDistorters) do
            if data and data.connection then data.connection:Disconnect() end
        end
        for part, data in pairs(shockwaveGenerators) do
            if data and data.connection then data.connection:Disconnect() end
        end
        if shockwaveMode2Connection then
            shockwaveMode2Connection:Disconnect()
            shockwaveMode2Connection = nil
        end
        for part, data in pairs(exponentialTweenParts) do
            if data then
                if data.currentConnection then data.currentConnection:Disconnect() end
                if data.connection then data.connection:Disconnect() end
                if data.bodyPosition then data.bodyPosition:Destroy() end
                if data.bodyGyro then data.bodyGyro:Destroy() end
                if data.vectorForce then data.vectorForce:Destroy() end
                if data.attachment then data.attachment:Destroy() end
            end
        end
        for part, data in pairs(linearOscillateParts) do
            if data then
                if data.currentConnection then data.currentConnection:Disconnect() end
                if data.connection then data.connection:Disconnect() end
                if data.bodyPosition then data.bodyPosition:Destroy() end
                if data.bodyGyro then data.bodyGyro:Destroy() end
                if data.vectorForce then data.vectorForce:Destroy() end
                if data.attachment then data.attachment:Destroy() end
            end
        end
        for part, data in pairs(rotationLockParts) do
            if data then
                if data.connection then data.connection:Disconnect() end
                if data.bodyPosition then data.bodyPosition:Destroy() end
                if data.bodyGyro then data.bodyGyro:Destroy() end
            end
        end
        for part, data in pairs(angularOscillateParts) do
            if data then
                if data.currentConnection then data.currentConnection:Disconnect() end
                if data.connection then data.connection:Disconnect() end
                if data.bodyGyro then data.bodyGyro:Destroy() end
            end
        end
        for part, data in pairs(orbiterCores) do
            if data and data.connection then data.connection:Disconnect() end
        end
        for part, data in pairs(sentinelParts) do
            removeSentinel(part)
        end
        if exclusiveZeroGravityConnection then
            exclusiveZeroGravityConnection:Disconnect()
            exclusiveZeroGravityConnection = nil
        end
        
        velocityControls = {}
        angularControls = {}
        gravityForces = {}
        weightForces = {}
        gyroStabilizers = {}
        frozenFlingers = {}
        positionLocks = {}
        showForcesVisuals = {}
        frozenMotionParts = {}
        physicsRecordings = {}
        physicsPaints = {}
        kineticAmplifiers = {}
        blackHoles = {}
        buoyancyParts = {}
        momentumAbsorbers = {}
        forceReflectors = {}
        gravityDistorters = {}
        shockwaveGenerators = {}
        shockwaveMode2Active = false
        exponentialTweenParts = {}
        linearOscillateParts = {}
        rotationLockParts = {}
        angularOscillateParts = {}
        orbiterCores = {}
        sentinelParts = {}
        sentinelTeams = {}
        exclusiveZeroGravity = false
        clearTpSelection()
    end)

    return tool
end

local function forceEnableInventory()
    toolPersistent = true
    pcall(function()
        StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, true)
    end)
    createPhysicsTool()
    player.CharacterAdded:Connect(function()
        if toolPersistent then
            task.wait(2)
            createPhysicsTool()
        end
    end)
    print("Physics Apply Tool with inventory force enabled and respawn persistence activated!")
end

local function forceEnableHttpService()
    local HttpService = game:GetService("HttpService")
    
    -- Try to enable HttpEnabled using different methods
    local methods = {
        -- Method 1: Direct property set
        function()
            HttpService.HttpEnabled = true
        end,
        
        -- Method 2: Using pcall protection
        function()
            pcall(function()
                HttpService.HttpEnabled = true
            end)
        end,
        
        -- Method 3: Set via rawset (for some executors)
        function()
            if rawset then
                rawset(HttpService, "HttpEnabled", true)
            end
        end,
        
        -- Method 4: Using getfenv/setfenv manipulation
        function()
            if setreadonly then
                setreadonly(HttpService, false)
                HttpService.HttpEnabled = true
                setreadonly(HttpService, true)
            end
        end,
        
        -- Method 5: Direct memory manipulation for supported executors
        function()
            if sethiddenproperty then
                sethiddenproperty(HttpService, "HttpEnabled", true)
            end
        end
    }
    
    -- Try each method
    for i, method in ipairs(methods) do
        local success = pcall(method)
        if success then
            print("âœ… HTTP Method " .. i .. " succeeded")
        end
    end
    
    -- Verify if HTTP is now enabled
    local isEnabled = false
    pcall(function()
        isEnabled = HttpService.HttpEnabled
    end)
    
    if isEnabled then
        print("ðŸŒ HTTP Service force-enabled successfully!")
        print("âœ… Google Gemini AI will now work!")
        return true
    else
        warn("âš ï¸ Could not force-enable HTTP Service")
        warn("ðŸ’¡ This game may have HTTP locked by the developer")
        warn("ðŸ”§ Sentinels will use preset messages instead")
        return false
    end
end

local function main()
    -- Try to force-enable HTTP first
    print("ðŸ”„ Attempting to force-enable HTTP Service...")
    local httpSuccess = forceEnableHttpService()
    
    -- Small delay to let HTTP initialize
    task.wait(0.5)
    
    local notificationGui, yesButton, noButton = createNotificationGui()
    yesButton.MouseButton1Click:Connect(function()
        TweenService:Create(notificationGui.Frame, TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.In), 
            {Position = UDim2.new(0.5, -200, -1, 0)}):Play()
        task.wait(0.3)
        notificationGui:Destroy()
        forceEnableInventory()
    end)
    noButton.MouseButton1Click:Connect(function()
        TweenService:Create(notificationGui.Frame, TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.In), 
            {Position = UDim2.new(0.5, -200, 2, 0)}):Play()
        task.wait(0.3)
        notificationGui:Destroy()
        createPhysicsTool()
        print("Physics Apply Tool created without inventory forcing.")
    end)
end

if syn and syn.queue_on_teleport then
    syn.queue_on_teleport([[loadstring(game:HttpGet("https://raw.githubusercontent.com/your-repo/physics-tool.lua"))()]])
end

local function notify(title, text, duration)
    if syn and syn.notify then
        syn.notify({Title = title, Text = text, Duration = duration or 3})
    else
        print("[Physics Tool] " .. title .. ": " .. text)
    end
end

local function safeExecute(func, errorMsg)
    local success, error = pcall(func)
    if not success then
        notify("Error", errorMsg or "An error occurred", 5)
        warn("Physics Tool Error: " .. tostring(error))
    end
    return success
end

local function optimizeForExecutor()
    if syn then
        notify("Executor Detected", "Synapse X compatibility enabled", 3)
    elseif KRNL_LOADED then
        notify("Executor Detected", "Krnl compatibility enabled", 3)
    elseif getgenv().ScriptWare then
        notify("Executor Detected", "ScriptWare compatibility enabled", 3)
    elseif fluxus then
        notify("Executor Detected", "Fluxus compatibility enabled", 3)
    else
        notify("Executor Detected", "Generic executor compatibility enabled", 3)
    end
end

optimizeForExecutor()

-- ============================================================
-- GOOGLE GEMINI API KEY CONFIGURATION
-- ============================================================
-- âš ï¸ IMPORTANT: Keep this API key PRIVATE! Never share it publicly!
--
-- Get your FREE API key from: https://aistudio.google.com/app/apikey
-- This enables REAL AI chat for Sentinels using Google Gemini!
--
-- How to set it up:
-- 1. Go to https://aistudio.google.com/app/apikey
-- 2. Click "Create API Key"
-- 3. Copy your key and paste it below (replace the empty quotes)
-- 4. Keep this file private - don't share screenshots with the key visible!
--
-- Example (DON'T use this, it's fake):
-- _G.GoogleAPIKey = "AIzaSyXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"
-- ============================================================

_G.GoogleAPIKey = "" -- ðŸ”‘ PASTE YOUR API KEY HERE (keep it secret!)

if _G.GoogleAPIKey and _G.GoogleAPIKey ~= "" then
    notify("Google Gemini AI", "âœ… API Connected - Sentinels now have REAL AI chat!", 4)
    print("ðŸ¤– Google Gemini AI enabled - Sentinels will use real AI responses!")
else
    print("â„¹ï¸ No API Key - Sentinels will use preset messages")
    print("ðŸ’¡ Get your FREE API key from: https://aistudio.google.com/app/apikey")
    print("ðŸ“ Then paste it in _G.GoogleAPIKey at the bottom of this script")
end

-- ============================================================
-- END OF CONFIGURATION
-- ============================================================

local function forceReplication(part)
    if part and part.Parent then
        local originalCFrame = part.CFrame
        local originalVelocity = part.AssemblyLinearVelocity
        task.spawn(function()
            part.CFrame = originalCFrame * CFrame.new(0.01, 0, 0)
            task.wait()
            part.CFrame = originalCFrame
            part.AssemblyLinearVelocity = originalVelocity
        end)
    end
end

local function enhancedReplicate(part, func)
    local function setNetworkOwnership(part)
        pcall(function()
            if part.Parent and part.Parent ~= player.Character then
                if part.AssemblyRootPart then
                    part.AssemblyRootPart:SetNetworkOwner(player)
                else
                    part:SetNetworkOwner(player)
                end
            end
        end)
    end
    setNetworkOwnership(part)
    local success = safeExecute(func, "Failed to apply physics effect")
    if success then forceReplication(part) end
    return success
end

main()